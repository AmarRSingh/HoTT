<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "	";
            responses[i]=data;
          

            i = 14;
            data = "	";
            responses[i]=data;
          

            i = 15;
            data = "	";
            responses[i]=data;
          

            i = 16;
            data = "	";
            responses[i]=data;
          

            i = 17;
            data = "	";
            responses[i]=data;
          

            i = 18;
            data = "	";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "<infomsg>	Interactive Module RPushout started</infomsg>		";
            responses[i]=data;
          

            i = 45;
            data = "<infomsg>	RPushout is defined</infomsg>		";
            responses[i]=data;
          

            i = 46;
            data = "<infomsg>	glue is assumed</infomsg>		";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>	RPushout_ind is defined</infomsg>		";
            responses[i]=data;
          

            i = 48;
            data = "<infomsg>	RPushout_comp_glue is assumed</infomsg>		";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>	Module RPushout is defined</infomsg>		";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "<infomsg>	RPushout_rec is defined</infomsg>		";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoals, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   ap (RPushout_rec R P i j gl) (glue R a b r) = gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoals, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   ap (RPushout_rec R P i j gl) (glue R a b r) = gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoals, subgoal 1 (ID 48)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   transport_const (glue R a b r) (i a) @	   ap (RPushout_rec R P i j gl) (glue R a b r) =	   transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 58;
            data = "2 subgoals, subgoal 1 (ID 105)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   transport_const (glue R a b r) (i a) @	   ap (RPushout_rec R P i j gl) (glue R a b r) =	   apD (RPushout_rec R P i j gl) (glue R a b r)		subgoal 2 (ID 106) is:	 apD (RPushout_rec R P i j gl) (glue R a b r) =	 transport_const (glue R a b r) (i a) @ gl a b r	(dependent evars:)		";
            responses[i]=data;
          

            i = 59;
            data = "1 subgoals, subgoal 1 (ID 106)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   apD (RPushout_rec R P i j gl) (glue R a b r) =	   transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 60;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 61;
            data = "<infomsg>	RPushout_comp_nd_glue is defined</infomsg>		";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "<infomsg>	bitotal is defined</infomsg>		";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "<infomsg>	Interactive Module CumulativeHierarchy started</infomsg>		";
            responses[i]=data;
          

            i = 75;
            data = "<infomsg>	V is defined</infomsg>		";
            responses[i]=data;
          

            i = 76;
            data = "<infomsg>	setext is assumed</infomsg>		";
            responses[i]=data;
          

            i = 77;
            data = "<infomsg>	is0trunc_V is assumed</infomsg>		";
            responses[i]=data;
          

            i = 78;
            data = "<infomsg>	V_ind is defined</infomsg>	<infomsg>	V_ind is recursively defined (decreasing on 5th argument)</infomsg>		";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "<infomsg>	Module CumulativeHierarchy is defined</infomsg>		";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoals, subgoal 1 (ID 91)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 85;
            data = "1 subgoals, subgoal 1 (ID 91)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 86;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 87;
            data = "<infomsg>	V_comp_setext is defined</infomsg>		";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoals, subgoal 1 (ID 111)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoals, subgoal 1 (ID 111)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 94;
            data = "1 subgoals, subgoal 1 (ID 142)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : RPushout R -> P),	   transport (fun _ : V => P) (setext R bitot_R h)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 95;
            data = "1 subgoals, subgoal 1 (ID 148)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   transport (fun _ : V => P) (setext R bitot_R h)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 96;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 97;
            data = "<infomsg>	V_rec is defined</infomsg>		";
            responses[i]=data;
          

            i = 98;
            data = "1 subgoals, subgoal 1 (ID 147)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 99;
            data = "1 subgoals, subgoal 1 (ID 147)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 100;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 101;
            data = "<infomsg>	V_comp_nd_setext is defined</infomsg>		";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "<infomsg>	equal_img is defined</infomsg>		";
            responses[i]=data;
          

            i = 110;
            data = "1 subgoals, subgoal 1 (ID 163)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 111;
            data = "1 subgoals, subgoal 1 (ID 163)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 112;
            data = "1 subgoals, subgoal 1 (ID 229)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoals, subgoal 1 (ID 233)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  h := RPushout_rec R V f g (fun (a : A) (b : B) => idmap) : RPushout R -> V	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 114;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>	setext' is defined</infomsg>		";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoals, subgoal 1 (ID 175)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoals, subgoal 1 (ID 175)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoals, subgoal 1 (ID 183)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   forall (A B : Type) (R : A -> B -> hProp),	   bitotal R ->	   forall (h : RPushout R -> V) (H_h : RPushout R -> P),	   H_set A (h o inL R) (H_h o inL R) = H_set B (h o inR R) (H_h o inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoals, subgoal 1 (ID 189)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   H_set A (h o inL R) (H_h o inL R) = H_set B (h o inR R) (H_h o inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 120;
            data = "2 subgoals, subgoal 1 (ID 190)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (h o inL R) (h o inR R)		subgoal 2 (ID 191) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 121;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 190)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (h o inL R) (h o inR R)		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 193)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => h (inL R a) = h (inR R b))		subgoal 2 (ID 194) is:	 forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 122;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 193)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 195)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 123;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 198)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (trunctype_type o R a) ->	   hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 124;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 201)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   {b : B & R a b} -> {b : B & h (inL R a) = h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 125;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 206)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & h (inL R a) = h (inR R b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 126;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 208)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   h (inL R a) = h (inR R b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 127;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 194)		subgoal 1 (ID 194) is:	 forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))	subgoal 2 (ID 191) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 128;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 194)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 217)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 129;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 220)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => R a b) ->	   hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 130;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 223)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   {a : A & R a b} -> {a : A & h (inL R a) = h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 131;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 228)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & h (inL R a0) = h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 132;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 230)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   h (inL R a) = h (inR R b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 133;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 191)		subgoal 1 (ID 191) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 134;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 191)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (H_h o inL R) (H_h o inR R)		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 240)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		subgoal 2 (ID 241) is:	 forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 135;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 240)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 242)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 136;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 245)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (trunctype_type o R a) ->	   hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 137;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 248)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   {b : B & R a b} -> {b : B & H_h (inL R a) = H_h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 138;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 253)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & H_h (inL R a) = H_h (inR R b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 139;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 255)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   H_h (inL R a) = H_h (inR R b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 140;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 241)		subgoal 1 (ID 241) is:	 forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 141;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 241)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 264)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 142;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 267)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => R a b) ->	   hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 143;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 270)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   {a : A & R a b} -> {a : A & H_h (inL R a) = H_h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 144;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 275)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & H_h (inL R a0) = H_h (inR R b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 145;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 277)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   H_h (inL R a) = H_h (inR R b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 146;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>	V_rec' is defined</infomsg>		";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoals, subgoal 1 (ID 207)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoals, subgoal 1 (ID 207)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoals, subgoal 1 (ID 210)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoals, subgoal 1 (ID 216)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoals, subgoal 1 (ID 220)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 157;
            data = "1 subgoals, subgoal 1 (ID 224)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoals, subgoal 1 (ID 231)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 159;
            data = "1 subgoals, subgoal 1 (ID 238)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 160;
            data = "2 subgoals, subgoal 1 (ID 242)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   equal_img f g		subgoal 2 (ID 243) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 161;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 242)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   equal_img f g		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 245)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall a : A, hexists (paths (f a) o g)		subgoal 2 (ID 246) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 162;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 245)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall a : A, hexists (paths (f a) o g)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 247)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 163;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 250)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   hexists (trunctype_type o R a) -> hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 164;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 253)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   {b : B & R a b} -> {b : B & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 165;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 258)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 166;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 260)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 167;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 246)		subgoal 1 (ID 246) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 243) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 168;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 246)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 269)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 169;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 272)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  b : B	  ============================	   hexists (fun a : A => R a b) -> hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 170;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 275)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  b : B	  ============================	   {a : A & R a b} -> {a : A & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 171;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 280)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 172;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 282)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a0 : A, P (f a0)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b0 : B, P (g b0)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 173;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 243)		subgoal 1 (ID 243) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 174;
            data = "1 subgoals, subgoal 1 (ID 243)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		2 subgoals, subgoal 1 (ID 375)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R))		subgoal 2 (ID 376) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) = H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 175;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 375)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R))		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 393)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   setext R bitot_R h = setext' (h o inL R) (h o inR R) eq_img		(dependent evars:)		";
            responses[i]=data;
          

            i = 176;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 376)		subgoal 1 (ID 376) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) = H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		1 subgoals, subgoal 1 (ID 376)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		1 subgoals, subgoal 1 (ID 504)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   (forall a : A,	    hexists	      (fun b : B =>	       hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	   (forall b : B,	    hexists	      (fun a : A =>	       hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)))		(dependent evars:)		";
            responses[i]=data;
          

            i = 177;
            data = "2 subgoals, subgoal 1 (ID 506)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		subgoal 2 (ID 507) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 178;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 506)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 508)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 179;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 512)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  ============================	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 180;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 513)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  ============================	   hexists (trunctype_type o R a) ->	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 181;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 516)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  ============================	   {b : B & R a b} ->	   {b : B & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 182;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 521)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   {b0 : B & hexists (fun p : f a = g b0 => transport P p (H_f a) = H_g b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 183;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 523)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 184;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 526)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 185;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 536)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 186;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 557)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) =	   transport (P o h) (glue R a b Rab) (H_h (inL R a))		(dependent evars:)		";
            responses[i]=data;
          

            i = 187;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 561)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   transport (P o h) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 188;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 562)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (trunctype_type o R a)	  b : B	  Rab : R a b	  ============================	   transport (P o h) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 189;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 507)		subgoal 1 (ID 507) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 190;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 507)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall b : B,	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 567)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 191;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 571)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 192;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 572)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   hexists (fun a : A => R a b) ->	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 193;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 575)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   {a : A & R a b} ->	   {a : A & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 194;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 580)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   {a0 : A & hexists (fun p : f a0 = g b => transport P p (H_f a0) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 195;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 582)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 196;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 585)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 197;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 595)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 198;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 616)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) =	   transport (P o h) (glue R a b Rab) (H_h (inL R a))		(dependent evars:)		";
            responses[i]=data;
          

            i = 199;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 620)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport (P o h) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 200;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 621)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport (P o h) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 201;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 202;
            data = "<infomsg>	V_ind' is defined</infomsg>		";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "1 subgoals, subgoal 1 (ID 212)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 208;
            data = "1 subgoals, subgoal 1 (ID 212)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 209;
            data = "1 subgoals, subgoal 1 (ID 278)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 210;
            data = "1 subgoals, subgoal 1 (ID 284)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 211;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 212;
            data = "<infomsg>	V_ind_hprop is defined</infomsg>		";
            responses[i]=data;
          

            i = 213;
            data = "	";
            responses[i]=data;
          

            i = 214;
            data = "<infomsg>	ua is assumed</infomsg>		";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "1 subgoals, subgoal 1 (ID 214)	  	  ua : Univalence	  x : V	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 223;
            data = "1 subgoals, subgoal 1 (ID 214)	  	  ua : Univalence	  x : V	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 224;
            data = "2 subgoals, subgoal 1 (ID 222)	  	  ua : Univalence	  x : V	  ============================	   forall A : Type, (A -> V) -> (A -> hProp) -> hProp		subgoal 2 (ID 225) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g -> ?y A f H_f = ?y B g H_g	(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 open,)		";
            responses[i]=data;
          

            i = 225;
            data = "2 subgoals, subgoal 1 (ID 229)	  	  ua : Univalence	  x : V	  A : Type	  f : A -> V	  ============================	   hProp		subgoal 2 (ID 225) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?t@{A:=A0; f:=f0}) A f	   H_f =	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?t@{A:=A0; f:=f0}) B g	   H_g	(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 open,)		";
            responses[i]=data;
          

            i = 226;
            data = "1 subgoals, subgoal 1 (ID 225)	  	  ua : Univalence	  x : V	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> hProp) (H_g : B -> hProp),	   equal_img H_f H_g ->	   (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	    hexists (fun a : A0 => f0 a = x)) A f H_f =	   (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	    hexists (fun a : A0 => f0 a = x)) B g H_g		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 227;
            data = "1 subgoals, subgoal 1 (ID 232)	  	  ua : Univalence	  x : V	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> hProp) (H_g : B -> hProp),	   equal_img H_f H_g ->	   hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 228;
            data = "1 subgoals, subgoal 1 (ID 243)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 229;
            data = "2 subgoals, subgoal 1 (ID 249)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		subgoal 2 (ID 250) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 230;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 249)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 251)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	   Trunc (-1) {a : B & g a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 231;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 265)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	   {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 232;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 270)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	   Trunc (-1) {a0 : B & g a0 = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 233;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 273)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	   hexists (paths (f a) o g) -> Trunc (-1) {a0 : B & g a0 = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 234;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 276)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	   {b : B & f a = g b} -> {a0 : B & g a0 = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 235;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 281)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	   {a0 : B & g a0 = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 236;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 283)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	   g b = x		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 237;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 250)		subgoal 1 (ID 250) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 238;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 250)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 343)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	   Trunc (-1) {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 239;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 357)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	   {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 240;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 362)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	   Trunc (-1) {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 241;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 365)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	   hexists (fun a : A => f a = g b) -> Trunc (-1) {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 242;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 368)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	   {a : A & f a = g b} -> {a : A & f a = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 243;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 373)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	   {a0 : A & f a0 = x}		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 244;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 375)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	   f a = x		(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 245;
            data = "No more subgoals.	(dependent evars: ?X217 using ?X220 , ?X220 using ?X221 , ?X221 using ?X222 , ?X222 using ?X226 , ?X226 using ?X227 , ?X227 using ?X228 , ?X228 using ?X229 , ?X229 using ,)		";
            responses[i]=data;
          

            i = 246;
            data = "<infomsg>	mem is defined</infomsg>		";
            responses[i]=data;
          

            i = 247;
            data = "	";
            responses[i]=data;
          

            i = 248;
            data = "	";
            responses[i]=data;
          

            i = 249;
            data = "";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "";
            responses[i]=data;
          

            i = 256;
            data = "<infomsg>	subset is defined</infomsg>		";
            responses[i]=data;
          

            i = 257;
            data = "	";
            responses[i]=data;
          

            i = 258;
            data = "";
            responses[i]=data;
          

            i = 259;
            data = "";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "";
            responses[i]=data;
          

            i = 265;
            data = "1 subgoals, subgoal 1 (ID 343)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 266;
            data = "1 subgoals, subgoal 1 (ID 343)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 267;
            data = "2 subgoals, subgoal 1 (ID 622)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   IsHSet hProp		subgoal 2 (ID 623) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	(dependent evars:)		";
            responses[i]=data;
          

            i = 268;
            data = "1 subgoals, subgoal 1 (ID 623)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	   equal_img f0 g ->	   forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	   equal_img H_f0 H_g ->	   BuildhProp	     ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	      (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	   BuildhProp	     ((forall a : A, hexists (fun b : B => H_f a (g b))) *	      (forall b : B, hexists (fun a : A => H_f a (g b))))		(dependent evars:)		";
            responses[i]=data;
          

            i = 269;
            data = "1 subgoals, subgoal 1 (ID 678)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   BuildhProp	     ((forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	      (forall b : B, Trunc (-1) {a : A & H_f a (g b)})) =	   BuildhProp	     ((forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	      (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}))		(dependent evars:)		";
            responses[i]=data;
          

            i = 270;
            data = "2 subgoals, subgoal 1 (ID 684)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	   (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	   (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	   (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})		subgoal 2 (ID 685) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 271;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 684)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	   (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	   (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	   (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 692)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	   forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}		subgoal 2 (ID 693) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 272;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 692)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	   forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 694)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	   Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 273;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 715)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	   {b : B & H_f a (g b)} -> Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 274;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 720)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 275;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 723)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   hexists (paths (g b) o g') -> Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 276;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 724)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   merely {b0 : B' & g b = g' b0} -> Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 277;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 746)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   {b0 : B' & g b = g' b0} -> {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 278;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 751)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	   {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 279;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 753)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	   H_f a (g' b')		(dependent evars:)		";
            responses[i]=data;
          

            i = 280;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 693)		subgoal 1 (ID 693) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	subgoal 2 (ID 685) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 281;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 693)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	   forall b : B', Trunc (-1) {a : A & H_f a (g' b)}		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 757)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	   Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 282;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 782)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	   {a : B & g a = g' b'} -> Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 283;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 787)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 284;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 788)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   Trunc (-1) {a : A & H_f a (g b)} -> Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 285;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 791)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   {a : A & H_f a (g b)} -> {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 286;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 796)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	   {a0 : A & H_f a0 (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 287;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 798)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	   H_f a (g' b')		(dependent evars:)		";
            responses[i]=data;
          

            i = 288;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 685)		subgoal 1 (ID 685) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 289;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 685)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	   (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	   (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	   (forall b : B, Trunc (-1) {a : A & H_f a (g b)})		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 808)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	   forall a : A, Trunc (-1) {b : B & H_f a (g b)}		subgoal 2 (ID 809) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 290;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 808)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	   forall a : A, Trunc (-1) {b : B & H_f a (g b)}		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 810)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	   Trunc (-1) {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 291;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 831)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	   {b : B' & H_f a (g' b)} -> Trunc (-1) {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 292;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 836)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   Trunc (-1) {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 293;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 839)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   hexists (fun a0 : B => g a0 = g' b') -> Trunc (-1) {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 294;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 842)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   {a0 : B & g a0 = g' b'} -> {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 295;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 847)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	   {b0 : B & H_f a (g b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 296;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 849)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	   H_f a (g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 809)		subgoal 1 (ID 809) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 298;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 809)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	   forall b : B, Trunc (-1) {a : A & H_f a (g b)}		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 856)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	   Trunc (-1) {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 299;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 881)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	   {b0 : B' & g b = g' b0} -> Trunc (-1) {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 300;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 886)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   Trunc (-1) {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 301;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 887)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   Trunc (-1) {a : A & H_f a (g' b')} -> Trunc (-1) {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 302;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 890)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   {a : A & H_f a (g' b')} -> {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 303;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 895)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	   {a0 : A & H_f a0 (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 304;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 897)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	   H_f a (g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 305;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 306;
            data = "<infomsg>	bisim_aux is defined</infomsg>		";
            responses[i]=data;
          

            i = 307;
            data = "1 subgoals, subgoal 1 (ID 344)	  	  ua : Univalence	  ============================	   V -> V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 308;
            data = "1 subgoals, subgoal 1 (ID 344)	  	  ua : Univalence	  ============================	   V -> V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 309;
            data = "1 subgoals, subgoal 1 (ID 415)	  	  ua : Univalence	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> V -> hProp) (H_g : B -> V -> hProp),	   equal_img H_f H_g -> bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 310;
            data = "1 subgoals, subgoal 1 (ID 423)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 311;
            data = "1 subgoals, subgoal 1 (ID 448)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   bisim_aux A f H_f == bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 312;
            data = "1 subgoals, subgoal 1 (ID 583)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   forall (A0 : Type) (f0 : A0 -> V),	   (forall a : A0, bisim_aux A f H_f (f0 a) = bisim_aux B g H_g (f0 a)) ->	   bisim_aux A f H_f (set f0) = bisim_aux B g H_g (set f0)		(dependent evars:)		";
            responses[i]=data;
          

            i = 313;
            data = "1 subgoals, subgoal 1 (ID 588)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   bisim_aux A f H_f (set h) = bisim_aux B g H_g (set h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 314;
            data = "2 subgoals, subgoal 1 (ID 596)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	   (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	   (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	   (forall b : C, Trunc (-1) {a : B & H_g a (h b)})		subgoal 2 (ID 599) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 315;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 596)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	   (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	   (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	   (forall b : C, Trunc (-1) {a : B & H_g a (h b)})		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 606)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	   forall a : B, Trunc (-1) {b : C & H_g a (h b)}		subgoal 2 (ID 607) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 316;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 606)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	   forall a : B, Trunc (-1) {b : C & H_g a (h b)}		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 608)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	   Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 317;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 632)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	   {a : A & H_f a = H_g b} -> Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 318;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 637)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 319;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 638)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   Trunc (-1) {b0 : C & H_f a (h b0)} -> Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 320;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 641)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   {b0 : C & H_f a (h b0)} -> {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 321;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 646)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	   {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 322;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 648)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	   H_g b (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 323;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 607)		subgoal 1 (ID 607) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	subgoal 2 (ID 599) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 324;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 607)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	   forall b : C, Trunc (-1) {a : B & H_g a (h b)}		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 657)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	   Trunc (-1) {a : B & H_g a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 325;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 677)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	   {a : A & H_f a (h c)} -> Trunc (-1) {a : B & H_g a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 326;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 682)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   Trunc (-1) {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 327;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 685)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   hexists (paths (H_f a) o H_g) -> Trunc (-1) {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 328;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 688)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   {b : B & H_f a = H_g b} -> {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 329;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 693)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	   {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 330;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 695)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	   H_g b (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 331;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 599)		subgoal 1 (ID 599) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars:)		";
            responses[i]=data;
          

            i = 332;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 599)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	   (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	   (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	   (forall b : C, Trunc (-1) {a : A & H_f a (h b)})		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 710)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	   forall a : A, Trunc (-1) {b : C & H_f a (h b)}		subgoal 2 (ID 711) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 333;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 710)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	   forall a : A, Trunc (-1) {b : C & H_f a (h b)}		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 712)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	   Trunc (-1) {b : C & H_f a (h b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 334;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 736)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	   {b : B & H_f a = H_g b} -> Trunc (-1) {b : C & H_f a (h b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 335;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 741)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   Trunc (-1) {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 336;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 742)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   Trunc (-1) {b0 : C & H_g b (h b0)} -> Trunc (-1) {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 337;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 745)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   {b0 : C & H_g b (h b0)} -> {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 338;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 750)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	   {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 339;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 752)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	   H_f a (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 340;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 711)		subgoal 1 (ID 711) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 341;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 711)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	   forall b : C, Trunc (-1) {a : A & H_f a (h b)}		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 764)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	   Trunc (-1) {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 342;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 784)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	   {a : B & H_g a (h c)} -> Trunc (-1) {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 343;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 789)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   Trunc (-1) {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 344;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 792)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   hexists (fun a : A => H_f a = H_g b) -> Trunc (-1) {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 345;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 795)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   {a : A & H_f a = H_g b} -> {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 346;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 800)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	   {a0 : A & H_f a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 347;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 802)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	   H_f a (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 348;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 349;
            data = "<infomsg>	bisimulation is defined</infomsg>		";
            responses[i]=data;
          

            i = 350;
            data = "	";
            responses[i]=data;
          

            i = 351;
            data = "1 subgoals, subgoal 1 (ID 346)	  	  ua : Univalence	  ============================	   Reflexive (fun x : V => trunctype_type o bisimulation x)		(dependent evars:)		";
            responses[i]=data;
          

            i = 352;
            data = "1 subgoals, subgoal 1 (ID 346)	  	  ua : Univalence	  ============================	   Reflexive (fun x : V => trunctype_type o bisimulation x)		(dependent evars:)		";
            responses[i]=data;
          

            i = 353;
            data = "1 subgoals, subgoal 1 (ID 362)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A, f a ~~ f a) -> set f ~~ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 354;
            data = "1 subgoals, subgoal 1 (ID 372)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   (forall a : A,	    Trunc (-1)	      {b : A &	      V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hprop	                 (fun	                    X : (forall a0 : A0,	                         Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                        (forall b0 : C,	                         Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                  (fun b0 : B =>	                   Trunc_rec	                     (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b1 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b1 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                               proj2_sig)))) (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig)	                                    b0} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((trunctype_type	                                     o R	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a0 : B,	                         Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                        (forall b0 : C,	                         Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                  (fun a0 : A0 =>	                   Trunc_rec	                     (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b0 : B & R a0 b0} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                               (proj1_sig, proj2_sig) as s	                               return ((trunctype_type o R a0) s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a0)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : B =>	                               trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  R a0	                                    (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     trunctype_type	                                       (R a0	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (f b)}) *	   (forall b : A,	    Trunc (-1)	      {a : A &	      V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hprop	                 (fun	                    X : (forall a0 : A0,	                         Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                        (forall b0 : C,	                         Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                  (fun b0 : B =>	                   Trunc_rec	                     (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b1 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b1 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                               proj2_sig)))) (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig)	                                    b0} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((trunctype_type	                                     o R	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a0 : B,	                         Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                        (forall b0 : C,	                         Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                  (fun a0 : A0 =>	                   Trunc_rec	                     (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b0 : B & R a0 b0} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                               (proj1_sig, proj2_sig) as s	                               return ((trunctype_type o R a0) s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a0)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : B =>	                               trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  R a0	                                    (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     trunctype_type	                                       (R a0	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (f b)})		(dependent evars:)		";
            responses[i]=data;
          

            i = 355;
            data = "2 subgoals, subgoal 1 (ID 374)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall a : A,	   Trunc (-1)	     {b : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (h o inL R) (H_h o inL R)) @	        path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	          (bisim_aux B (h o inR R) (H_h o inR R))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0 (h o inL R) (H_h o inL R) v =	              bisim_aux B (h o inR R) (H_h o inR R) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                     bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((trunctype_type	                                    o R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return ((trunctype_type o R a0) s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	       (f a) (f b)}		subgoal 2 (ID 375) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B (h o inR R) (H_h o inR R))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v =	            bisim_aux B (h o inR R) (H_h o inR R) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b1 : C =>	                             trunctype_type	                               (H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 => trunctype_type (R a0 b0)) s.1) :=	                            X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : B =>	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : A0 =>	                            trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((trunctype_type	                                  o R (let (proj1_sig, _) := X0 in proj1_sig))	                                   s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : B => H_h (inL R a0) = H_h (inR R b0))	                                 s.1) := X0 in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b0 : C =>	                             trunctype_type	                               (H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                            (proj1_sig, proj2_sig) as s	                            return ((trunctype_type o R a0) s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig)))	                                s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : B =>	                            trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  trunctype_type	                                    (R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v)	              (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	     (f a) (f b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 356;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 374)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall a : A,	   Trunc (-1)	     {b : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (h o inL R) (H_h o inL R)) @	        path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	          (bisim_aux B (h o inR R) (H_h o inR R))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0 (h o inL R) (H_h o inL R) v =	              bisim_aux B (h o inR R) (H_h o inR R) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                     bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((trunctype_type	                                    o R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return ((trunctype_type o R a0) s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	       (f a) (f b)}		(dependent evars:)		<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 375)		subgoal 1 (ID 375) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B (h o inR R) (H_h o inR R))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v =	            bisim_aux B (h o inR R) (H_h o inR R) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b1 : C =>	                             trunctype_type	                               (H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 => trunctype_type (R a0 b0)) s.1) :=	                            X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : B =>	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : A0 =>	                            trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((trunctype_type	                                  o R (let (proj1_sig, _) := X0 in proj1_sig))	                                   s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : B => H_h (inL R a0) = H_h (inR R b0))	                                 s.1) := X0 in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b0 : C =>	                             trunctype_type	                               (H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                            (proj1_sig, proj2_sig) as s	                            return ((trunctype_type o R a0) s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig)))	                                s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : B =>	                            trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  trunctype_type	                                    (R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v)	              (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	     (f a) (f b)}	(dependent evars:)		";
            responses[i]=data;
          

            i = 357;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 375)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall b : A,	   Trunc (-1)	     {a : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (h o inL R) (H_h o inL R)) @	        path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	          (bisim_aux B (h o inR R) (H_h o inR R))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0 (h o inL R) (H_h o inL R) v =	              bisim_aux B (h o inR R) (H_h o inR R) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                     bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((trunctype_type	                                    o R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return ((trunctype_type o R a0) s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	       (f a) (f b)}		(dependent evars:)		No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 358;
            data = "<infomsg>	reflexive_bisimulation is defined</infomsg>		";
            responses[i]=data;
          

            i = 359;
            data = "1 subgoals, subgoal 1 (ID 348)	  	  ua : Univalence	  ============================	   forall u v : V, u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 360;
            data = "1 subgoals, subgoal 1 (ID 348)	  	  ua : Univalence	  ============================	   forall u v : V, u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 361;
            data = "1 subgoals, subgoal 1 (ID 350)	  	  ua : Univalence	  u, v : V	  ============================	   u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 362;
            data = "2 subgoals, subgoal 1 (ID 391)	  	  ua : Univalence	  u, v : V	  ============================	   u = v -> u ~~ v		subgoal 2 (ID 392) is:	 u ~~ v -> u = v	(dependent evars:)		";
            responses[i]=data;
          

            i = 363;
            data = "1 subgoals, subgoal 1 (ID 392)	  	  ua : Univalence	  u, v : V	  ============================	   u ~~ v -> u = v		(dependent evars:)		";
            responses[i]=data;
          

            i = 364;
            data = "1 subgoals, subgoal 1 (ID 397)	  	  ua : Univalence	  u, v : V	  ============================	   forall u0 v0 : V, u0 ~~ v0 -> u0 = v0		(dependent evars:)		";
            responses[i]=data;
          

            i = 365;
            data = "1 subgoals, subgoal 1 (ID 616)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  ============================	   forall v0 : V, set f ~~ v0 -> set f = v0		(dependent evars:)		";
            responses[i]=data;
          

            i = 366;
            data = "1 subgoals, subgoal 1 (ID 809)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  ============================	   set f ~~ set g -> set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 367;
            data = "1 subgoals, subgoal 1 (ID 821)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 368;
            data = "1 subgoals, subgoal 1 (ID 824)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 369;
            data = "2 subgoals, subgoal 1 (ID 826)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  ============================	   forall a : A, hexists (paths (f a) o g)		subgoal 2 (ID 827) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 370;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 826)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  ============================	   forall a : A, hexists (paths (f a) o g)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 828)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  a : A	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 371;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 829)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  a : A	  ============================	   Trunc (-1)	     {b : B &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	          (bitot_R : bitotal R) (h : RPushout R -> V)	          (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (h o inL R) (H_h o inL R)) @	        path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	          (bisim_aux B0 (h o inR R) (H_h o inR R))	          (V_ind_hprop	             (fun v0 : V =>	              bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	              bisim_aux B0 (h o inR R) (H_h o inR R) v0)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                     bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B0 =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B0 &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B0 =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B0 &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((trunctype_type	                                    o R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B0,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return ((trunctype_type o R a0) s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B0 =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v0 : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	       (f a) (g b)} -> hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 372;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 832)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  a : A	  ============================	   {b : B &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B0 (h o inR R) (H_h o inR R))	        (V_ind_hprop	           (fun v0 : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	            bisim_aux B0 (h o inR R) (H_h o inR R) v0)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B0 =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b1 : C =>	                             trunctype_type	                               (H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 => trunctype_type (R a0 b0)) s.1) :=	                            X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B0 &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : B0 =>	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : A0 =>	                            trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((trunctype_type	                                  o R (let (proj1_sig, _) := X0 in proj1_sig))	                                   s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B0,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : B0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b0 : C =>	                             trunctype_type	                               (H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                            (proj1_sig, proj2_sig) as s	                            return ((trunctype_type o R a0) s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig)))	                                s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : B0 =>	                            trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  trunctype_type	                                    (R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v0 : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	              (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	     (f a) (g b)} -> {b : B & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 373;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 837)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  a : A	  b : B	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A (h o inL R) (H_h o inL R) (h0 a) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1) {b : C & H_h (inL R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : A & H_h (inL R a) (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun X0 : {a : A & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a : A => H_h (inL R a) = H_h (inR R b))	                                    s.1) := X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a : A => trunctype_type (R a b)) s.1) :=	                               X0 in	                               proj2_sig)))) (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : A & H_h (inL R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a : A =>	                               trunctype_type (H_h (inL R a) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig) b}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((trunctype_type	                                     o R	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1) {b : C & H_h (inR R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : B & H_h (inR R a) (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun X0 : {b : B & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b : B => H_h (inL R a) = H_h (inR R b))	                                    s.1) := X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                               (proj1_sig, proj2_sig) as s	                               return ((trunctype_type o R a) s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : B & H_h (inR R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h (inL R a) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : A =>	                                  H_h (inL R a) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a : B =>	                               trunctype_type (H_h (inR R a) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a : A &	                                  R a (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a : A =>	                                     trunctype_type	                                       (R a	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (g b)	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 374;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 827)		subgoal 1 (ID 827) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 375;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 827)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 840)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 376;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 841)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  b : B	  ============================	   Trunc (-1)	     {a : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	          (bitot_R : bitotal R) (h : RPushout R -> V)	          (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (h o inL R) (H_h o inL R)) @	        path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	          (bisim_aux B0 (h o inR R) (H_h o inR R))	          (V_ind_hprop	             (fun v0 : V =>	              bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	              bisim_aux B0 (h o inR R) (H_h o inR R) v0)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                     bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B0 =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B0 &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B0 =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B0 &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((trunctype_type	                                    o R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B0,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                              in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return ((trunctype_type o R a0) s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                             (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                          (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B0 =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v0 : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	       (f a) (g b)} -> hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 377;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 844)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  b : B	  ============================	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B0 (h o inR R) (H_h o inR R))	        (V_ind_hprop	           (fun v0 : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	            bisim_aux B0 (h o inR R) (H_h o inR R) v0)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B0 =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b1 : C =>	                             trunctype_type	                               (H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 => trunctype_type (R a0 b0)) s.1) :=	                            X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B0 &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : B0 =>	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : A0 =>	                            trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((trunctype_type	                                  o R (let (proj1_sig, _) := X0 in proj1_sig))	                                   s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B0,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : B0 =>	                                H_h (inL R a0) = H_h (inR R b0)) s.1) := X0	                            in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                         (proj1_sig, proj2_sig) as s	                         return	                           ((fun b0 : C =>	                             trunctype_type	                               (H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                            (proj1_sig, proj2_sig) as s	                            return ((trunctype_type o R a0) s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               H_h (inL R a0) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig)))	                                s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                        (proj1_sig, proj2_sig) as s	                        return	                          ((fun a0 : B0 =>	                            trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                        X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  trunctype_type	                                    (R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v0 : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	              (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	     (f a) (g b)} -> {a : A & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 378;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 849)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (h o inL R) (H_h o inL R)) @	            path_forall (bisim_aux A (h o inL R) (H_h o inL R))	              (bisim_aux B (h o inR R) (H_h o inR R))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (h o inL R) (H_h o inL R) v =	                  bisim_aux B (h o inR R) (H_h o inR R) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (h o inL R) (H_h o inL R) (h0 a0) =	                         bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b1 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A => trunctype_type (R a0 b0))	                                       s.1) := X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h	                                       (inL R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A =>	                                  trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((trunctype_type	                                        o R	                                            (let	                                             (proj1_sig, _) := X0 in	                                             proj1_sig)) s.1) := X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                  X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let	                                            (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                  (proj1_sig, proj2_sig) as s	                                  return ((trunctype_type o R a0) s.1) := X0	                                  in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     H_h (inL R a0) =	                                     H_h	                                       (inR R	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : B =>	                                  trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                              X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                    (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        trunctype_type	                                          (R a0	                                             (let	                                              (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (h o inL R) (H_h o inL R) v)	                    (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	           (f a) (g b)}	  b : B	  a : A	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A (h o inL R) (H_h o inL R) (h0 a) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1) {b : C & H_h (inL R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : A & H_h (inL R a) (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun X0 : {a : A & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a : A => H_h (inL R a) = H_h (inR R b))	                                    s.1) := X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a : A => trunctype_type (R a b)) s.1) :=	                               X0 in	                               proj2_sig)))) (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : A & H_h (inL R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun b : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a : A =>	                               trunctype_type (H_h (inL R a) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig) b}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((trunctype_type	                                     o R	                                         (let	                                          (proj1_sig, _) := X0 in	                                          proj1_sig)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1) {b : C & H_h (inR R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : B & H_h (inR R a) (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun X0 : {b : B & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                               (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b : B => H_h (inL R a) = H_h (inR R b))	                                    s.1) := X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                            (proj1_sig, proj2_sig) as s	                            return	                              ((fun b : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let	                                         (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                               (proj1_sig, proj2_sig) as s	                               return ((trunctype_type o R a) s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : B & H_h (inR R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h (inL R a) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                              (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : A =>	                                  H_h (inL R a) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                           (proj1_sig, proj2_sig) as s	                           return	                             ((fun a : B =>	                               trunctype_type (H_h (inR R a) (h0 c))) s.1) :=	                           X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a : A &	                                  R a (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                 (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a : A =>	                                     trunctype_type	                                       (R a	                                          (let	                                           (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (g b)	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 379;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 380;
            data = "<infomsg>	bisimulation_equiv_id is defined</infomsg>		";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "<infomsg>	ker_bisim is defined</infomsg>		";
            responses[i]=data;
          

            i = 391;
            data = "1 subgoals, subgoal 1 (ID 355)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars:)		";
            responses[i]=data;
          

            i = 392;
            data = "1 subgoals, subgoal 1 (ID 355)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars:)		";
            responses[i]=data;
          

            i = 393;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 394;
            data = "<infomsg>	ker_bisim_is_ker is defined</infomsg>		";
            responses[i]=data;
          

            i = 395;
            data = "	";
            responses[i]=data;
          

            i = 396;
            data = "";
            responses[i]=data;
          

            i = 397;
            data = "";
            responses[i]=data;
          

            i = 398;
            data = "";
            responses[i]=data;
          

            i = 399;
            data = "";
            responses[i]=data;
          

            i = 400;
            data = "<infomsg>	u is assumed</infomsg>	<infomsg>	Au is assumed</infomsg>	<infomsg>	Au' is assumed</infomsg>	<infomsg>	h is assumed</infomsg>	<infomsg>	h' is assumed</infomsg>	<infomsg>	mu is assumed</infomsg>	<infomsg>	mono is assumed</infomsg>	<infomsg>	mu' is assumed</infomsg>	<infomsg>	mono' is assumed</infomsg>	<infomsg>	p is assumed</infomsg>	<infomsg>	p' is assumed</infomsg>		";
            responses[i]=data;
          

            i = 401;
            data = "1 subgoals, subgoal 1 (ID 368)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   (forall a : Au, {a' : Au' & mu' a' = mu a}) *	   (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars:)		";
            responses[i]=data;
          

            i = 402;
            data = "1 subgoals, subgoal 1 (ID 368)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   (forall a : Au, {a' : Au' & mu' a' = mu a}) *	   (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars:)		";
            responses[i]=data;
          

            i = 403;
            data = "2 subgoals, subgoal 1 (ID 370)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   forall a : Au, {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 371) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars:)		";
            responses[i]=data;
          

            i = 404;
            data = "2 subgoals, subgoal 1 (ID 372)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a : Au	  ============================	   {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 371) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars:)		";
            responses[i]=data;
          

            i = 405;
            data = "1 subgoals, subgoal 1 (ID 371)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   forall a' : Au', {a : Au & mu a = mu' a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 406;
            data = "1 subgoals, subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a' : Au'	  ============================	   {a : Au & mu a = mu' a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 407;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 408;
            data = "<infomsg>	eq_img_untrunc is defined</infomsg>		";
            responses[i]=data;
          

            i = 409;
            data = "<infomsg>	e is defined</infomsg>		";
            responses[i]=data;
          

            i = 410;
            data = "<infomsg>	inv_e is defined</infomsg>		";
            responses[i]=data;
          

            i = 411;
            data = "1 subgoals, subgoal 1 (ID 379)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	   Sect inv_e e		(dependent evars:)		";
            responses[i]=data;
          

            i = 412;
            data = "1 subgoals, subgoal 1 (ID 379)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	   Sect inv_e e		(dependent evars:)		";
            responses[i]=data;
          

            i = 413;
            data = "1 subgoals, subgoal 1 (ID 381)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  a' : Au'	  ============================	   e (inv_e a') = a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 414;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  a' : Au'	  ============================	   mu' (e (inv_e a')) = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 415;
            data = "2 subgoals, subgoal 1 (ID 453)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  a' : Au'	  ============================	   mu' (e (inv_e a')) = mu (inv_e a')		subgoal 2 (ID 454) is:	 mu (inv_e a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 416;
            data = "1 subgoals, subgoal 1 (ID 454)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  a' : Au'	  ============================	   mu (inv_e a') = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 417;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 418;
            data = "<infomsg>	hom1 is defined</infomsg>		";
            responses[i]=data;
          

            i = 419;
            data = "1 subgoals, subgoal 1 (ID 382)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	   Sect e inv_e		(dependent evars:)		";
            responses[i]=data;
          

            i = 420;
            data = "1 subgoals, subgoal 1 (ID 382)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	   Sect e inv_e		(dependent evars:)		";
            responses[i]=data;
          

            i = 421;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a0 : Au => (fst eq_img_untrunc a0).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	   inv_e (e a) = a		(dependent evars:)		";
            responses[i]=data;
          

            i = 422;
            data = "1 subgoals, subgoal 1 (ID 387)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a0 : Au => (fst eq_img_untrunc a0).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	   mu (inv_e (e a)) = mu a		(dependent evars:)		";
            responses[i]=data;
          

            i = 423;
            data = "2 subgoals, subgoal 1 (ID 460)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a0 : Au => (fst eq_img_untrunc a0).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  a : Au	  ============================	   mu (inv_e (e a)) = mu' (e a)		subgoal 2 (ID 461) is:	 mu' (e a) = mu a	(dependent evars:)		";
            responses[i]=data;
          

            i = 424;
            data = "1 subgoals, subgoal 1 (ID 461)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a0 : Au => (fst eq_img_untrunc a0).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  a : Au	  ============================	   mu' (e a) = mu a		(dependent evars:)		";
            responses[i]=data;
          

            i = 425;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 426;
            data = "<infomsg>	hom2 is defined</infomsg>		";
            responses[i]=data;
          

            i = 427;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' = Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 428;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' = Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 429;
            data = "1 subgoals, subgoal 1 (ID 388)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' <~> Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 430;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 431;
            data = "<infomsg>	path is defined</infomsg>		";
            responses[i]=data;
          

            i = 432;
            data = "1 subgoals, subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoals, subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 434;
            data = "1 subgoals, subgoal 1 (ID 433)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu == mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoals, subgoal 1 (ID 435)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := (fun a'0 : Au' =>	           isinj_embedding mu' mono' (e (inv_e a'0)) a'0	             ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun A : Type => A -> V) path^ mu a' = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 436;
            data = "2 subgoals, subgoal 1 (ID 531)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun A : Type => A -> V) path^ mu a' =	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))		subgoal 2 (ID 532) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 437;
            data = "1 subgoals, subgoal 1 (ID 532)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	   mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 438;
            data = "2 subgoals, subgoal 1 (ID 625)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	   mu (transport idmap (path^)^ a')		subgoal 2 (ID 626) is:	 mu (transport idmap (path^)^ a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 439;
            data = "1 subgoals, subgoal 1 (ID 626)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 440;
            data = "2 subgoals, subgoal 1 (ID 711)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu (inv_e a')		subgoal 2 (ID 712) is:	 mu (inv_e a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 441;
            data = "1 subgoals, subgoal 1 (ID 711)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu (inv_e a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 442;
            data = "1 subgoals, subgoal 1 (ID 740)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap (path^)^ a' = inv_e a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 443;
            data = "2 subgoals, subgoal 1 (ID 824)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap (path^)^ a' = transport idmap path a'		subgoal 2 (ID 825) is:	 transport idmap path a' = inv_e a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 444;
            data = "1 subgoals, subgoal 1 (ID 825)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a'0 : Au' => (snd eq_img_untrunc a'0).1 : Au' -> Au	  hom1 := fun a'0 : Au' =>	          isinj_embedding mu' mono' (e (inv_e a'0)) a'0	            ((fst eq_img_untrunc (inv_e a'0)).2 @ (snd eq_img_untrunc a'0).2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap path a' = inv_e a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 445;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 446;
            data = "<infomsg>	mu_eq_mu' is defined</infomsg>		";
            responses[i]=data;
          

            i = 447;
            data = "1 subgoals, subgoal 1 (ID 415)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 448;
            data = "1 subgoals, subgoal 1 (ID 415)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 449;
            data = "1 subgoals, subgoal 1 (ID 418)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   {p0 : Au = Au' &	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     p0 (mu; (h, mono, p)) = (mu'; (h', mono', p'))}		(dependent evars:)		";
            responses[i]=data;
          

            i = 450;
            data = "1 subgoals, subgoal 1 (ID 423)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     path^ (mu; (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 451;
            data = "2 subgoals, subgoal 1 (ID 523)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     path^ (mu; (h, mono, p)) =	   (transport (fun A : Type => A -> V) path^ mu;	   transportD (fun A : Type => A -> V)	     (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	      IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	     (h, mono, p))		subgoal 2 (ID 524) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 452;
            data = "1 subgoals, subgoal 1 (ID 524)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (transport (fun A : Type => A -> V) path^ mu;	   transportD (fun A : Type => A -> V)	     (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	      IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	     (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 453;
            data = "1 subgoals, subgoal 1 (ID 1165)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 454;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 455;
            data = "<infomsg>	monic_set_present_uniqueness is defined</infomsg>		";
            responses[i]=data;
          

            i = 456;
            data = "	";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "";
            responses[i]=data;
          

            i = 461;
            data = "1 subgoals, subgoal 1 (ID 362)	  	  ua : Univalence	  ============================	   forall u : V,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 462;
            data = "1 subgoals, subgoal 1 (ID 362)	  	  ua : Univalence	  ============================	   forall u : V,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 463;
            data = "2 subgoals, subgoal 1 (ID 363)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A,	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		subgoal 2 (ID 364) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 464;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 363)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A,	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 368)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 465;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 441)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   {Au0 : Type &	   {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (set f = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 466;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 445)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   IsHSet Au * IsEmbedding mu * (set f = set mu)		(dependent evars:)		";
            responses[i]=data;
          

            i = 467;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 447)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   IsHSet Au * IsEmbedding mu		subgoal 2 (ID 448) is:	 set f = set mu	(dependent evars:)		";
            responses[i]=data;
          

            i = 468;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 448)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   set f = set mu		(dependent evars:)		";
            responses[i]=data;
          

            i = 469;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 455)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall a : A, hexists (paths (f a) o mu)		subgoal 2 (ID 456) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 470;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 455)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall a : A, hexists (paths (f a) o mu)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 457)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a : A	  ============================	   hexists (paths (f a) o mu)		(dependent evars:)		";
            responses[i]=data;
          

            i = 471;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 462)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a : A	  ============================	   f a = mu (eu a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 472;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 456)		subgoal 1 (ID 456) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	subgoal 2 (ID 364) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 473;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 456)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall b : Au, hexists (fun a : A => f a = mu b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 467)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  ============================	   hexists (fun a : A => f a = mu a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 474;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 468)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  ============================	   TrM.IsConnected (-1)%trunc (hfiber eu a') ->	   hexists (fun a : A => f a = mu a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 475;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 529)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : TrM.IsConnected (-1)%trunc (hfiber eu a')	  ============================	   hfiber eu a' -> {a : A & f a = mu a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 476;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 534)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : TrM.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   {a0 : A & f a0 = mu a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 477;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 536)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : TrM.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   f a = mu a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 478;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 601)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : TrM.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   f a = mu (eu a)		subgoal 2 (ID 602) is:	 mu (eu a) = mu a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 479;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 602)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : TrM.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   mu (eu a) = mu a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 480;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 364)		subgoal 1 (ID 364) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 481;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 364)	  	  ua : Univalence	  ============================	   forall v : V,	   IsHProp	     {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 611)	  	  ua : Univalence	  v : V	  ============================	   IsHProp	     {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 482;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 612)	  	  ua : Univalence	  v : V	  ============================	   forall	     x	      y : {Au : Type &	          {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}, 	   x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 483;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 629)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  ============================	   forall	     y : {Au0 : Type &	         {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (v = set m)}},	   (Au; (mu; (hset, mono, p))) = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 484;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 646)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  Au' : Type	  mu' : Au' -> V	  hset' : IsHSet Au'	  mono' : IsEmbedding mu'	  p' : v = set mu'	  ============================	   (Au; (mu; (hset, mono, p))) = (Au'; (mu'; (hset', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 485;
            data = "No more subgoals.	(dependent evars: ?X647 using , ?X648 using , ?X649 using , ?X652 using , ?X654 using ,)		";
            responses[i]=data;
          

            i = 486;
            data = "<infomsg>	monic_set_present is defined</infomsg>		";
            responses[i]=data;
          

            i = 487;
            data = "<infomsg>	type_of_members is defined</infomsg>		";
            responses[i]=data;
          

            i = 488;
            data = "	";
            responses[i]=data;
          

            i = 489;
            data = "<infomsg>	func_of_members is defined</infomsg>		";
            responses[i]=data;
          

            i = 490;
            data = "<infomsg>	is_hset_typeofmembers is defined</infomsg>		";
            responses[i]=data;
          

            i = 491;
            data = "<infomsg>	IsEmbedding_funcofmembers is defined</infomsg>		";
            responses[i]=data;
          

            i = 492;
            data = "<infomsg>	is_valid_presentation is defined</infomsg>		";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "";
            responses[i]=data;
          

            i = 497;
            data = "";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "1 subgoals, subgoal 1 (ID 398)	  	  ua : Univalence	  ============================	   forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 501;
            data = "1 subgoals, subgoal 1 (ID 398)	  	  ua : Univalence	  ============================	   forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 502;
            data = "1 subgoals, subgoal 1 (ID 694)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall (a : A) (y : V), f a ⊆ y * y ⊆ f a <-> f a = y) ->	   forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 503;
            data = "1 subgoals, subgoal 1 (ID 698)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 504;
            data = "1 subgoals, subgoal 1 (ID 988)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall (A0 : Type) (f0 : A0 -> V),	   (forall a : A0, set f ⊆ f0 a * f0 a ⊆ set f <-> set f = f0 a) ->	   set f ⊆ set f0 * set f0 ⊆ set f <-> set f = set f0		(dependent evars:)		";
            responses[i]=data;
          

            i = 505;
            data = "1 subgoals, subgoal 1 (ID 992)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f <-> set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 506;
            data = "2 subgoals, subgoal 1 (ID 994)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f -> set f = set g		subgoal 2 (ID 995) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 507;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 994)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f -> set f = set g		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 1000)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 508;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 1003)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 509;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 1005)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall a : A, hexists (paths (f a) o g)		subgoal 2 (ID 1006) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 510;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1005)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall a : A, hexists (paths (f a) o g)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1007)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 511;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1031)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	   {a0 : B & g a0 = f a} -> hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 512;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1036)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 513;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1039)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 514;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 1041)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 515;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 1006)		subgoal 1 (ID 1006) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 995) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 516;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 1006)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 1045)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 517;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 1046)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	   g b ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 518;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 995)		subgoal 1 (ID 995) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 519;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 995)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f = set g -> set f ⊆ set g * set g ⊆ set f		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 1055)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set f ⊆ set g		subgoal 2 (ID 1056) is:	 set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 520;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 1055)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set f ⊆ set g		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 1059)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set f	  ============================	   z ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 521;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 1056)		subgoal 1 (ID 1056) is:	 set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 522;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 1056)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set g ⊆ set f		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 1065)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set g	  ============================	   z ∈ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 523;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 524;
            data = "<infomsg>	extensionality is defined</infomsg>		";
            responses[i]=data;
          

            i = 525;
            data = "1 subgoals, subgoal 1 (ID 403)	  	  ua : Univalence	  C : V -> hProp	  ============================	   (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 526;
            data = "1 subgoals, subgoal 1 (ID 403)	  	  ua : Univalence	  C : V -> hProp	  ============================	   (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 527;
            data = "1 subgoals, subgoal 1 (ID 404)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	   forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 528;
            data = "1 subgoals, subgoal 1 (ID 430)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	   forall (A : Type) (f : A -> V), (forall a : A, C (f a)) -> C (set f)		(dependent evars:)		";
            responses[i]=data;
          

            i = 529;
            data = "1 subgoals, subgoal 1 (ID 433)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	   C (set f)		(dependent evars:)		";
            responses[i]=data;
          

            i = 530;
            data = "1 subgoals, subgoal 1 (ID 434)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	   forall x : V, x ∈ set f -> C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 531;
            data = "1 subgoals, subgoal 1 (ID 436)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	   C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 532;
            data = "1 subgoals, subgoal 1 (ID 442)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	   {a : A & f a = x} -> C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 533;
            data = "1 subgoals, subgoal 1 (ID 447)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  a : A	  p : f a = x	  ============================	   C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 534;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 535;
            data = "<infomsg>	mem_induction is defined</infomsg>		";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "";
            responses[i]=data;
          

            i = 543;
            data = "1 subgoals, subgoal 1 (ID 405)	  	  ua : Univalence	  ============================	   Irreflexive (fun x : V => trunctype_type o mem x)		(dependent evars:)		";
            responses[i]=data;
          

            i = 544;
            data = "1 subgoals, subgoal 1 (ID 405)	  	  ua : Univalence	  ============================	   Irreflexive (fun x : V => trunctype_type o mem x)		(dependent evars:)		";
            responses[i]=data;
          

            i = 545;
            data = "2 subgoals, subgoal 1 (ID 408)	  	  ua : Univalence	  ============================	   forall v : V,	   IsHProp (complement (fun x : V => trunctype_type o mem x) v v)		subgoal 2 (ID 409) is:	 Irreflexive (fun x : V => trunctype_type o mem x)	(dependent evars:)		";
            responses[i]=data;
          

            i = 546;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 408)	  	  ua : Univalence	  ============================	   forall v : V,	   IsHProp (complement (fun x : V => trunctype_type o mem x) v v)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 410)	  	  ua : Univalence	  v : V	  ============================	   IsHProp (complement (fun x : V => trunctype_type o mem x) v v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 547;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 411)	  	  ua : Univalence	  v : V	  ============================	   IsHProp (~ v ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 548;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 409)		subgoal 1 (ID 409) is:	 Irreflexive (fun x : V => trunctype_type o mem x)	(dependent evars:)		1 subgoals, subgoal 1 (ID 409)	  	  ua : Univalence	  X : forall v : V,	      IsHProp (complement (fun x : V => trunctype_type o mem x) v v)	  ============================	   Irreflexive (fun x : V => trunctype_type o mem x)		(dependent evars:)		1 subgoals, subgoal 1 (ID 526)	  	  ua : Univalence	  X : forall v : V,	      IsHProp (complement (fun x : V => trunctype_type o mem x) v v)	  ============================	   forall v : V, (forall x : V, x ∈ v -> ~ x ∈ x) -> ~ v ∈ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 549;
            data = "1 subgoals, subgoal 1 (ID 528)	  	  ua : Univalence	  X : forall v : V,	      IsHProp (complement (fun x : V => trunctype_type o mem x) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  ============================	   ~ v ∈ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 550;
            data = "1 subgoals, subgoal 1 (ID 530)	  	  ua : Univalence	  X : forall v : V,	      IsHProp (complement (fun x : V => trunctype_type o mem x) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  Hv : v ∈ v	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 551;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 552;
            data = "<infomsg>	irreflexive_mem is defined</infomsg>		";
            responses[i]=data;
          

            i = 553;
            data = "1 subgoals, subgoal 1 (ID 418)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	   set f = set g -> equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 554;
            data = "1 subgoals, subgoal 1 (ID 418)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	   set f = set g -> equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 555;
            data = "1 subgoals, subgoal 1 (ID 419)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 556;
            data = "2 subgoals, subgoal 1 (ID 421)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall a : A, hexists (paths (f a) o g)		subgoal 2 (ID 422) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 557;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 421)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall a : A, hexists (paths (f a) o g)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 423)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 558;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 425)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set g		subgoal 2 (ID 426) is:	 hexists (paths (f a) o g)	(dependent evars:)		";
            responses[i]=data;
          

            i = 559;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 425)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set g		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 434)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 560;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 426)		subgoal 1 (ID 426) is:	 hexists (paths (f a) o g)	subgoal 2 (ID 422) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 426)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	   hexists (paths (f a) o g)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 444)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	   {a0 : B & g a0 = f a} -> {b : B & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 561;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 449)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  b : B	  p' : g b = f a	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 562;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 422)		subgoal 1 (ID 422) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 563;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 422)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 455)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 564;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 457)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set f		subgoal 2 (ID 458) is:	 hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 565;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 457)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set f		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 469)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 566;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 458)		subgoal 1 (ID 458) is:	 hexists (fun a : A => f a = g b)	(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 458)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 479)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	   {a : A & f a = g b} -> {a : A & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 567;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 484)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  a : A	  p' : f a = g b	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 568;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 569;
            data = "<infomsg>	path_V_eqimg is defined</infomsg>		";
            responses[i]=data;
          

            i = 570;
            data = "";
            responses[i]=data;
          

            i = 571;
            data = "";
            responses[i]=data;
          

            i = 572;
            data = "";
            responses[i]=data;
          

            i = 573;
            data = "";
            responses[i]=data;
          

            i = 574;
            data = "";
            responses[i]=data;
          

            i = 575;
            data = "";
            responses[i]=data;
          

            i = 576;
            data = "";
            responses[i]=data;
          

            i = 577;
            data = "";
            responses[i]=data;
          

            i = 578;
            data = "";
            responses[i]=data;
          

            i = 579;
            data = "<infomsg>	V_empty is defined</infomsg>		";
            responses[i]=data;
          

            i = 580;
            data = "";
            responses[i]=data;
          

            i = 581;
            data = "";
            responses[i]=data;
          

            i = 582;
            data = "";
            responses[i]=data;
          

            i = 583;
            data = "";
            responses[i]=data;
          

            i = 584;
            data = "<infomsg>	V_singleton is defined</infomsg>		";
            responses[i]=data;
          

            i = 585;
            data = "1 subgoals, subgoal 1 (ID 428)	  	  ua : Univalence	  u, v : V	  ============================	   IsEquiv (ap V_singleton)		(dependent evars:)		";
            responses[i]=data;
          

            i = 586;
            data = "1 subgoals, subgoal 1 (ID 428)	  	  ua : Univalence	  u, v : V	  ============================	   IsEquiv (ap V_singleton)		(dependent evars:)		";
            responses[i]=data;
          

            i = 587;
            data = "1 subgoals, subgoal 1 (ID 439)	  	  ua : Univalence	  u, v : V	  ============================	   V_singleton u = V_singleton v -> u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 open, ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 ,)		";
            responses[i]=data;
          

            i = 588;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 439)	  	  ua : Univalence	  u, v : V	  ============================	   V_singleton u = V_singleton v -> u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 open, ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 833)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	   u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 open,)		";
            responses[i]=data;
          

            i = 589;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 838)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	   equal_img (Unit_ind u) (Unit_ind v) -> u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 open, ?X839 using ,)		";
            responses[i]=data;
          

            i = 590;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 844)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (paths (Unit_ind u a) o Unit_ind v)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	   u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 using ?X840 , ?X839 using , ?X840 using ?X841 , ?X841 using ?X842 , ?X842 using ?X843 , ?X843 using ?X844 , ?X844 open,)		";
            responses[i]=data;
          

            i = 591;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 912)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (paths (Unit_ind u a) o Unit_ind v)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	   {b : Unit & Unit_ind u tt = Unit_ind v b} -> u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 using ?X840 , ?X839 using , ?X840 using ?X841 , ?X841 using ?X842 , ?X842 using ?X843 , ?X843 using ?X844 , ?X844 using ?X849 , ?X849 using ?X906 , ?X906 using ?X907 , ?X907 using ?X908 , ?X908 using ?X909 , ?X909 using ?X910 , ?X910 using ?X911 , ?X911 using ?X912 , ?X912 open,)		";
            responses[i]=data;
          

            i = 592;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 917)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (paths (Unit_ind u a) o Unit_ind v)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  t : Unit	  p : Unit_ind u tt = Unit_ind v t	  ============================	   u = v		(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 using ?X840 , ?X839 using , ?X840 using ?X841 , ?X841 using ?X842 , ?X842 using ?X843 , ?X843 using ?X844 , ?X844 using ?X849 , ?X849 using ?X906 , ?X906 using ?X907 , ?X907 using ?X908 , ?X908 using ?X909 , ?X909 using ?X910 , ?X910 using ?X911 , ?X911 using ?X912 , ?X912 using ?X913 , ?X913 using ?X914 , ?X914 using ?X915 , ?X915 using ?X916 , ?X916 using ?X917 , ?X917 open,)		";
            responses[i]=data;
          

            i = 593;
            data = "No more subgoals.	(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 using ?X840 , ?X839 using , ?X840 using ?X841 , ?X841 using ?X842 , ?X842 using ?X843 , ?X843 using ?X844 , ?X844 using ?X849 , ?X849 using ?X906 , ?X906 using ?X907 , ?X907 using ?X908 , ?X908 using ?X909 , ?X909 using ?X910 , ?X910 using ?X911 , ?X911 using ?X912 , ?X912 using ?X913 , ?X913 using ?X914 , ?X914 using ?X915 , ?X915 using ?X916 , ?X916 using ?X917 , ?X917 using ?X918 , ?X918 using ?X919 , ?X919 using ?X920 , ?X920 using ?X921 , ?X921 using ?X922 , ?X922 using ?X923 , ?X923 using ,)		No more subgoals.	(dependent evars: ?X432 using ?X436 , ?X433 using ?X440 ?X432 , ?X434 using ?X444 ?X432 , ?X436 using ?X437 , ?X437 using ?X438 , ?X438 using ?X439 , ?X439 using ?X833 , ?X440 using ?X441 , ?X441 using ?X442 , ?X442 using ?X443 , ?X443 using ?X588 ?X439 , ?X444 using ?X445 , ?X445 using ?X446 , ?X446 using ?X447 , ?X447 using ?X634 ?X439 , ?X588 using ?X589 , ?X589 using ?X439 , ?X634 using ?X635 , ?X635 using ?X439 , ?X833 using ?X839 ?X838 , ?X838 using ?X840 , ?X839 using , ?X840 using ?X841 , ?X841 using ?X842 , ?X842 using ?X843 , ?X843 using ?X844 , ?X844 using ?X849 , ?X849 using ?X906 , ?X906 using ?X907 , ?X907 using ?X908 , ?X908 using ?X909 , ?X909 using ?X910 , ?X910 using ?X911 , ?X911 using ?X912 , ?X912 using ?X913 , ?X913 using ?X914 , ?X914 using ?X915 , ?X915 using ?X916 , ?X916 using ?X917 , ?X917 using ?X918 , ?X918 using ?X919 , ?X919 using ?X920 , ?X920 using ?X921 , ?X921 using ?X922 , ?X922 using ?X923 , ?X923 using ,)		<infomsg>	isequiv_ap_V_singleton is defined</infomsg>		";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "";
            responses[i]=data;
          

            i = 596;
            data = "";
            responses[i]=data;
          

            i = 597;
            data = "";
            responses[i]=data;
          

            i = 598;
            data = "<infomsg>	V_pair is defined</infomsg>		";
            responses[i]=data;
          

            i = 599;
            data = "1 subgoals, subgoal 1 (ID 437)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	   (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars:)		";
            responses[i]=data;
          

            i = 600;
            data = "1 subgoals, subgoal 1 (ID 437)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	   (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars:)		";
            responses[i]=data;
          

            i = 601;
            data = "1 subgoals, subgoal 1 (ID 442)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   V_pair u v = V_pair u' v'		(dependent evars:)		";
            responses[i]=data;
          

            i = 602;
            data = "1 subgoals, subgoal 1 (ID 445)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   equal_img (fun b : Bool => if b then u else v)	     (fun b : Bool => if b then u' else v')		(dependent evars:)		";
            responses[i]=data;
          

            i = 603;
            data = "2 subgoals, subgoal 1 (ID 447)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall a : Bool,	   hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		subgoal 2 (ID 448) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 604;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 447)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall a : Bool,	   hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 449)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun b : Bool => u = (if b then u' else v'))		subgoal 2 (ID 450) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 605;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 455)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   u = u'		subgoal 2 (ID 450) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 606;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 450)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun b : Bool => v = (if b then u' else v'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 607;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 448)		subgoal 1 (ID 448) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 608;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 448)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall b : Bool,	   hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 461)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun a : Bool => (if a then u else v) = u')		subgoal 2 (ID 462) is:	 hexists (fun a : Bool => (if a then u else v) = v')	(dependent evars:)		";
            responses[i]=data;
          

            i = 609;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 462)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun a : Bool => (if a then u else v) = v')		(dependent evars:)		";
            responses[i]=data;
          

            i = 610;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 611;
            data = "<infomsg>	path_pair is defined</infomsg>		";
            responses[i]=data;
          

            i = 612;
            data = "1 subgoals, subgoal 1 (ID 444)	  	  ua : Univalence	  u, v, w : V	  ============================	   V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 613;
            data = "1 subgoals, subgoal 1 (ID 444)	  	  ua : Univalence	  u, v, w : V	  ============================	   V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 614;
            data = "2 subgoals, subgoal 1 (ID 446)	  	  ua : Univalence	  u, v, w : V	  ============================	   V_pair u v = V_singleton w -> (u = w) * (v = w)		subgoal 2 (ID 447) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars:)		";
            responses[i]=data;
          

            i = 615;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 446)	  	  ua : Univalence	  u, v, w : V	  ============================	   V_pair u v = V_singleton w -> (u = w) * (v = w)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 448)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 616;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 458)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 617;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 658)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	   {b : Unit & u = Unit_ind w b} -> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 618;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 669)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 619;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 888)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	   {b : Unit & v = Unit_ind w b} -> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 620;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 899)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  p' : v = Unit_ind w tt	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 621;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 447)		subgoal 1 (ID 447) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars:)		";
            responses[i]=data;
          

            i = 622;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 447)	  	  ua : Univalence	  u, v, w : V	  ============================	   (u = w) * (v = w) -> V_pair u v = V_singleton w		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 907)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	   V_pair u v = V_singleton w		(dependent evars:)		";
            responses[i]=data;
          

            i = 623;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 912)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	   forall a : Bool, hexists (paths (if a then u else v) o Unit_ind w)		subgoal 2 (ID 913) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 624;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 919)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  a : Bool	  ============================	   (if a then u else v) = Unit_ind w tt		subgoal 2 (ID 913) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 625;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 913)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	   forall b : Unit,	   hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 626;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 930)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  t : Unit	  ============================	   u = Unit_ind w t		(dependent evars:)		";
            responses[i]=data;
          

            i = 627;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 628;
            data = "<infomsg>	pair_eq_singleton is defined</infomsg>		";
            responses[i]=data;
          

            i = 629;
            data = "";
            responses[i]=data;
          

            i = 630;
            data = "";
            responses[i]=data;
          

            i = 631;
            data = "";
            responses[i]=data;
          

            i = 632;
            data = "";
            responses[i]=data;
          

            i = 633;
            data = "<infomsg>	V_pair_ord is defined</infomsg>		";
            responses[i]=data;
          

            i = 634;
            data = "	";
            responses[i]=data;
          

            i = 635;
            data = "1 subgoals, subgoal 1 (ID 452)	  	  ua : Univalence	  a, b, c, d : V	  ============================	   [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 636;
            data = "1 subgoals, subgoal 1 (ID 452)	  	  ua : Univalence	  a, b, c, d : V	  ============================	   [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 637;
            data = "2 subgoals, subgoal 1 (ID 454)	  	  ua : Univalence	  a, b, c, d : V	  ============================	   [a, b] = [c, d] -> (a = c) * (b = d)		subgoal 2 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 638;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 454)	  	  ua : Univalence	  a, b, c, d : V	  ============================	   [a, b] = [c, d] -> (a = c) * (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 456)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 639;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 458)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   a = c		subgoal 2 (ID 459) is:	 (a = c) * (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 640;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 458)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   a = c		(dependent evars:)		2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 460)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [c, d]		subgoal 2 (ID 461) is:	 a = c	(dependent evars:)		";
            responses[i]=data;
          

            i = 641;
            data = "1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 460)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 469)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [a, b]		(dependent evars:)		";
            responses[i]=data;
          

            i = 642;
            data = "1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 471)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	   Trunc (-1)	     {a0 : Bool & (if a0 then V_singleton a else V_pair a b) = V_singleton a}		(dependent evars:)		";
            responses[i]=data;
          

            i = 643;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 461)		subgoal 1 (ID 461) is:	 a = c	subgoal 2 (ID 459) is:	 (a = c) * (b = d)	subgoal 3 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 461)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	   a = c		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 552)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	   {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_singleton a} ->	   a = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 644;
            data = "2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 566)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	   a = c		subgoal 2 (ID 567) is:	 a = c	(dependent evars:)		";
            responses[i]=data;
          

            i = 645;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 567)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_pair c d = V_singleton a	  ============================	   a = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 646;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 459)		subgoal 1 (ID 459) is:	 (a = c) * (b = d)	subgoal 2 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 647;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 459)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   (a = c) * (b = d)		(dependent evars:)		2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 617)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   a = c		subgoal 2 (ID 618) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 648;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 618)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 649;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 621)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   hor (b = c) (b = d)		subgoal 2 (ID 622) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 650;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 621)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   hor (b = c) (b = d)		(dependent evars:)		2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 623)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [c, d]		subgoal 2 (ID 624) is:	 hor (b = c) (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 651;
            data = "1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 623)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 632)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [a, b]		(dependent evars:)		";
            responses[i]=data;
          

            i = 652;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 624)		subgoal 1 (ID 624) is:	 hor (b = c) (b = d)	subgoal 2 (ID 622) is:	 b = d	subgoal 3 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 624)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	   hor (b = c) (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 654)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	   {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_pair a b} ->	   hor (b = c) (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 653;
            data = "2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 668)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   hor (b = c) (b = d)		subgoal 2 (ID 669) is:	 hor (b = c) (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 654;
            data = "1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 668)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   hor (b = c) (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 674)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   b = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 655;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 669)		subgoal 1 (ID 669) is:	 hor (b = c) (b = d)	subgoal 2 (ID 622) is:	 b = d	subgoal 3 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 656;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 669)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  ============================	   hor (b = c) (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 696)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	   hor (b = c) (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 657;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 700)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	   {a0 : Bool & (if a0 then c else d) = b} -> (b = c) + (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 658;
            data = "2 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 714)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	   (b = c) + (b = d)		subgoal 2 (ID 715) is:	 (b = c) + (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 659;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 715)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : d = b	  ============================	   (b = c) + (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 660;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 622)		subgoal 1 (ID 622) is:	 b = d	subgoal 2 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 622)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	   b = d		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 807)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	   (b = c) + (b = d) -> b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 661;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 814)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   b = d		subgoal 2 (ID 815) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 662;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 814)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 663;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 817)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   [a, b] = V_singleton (V_singleton b)		subgoal 2 (ID 818) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 664;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 817)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   [a, b] = V_singleton (V_singleton b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 824)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   (V_singleton a = V_singleton b) * (V_pair a b = V_singleton b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 665;
            data = "2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 826)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   V_singleton a = V_singleton b		subgoal 2 (ID 827) is:	 V_pair a b = V_singleton b	(dependent evars:)		";
            responses[i]=data;
          

            i = 666;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 827)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   V_pair a b = V_singleton b		(dependent evars:)		";
            responses[i]=data;
          

            i = 667;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 843)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   (a = b) * (b = b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 668;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 818)		subgoal 1 (ID 818) is:	 b = d	subgoal 2 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 669;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 818)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  ============================	   b = d		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 857)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  H'' : V_pair c d = V_singleton b	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 670;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 455)		subgoal 1 (ID 455) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 671;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 455)	  	  ua : Univalence	  a, b, c, d : V	  ============================	   (a = c) * (b = d) -> [a, b] = [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 927)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	   [a, b] = [c, d]		(dependent evars:)		";
            responses[i]=data;
          

            i = 672;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 932)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	   (V_singleton a = V_singleton c) * (V_pair a b = V_pair c d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 673;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 934)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	   V_singleton a = V_singleton c		subgoal 2 (ID 935) is:	 V_pair a b = V_pair c d	(dependent evars:)		";
            responses[i]=data;
          

            i = 674;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 935)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	   V_pair a b = V_pair c d		(dependent evars:)		";
            responses[i]=data;
          

            i = 675;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 943)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	   (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 676;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 677;
            data = "<infomsg>	path_pair_ord is defined</infomsg>		";
            responses[i]=data;
          

            i = 678;
            data = "";
            responses[i]=data;
          

            i = 679;
            data = "";
            responses[i]=data;
          

            i = 680;
            data = "";
            responses[i]=data;
          

            i = 681;
            data = "";
            responses[i]=data;
          

            i = 682;
            data = "<infomsg>	V_cart_prod is defined</infomsg>		";
            responses[i]=data;
          

            i = 683;
            data = "Toplevel input, characters 0-68:	> Notation \" a * b \" := (V_cart_prod a b)	>   (at level 25) : set_scope. 	Error: Notation _ * _ is already defined at level 40 with arguments	at level 40, at next level while it is now required to be at level 25	with arguments at next level, at next level.	";
            responses[i]=data;
          

            i = 684;
            data = "";
            responses[i]=data;
          

            i = 685;
            data = "";
            responses[i]=data;
          

            i = 686;
            data = "";
            responses[i]=data;
          

            i = 687;
            data = "";
            responses[i]=data;
          

            i = 688;
            data = "Toplevel input, characters 58-59:	> Definition V_is_func (a : V) (b : V) (f : V) := f ⊆ a * b	>                                                         ^	Error:	In environment	ua : Univalence	a : V	b : V	f : V	The term \"b\" has type \"V\" while it is expected to have type \"Type\".	";
            responses[i]=data;
          

            i = 689;
            data = "";
            responses[i]=data;
          

            i = 690;
            data = "";
            responses[i]=data;
          

            i = 691;
            data = "";
            responses[i]=data;
          

            i = 692;
            data = "";
            responses[i]=data;
          

            i = 693;
            data = "<infomsg>	V_func is defined</infomsg>		";
            responses[i]=data;
          

            i = 694;
            data = "";
            responses[i]=data;
          

            i = 695;
            data = "";
            responses[i]=data;
          

            i = 696;
            data = "";
            responses[i]=data;
          

            i = 697;
            data = "";
            responses[i]=data;
          

            i = 698;
            data = "<infomsg>	V_union is defined</infomsg>		";
            responses[i]=data;
          

            i = 699;
            data = "";
            responses[i]=data;
          

            i = 700;
            data = "";
            responses[i]=data;
          

            i = 701;
            data = "";
            responses[i]=data;
          

            i = 702;
            data = "";
            responses[i]=data;
          

            i = 703;
            data = "1 subgoals, subgoal 1 (ID 469)	  	  ua : Univalence	  ============================	   V -> V		(dependent evars:)		";
            responses[i]=data;
          

            i = 704;
            data = "1 subgoals, subgoal 1 (ID 469)	  	  ua : Univalence	  ============================	   V -> V		(dependent evars:)		";
            responses[i]=data;
          

            i = 705;
            data = "2 subgoals, subgoal 1 (ID 475)	  	  ua : Univalence	  ============================	   forall A : Type, (A -> V) -> (A -> V) -> V		subgoal 2 (ID 477) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g -> ?y A f H_f = ?y B g H_g	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 open,)		";
            responses[i]=data;
          

            i = 706;
            data = "2 subgoals, subgoal 1 (ID 481)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   V		subgoal 2 (ID 477) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?v@{A:=A0; f:=f0}) A f H_f =	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?v@{A:=A0; f:=f0}) B g H_g	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 open,)		";
            responses[i]=data;
          

            i = 707;
            data = "1 subgoals, subgoal 1 (ID 477)	  	  ua : Univalence	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> V) (H_g : B -> V),	   equal_img H_f H_g ->	   (fun (A0 : Type) (f0 _ : A0 -> V) =>	    set	      (fun x : A0 + Unit =>	       match x with	       | inl a => f0 a	       | inr tt => set f0	       end)) A f H_f =	   (fun (A0 : Type) (f0 _ : A0 -> V) =>	    set	      (fun x : A0 + Unit =>	       match x with	       | inl a => f0 a	       | inr tt => set f0	       end)) B g H_g		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 708;
            data = "1 subgoals, subgoal 1 (ID 495)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set	     (fun x : A + Unit => match x with	                          | inl a => f a	                          | inr tt => set f	                          end) =	   set	     (fun x : B + Unit => match x with	                          | inl a => g a	                          | inr tt => set g	                          end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 709;
            data = "1 subgoals, subgoal 1 (ID 498)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   equal_img	     (fun x : A + Unit => match x with	                          | inl a => f a	                          | inr tt => set f	                          end)	     (fun x : B + Unit => match x with	                          | inl a => g a	                          | inr tt => set g	                          end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 710;
            data = "2 subgoals, subgoal 1 (ID 500)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall a : A + Unit,	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		subgoal 2 (ID 501) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 711;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 500)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall a : A + Unit,	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 502)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A + Unit	  ============================	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 712;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 508)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		subgoal 2 (ID 509) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 713;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 508)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 512)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists (paths (f a) o g) ->	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 714;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 515)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   {b : B & f a = g b} ->	   {b : B + Unit & f a = match b with	                         | inl a0 => g a0	                         | inr tt => set g	                         end}		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 715;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 520)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  b : B	  p : f a = g b	  ============================	   {b0 : B + Unit &	   f a = match b0 with	         | inl a0 => g a0	         | inr tt => set g	         end}		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 716;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 509)		subgoal 1 (ID 509) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	subgoal 2 (ID 501) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 717;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 509)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   hexists	     (fun b : B + Unit =>	      match u with	      | tt => set f	      end = match b with	            | inl a => g a	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 531)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   match u with	   | tt => set f	   end = set g		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 718;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 534)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 719;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 501)		subgoal 1 (ID 501) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 720;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 501)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall b : B + Unit,	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 538)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B + Unit	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 721;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 544)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		subgoal 2 (ID 545) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 722;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 544)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 548)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists (fun a : A => f a = g b) ->	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 723;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 551)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   {a : A & f a = g b} ->	   {a : A + Unit & match a with	                   | inl a0 => f a0	                   | inr tt => set f	                   end = g b}		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 724;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 556)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  a : A	  p : f a = g b	  ============================	   {a0 : A + Unit &	   match a0 with	   | inl a1 => f a1	   | inr tt => set f	   end = g b}		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 725;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 545)		subgoal 1 (ID 545) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 726;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 545)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match u with	            | tt => set g	            end)		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 567)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   set f = match u with	           | tt => set g	           end		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 727;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 570)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 728;
            data = "No more subgoals.	(dependent evars: ?X472 using ?X474 , ?X474 using ?X475 , ?X475 using ?X478 , ?X478 using ?X479 , ?X479 using ?X480 , ?X480 using ?X481 , ?X481 using ,)		";
            responses[i]=data;
          

            i = 729;
            data = "<infomsg>	V_succ is defined</infomsg>		";
            responses[i]=data;
          

            i = 730;
            data = "";
            responses[i]=data;
          

            i = 731;
            data = "";
            responses[i]=data;
          

            i = 732;
            data = "";
            responses[i]=data;
          

            i = 733;
            data = "";
            responses[i]=data;
          

            i = 734;
            data = "<infomsg>	V_omega is defined</infomsg>		";
            responses[i]=data;
          

            i = 735;
            data = "";
            responses[i]=data;
          

            i = 736;
            data = "";
            responses[i]=data;
          

            i = 737;
            data = "";
            responses[i]=data;
          

            i = 738;
            data = "";
            responses[i]=data;
          

            i = 739;
            data = "";
            responses[i]=data;
          

            i = 740;
            data = "";
            responses[i]=data;
          

            i = 741;
            data = "";
            responses[i]=data;
          

            i = 742;
            data = "1 subgoals, subgoal 1 (ID 474)	  	  ua : Univalence	  ============================	   forall x : V, ~ x ∈ V_empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 743;
            data = "1 subgoals, subgoal 1 (ID 474)	  	  ua : Univalence	  ============================	   forall x : V, ~ x ∈ V_empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 744;
            data = "1 subgoals, subgoal 1 (ID 477)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 745;
            data = "1 subgoals, subgoal 1 (ID 483)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	   {a : Empty & Empty_ind (fun _ : Empty => V) a = x} -> Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 746;
            data = "1 subgoals, subgoal 1 (ID 489)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ff : Empty	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 747;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 748;
            data = "<infomsg>	not_mem_Vempty is defined</infomsg>		";
            responses[i]=data;
          

            i = 749;
            data = "1 subgoals, subgoal 1 (ID 481)	  	  ua : Univalence	  ============================	   forall u v : V,	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 750;
            data = "1 subgoals, subgoal 1 (ID 481)	  	  ua : Univalence	  ============================	   forall u v : V,	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 751;
            data = "1 subgoals, subgoal 1 (ID 483)	  	  ua : Univalence	  u, v : V	  ============================	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 752;
            data = "1 subgoals, subgoal 1 (ID 486)	  	  ua : Univalence	  u, v : V	  ============================	   {w : V & forall x : V, x ∈ w <-> hor (x = u) (x = v)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 753;
            data = "1 subgoals, subgoal 1 (ID 488)	  	  ua : Univalence	  u, v : V	  ============================	   forall x : V, x ∈ V_pair u v <-> hor (x = u) (x = v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 754;
            data = "2 subgoals, subgoal 1 (ID 495)	  	  ua : Univalence	  u, v, x : V	  ============================	   {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		subgoal 2 (ID 498) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars:)		";
            responses[i]=data;
          

            i = 755;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 495)	  	  ua : Univalence	  u, v, x : V	  ============================	   {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		(dependent evars:)		<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 498)		subgoal 1 (ID 498) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars:)		";
            responses[i]=data;
          

            i = 756;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 498)	  	  ua : Univalence	  u, v, x : V	  ============================	   (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}		(dependent evars:)		No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 757;
            data = "<infomsg>	pairing is defined</infomsg>		";
            responses[i]=data;
          

            i = 758;
            data = "1 subgoals, subgoal 1 (ID 483)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars:)		";
            responses[i]=data;
          

            i = 759;
            data = "1 subgoals, subgoal 1 (ID 483)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars:)		";
            responses[i]=data;
          

            i = 760;
            data = "2 subgoals, subgoal 1 (ID 485)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega		subgoal 2 (ID 486) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	(dependent evars:)		";
            responses[i]=data;
          

            i = 761;
            data = "1 subgoals, subgoal 1 (ID 486)	  	  ua : Univalence	  ============================	   forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars:)		";
            responses[i]=data;
          

            i = 762;
            data = "1 subgoals, subgoal 1 (ID 492)	  	  ua : Univalence	  x : V	  ============================	   x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars:)		";
            responses[i]=data;
          

            i = 763;
            data = "1 subgoals, subgoal 1 (ID 495)	  	  ua : Univalence	  x : V	  ============================	   {a : nat &	   (fix I (n : nat) : V :=	      match n with	      | 0 => V_empty	      | n0.+1 => V_succ (I n0)	      end) a = x} ->	   {a : nat &	   (fix I (n : nat) : V :=	      match n with	      | 0 => V_empty	      | n0.+1 => V_succ (I n0)	      end) a = V_succ x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 764;
            data = "1 subgoals, subgoal 1 (ID 500)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	   {a : nat &	   (fix I (n0 : nat) : V :=	      match n0 with	      | 0 => V_empty	      | n1.+1 => V_succ (I n1)	      end) a = V_succ x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 765;
            data = "1 subgoals, subgoal 1 (ID 502)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	   V_succ	     ((fix I (n0 : nat) : V :=	         match n0 with	         | 0 => V_empty	         | n1.+1 => V_succ (I n1)	         end) n) = V_succ x		(dependent evars:)		";
            responses[i]=data;
          

            i = 766;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 767;
            data = "<infomsg>	infinity is defined</infomsg>		";
            responses[i]=data;
          

            i = 768;
            data = "1 subgoals, subgoal 1 (ID 488)	  	  ua : Univalence	  ============================	   forall v : V,	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 769;
            data = "1 subgoals, subgoal 1 (ID 488)	  	  ua : Univalence	  ============================	   forall v : V,	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 770;
            data = "1 subgoals, subgoal 1 (ID 489)	  	  ua : Univalence	  v : V	  ============================	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 771;
            data = "1 subgoals, subgoal 1 (ID 494)	  	  ua : Univalence	  v : V	  ============================	   forall x : V, x ∈ V_union v <-> hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 772;
            data = "2 subgoals, subgoal 1 (ID 497)	  	  ua : Univalence	  v, x : V	  ============================	   x ∈ V_union v -> hexists (fun u : V => x ∈ u * u ∈ v)		subgoal 2 (ID 498) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 773;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 497)	  	  ua : Univalence	  v, x : V	  ============================	   x ∈ V_union v -> hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 499)	  	  ua : Univalence	  v, x : V	  H : x ∈ V_union v	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 774;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 501)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 775;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 505)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  ============================	   {a : {x0 : [v] & [func_of_members x0]} & func_of_members a.2 = x} ->	   {u : V & x ∈ u * u ∈ v}		(dependent evars:)		";
            responses[i]=data;
          

            i = 776;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 515)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   {u : V & x ∈ u * u ∈ v}		(dependent evars:)		";
            responses[i]=data;
          

            i = 777;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 520)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ func_of_members u'		subgoal 2 (ID 521) is:	 func_of_members u' ∈ v	(dependent evars:)		";
            responses[i]=data;
          

            i = 778;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 520)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ func_of_members u'		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 537)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ set func_of_members		(dependent evars:)		";
            responses[i]=data;
          

            i = 779;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 539)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   Trunc (-1) {a : [func_of_members u'] & func_of_members a = x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 780;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 544)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members x' = x		(dependent evars:)		";
            responses[i]=data;
          

            i = 781;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 521)		subgoal 1 (ID 521) is:	 func_of_members u' ∈ v	subgoal 2 (ID 498) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 782;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 521)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members u' ∈ v		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 560)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members u' ∈ set func_of_members		(dependent evars:)		";
            responses[i]=data;
          

            i = 783;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 562)	  	  ua : Univalence	  v, x : V	  H : Trunc (-1)	        {a : {x : [v] & [func_of_members x]} & func_of_members a.2 = x}	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   Trunc (-1) {a : [v] & func_of_members a = func_of_members u'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 784;
            data = "<infomsg>	This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 498)		subgoal 1 (ID 498) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 785;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 498)	  	  ua : Univalence	  v, x : V	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 573)	  	  ua : Univalence	  v, x : V	  ============================	   {u : V & x ∈ u * u ∈ v} -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 786;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 582)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 787;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 586)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   u ∈ set func_of_members -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 788;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 591)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   {a : [v] & func_of_members a = u} -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 789;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 596)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 790;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 607)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   x ∈ set func_of_members -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 791;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 612)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   {a : [func_of_members u'] & func_of_members a = x} -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 792;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 617)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 793;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 620)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   {a : {x0 : [v] & [func_of_members x0]} & func_of_members a.2 = x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 794;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 624)	  	  ua : Univalence	  v, x, u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   func_of_members (u'; x').2 = x		(dependent evars:)		";
            responses[i]=data;
          

            i = 795;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 796;
            data = "<infomsg>	union is defined</infomsg>		";
            responses[i]=data;
          

            i = 797;
            data = "Toplevel input, characters 69-78:	> Lemma function : forall u v, hexists (fun w => forall x, x ∈ w <-> V_is_func u v x).	>                                                                    ^^^^^^^^^	Error: The reference V_is_func was not found in the current environment.	";
            responses[i]=data;
          

            i = 798;
            data = "	";
            responses[i]=data;
          

            i = 799;
            data = "Toplevel input, characters 3-14:	>   intros u v.	>   ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 800;
            data = "Toplevel input, characters 15-45:	> apply tr; exists (V_func u v).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 801;
            data = "Toplevel input, characters 3-85:	>   assert (memb_u : u = set (@func_of_members u)) by exact (is_valid_presentation u).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 802;
            data = "Toplevel input, characters 3-85:	>   assert (memb_v : v = set (@func_of_members v)) by exact (is_valid_presentation v).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 803;
            data = "Toplevel input, characters 3-20:	>   intro phi; split.	>   ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 804;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-12:	>   - intro H.	>     ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 805;
            data = "Toplevel input, characters 14-20:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 806;
            data = "Toplevel input, characters 8-14:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 807;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 808;
            data = "Toplevel input, characters 20-31:	> simpl in *.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 809;
            data = "Toplevel input, characters 0-13:	> generalize H.	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 810;
            data = "Toplevel input, characters 15-31:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 811;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 812;
            data = "Toplevel input, characters 0-52:	> generalize (transport (fun x => z ∈ x) p_phi^ Hz).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 813;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 814;
            data = "Toplevel input, characters 7-20:	>       intros [a p].	>       ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 815;
            data = "Toplevel input, characters 0-16:	> exists (a, h a).	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 816;
            data = "Toplevel input, characters 18-29:	> assumption.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 817;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros x Hx.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 818;
            data = "Toplevel input, characters 20-72:	> generalize (transport (fun y => x ∈ y) memb_u Hx).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 819;
            data = "Toplevel input, characters 7-23:	>       apply Trunc_rec.	>       ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 820;
            data = "Toplevel input, characters 24-37:	> intros [a p].	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 821;
            data = "Toplevel input, characters 0-39:	> generalize H; apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 822;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 823;
            data = "Toplevel input, characters 0-31:	> exists (func_of_members (h a)).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 824;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 825;
            data = "Toplevel input, characters 7-86:	>       exact (transport (fun z => func_of_members (h a) ∈ z) memb_v^ (tr (h a; 1))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 826;
            data = "Toplevel input, characters 7-75:	>       apply (transport (fun y => [x, func_of_members (h a)] ∈ y) p_phi).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 827;
            data = "Toplevel input, characters 7-26:	>       apply tr; exists a.	>       ^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 828;
            data = "Toplevel input, characters 27-50:	> rewrite p; reflexivity.	> ^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 829;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-30:	>     + intros x y y' (Hy, Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 830;
            data = "Toplevel input, characters 0-30:	> generalize H; apply Trunc_rec.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 831;
            data = "Toplevel input, characters 32-49:	> intros [h p_phi].	> ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 832;
            data = "Toplevel input, characters 7-64:	>       generalize (transport (fun z => [x, y] ∈ z) p_phi^ Hy).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 833;
            data = "Toplevel input, characters 0-16:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 834;
            data = "Toplevel input, characters 18-31:	> intros [a p].	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 835;
            data = "Toplevel input, characters 7-66:	>       generalize (transport (fun z => [x, y'] ∈ z) p_phi^ Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 836;
            data = "Toplevel input, characters 0-16:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 837;
            data = "Toplevel input, characters 18-33:	> intros [a' p'].	> ^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 838;
            data = "Toplevel input, characters 7-50:	>       destruct (fst path_pair_ord p) as (px, py).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 839;
            data = "Toplevel input, characters 0-46:	> destruct (fst path_pair_ord p') as (px', py').	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 840;
            data = "Toplevel input, characters 7-66:	>       transitivity (func_of_members (h a)); auto with path_hints.	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 841;
            data = "Toplevel input, characters 67-126:	> transitivity (func_of_members (h a'));auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 842;
            data = "Toplevel input, characters 7-37:	>       refine (ap func_of_members _).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 843;
            data = "Toplevel input, characters 0-16:	> refine (ap h _).	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 844;
            data = "Toplevel input, characters 7-90:	>       apply (isinj_embedding func_of_members IsEmbedding_funcofmembers a a' (px @ px'^)).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 845;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-26:	>   - intros ((H1, H2), H3).	>     ^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 846;
            data = "Toplevel input, characters 0-6:	> simpl.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 847;
            data = "Toplevel input, characters 5-93:	>     assert (h : forall a : [u], {b : [v] & [func_of_members a, func_of_members b] ∈ phi}).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 848;
            data = "Toplevel input, characters 5-6:	>     {	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-14:	>     { intro a.	>       ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 849;
            data = "Toplevel input, characters 16-46:	> pose (x := func_of_members a).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 850;
            data = "Toplevel input, characters 7-67:	>       transparent assert (H : {y : V & y ∈ v * [x, y] ∈ phi}).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 851;
            data = "Toplevel input, characters 7-164:	> ..... refine (@untrunc_istrunc -1 {y : V & y ∈ v * [x, y] ∈ phi} _	>                                  (H2 x (transport (fun z => x ∈ z) memb_u^ (tr (a; 1))))). 	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 852;
            data = "Toplevel input, characters 7-8:	>       {	>       ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 8-28:	>       { apply hprop_allpath.	>         ^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 853;
            data = "Toplevel input, characters 30-74:	> intros [y (H1_y, H2_y)] [y' (H1_y', H2_y')].	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 854;
            data = "Toplevel input, characters 9-43:	>         apply path_sigma_uncurried; simpl.	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 855;
            data = "Toplevel input, characters 9-42:	>         exists (H3 x y y' (H2_y, H2_y')).	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 856;
            data = "Toplevel input, characters 9-28:	>         apply path_ishprop.	>         ^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	Toplevel input, characters 28-29:	>         apply path_ishprop. }	>                             ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-37:	>       destruct H as [y (H1_y, H2_y)].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 857;
            data = "Toplevel input, characters 7-123:	>       destruct (@untrunc_istrunc -1 _ (IsEmbedding_funcofmembers y) (transport (fun z => y ∈ z) memb_v H1_y)) as [b Hb].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 858;
            data = "Toplevel input, characters 7-16:	>       exists b.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 859;
            data = "Toplevel input, characters 17-70:	> exact (transport (fun z => [x, z] ∈ phi) Hb^ H2_y).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 860;
            data = "Toplevel input, characters 1-2:	>  }	>  ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-42:	>     apply tr; exists (fun a => pr1 (h a)).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 861;
            data = "Toplevel input, characters 0-21:	> apply extensionality.	> ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 862;
            data = "Toplevel input, characters 23-29:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 863;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 864;
            data = "Toplevel input, characters 20-51:	> generalize Hz; apply Trunc_rec.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 865;
            data = "Toplevel input, characters 33-47:	> intros [a Ha].	> ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 866;
            data = "Toplevel input, characters 7-61:	>       exact (transport (fun w => w ∈ phi) Ha (pr2 (h a))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 867;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 868;
            data = "Toplevel input, characters 20-26:	> simpl.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 869;
            data = "Toplevel input, characters 7-28:	>       generalize (H1 z Hz).	>       ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 870;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 871;
            data = "Toplevel input, characters 0-17:	> intros [(a,b) p].	> ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 872;
            data = "Toplevel input, characters 0-11:	> simpl in p.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 873;
            data = "Toplevel input, characters 7-16:	>       exists a.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 874;
            data = "Toplevel input, characters 17-93:	> transitivity ([func_of_members a, func_of_members b]); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 875;
            data = "Toplevel input, characters 7-16:	>       apply ap.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 876;
            data = "Toplevel input, characters 7-41:	>       apply H3 with (func_of_members a).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 877;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 878;
            data = "Toplevel input, characters 7-25:	>       exact (pr2 (h a)).	>       ^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 879;
            data = "Toplevel input, characters 7-52:	>       exact (transport (fun w => w ∈ phi) p^ Hz).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 880;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 881;
            data = "Toplevel input, characters 84-85:	>   hexists (fun w => forall y, y ∈ w <-> hexists (fun z => z ∈ x * (r z = y))).	>                                  ^	Syntax Error: Lexer: Undefined token	";
            responses[i]=data;
          

            i = 882;
            data = "	";
            responses[i]=data;
          

            i = 883;
            data = "Toplevel input, characters 3-11:	>   intro r.	>   ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 884;
            data = "Toplevel input, characters 12-39:	> refine (V_ind_hprop _ _ _).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 885;
            data = "Toplevel input, characters 3-16:	>   intros A f _.	>   ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 886;
            data = "Toplevel input, characters 17-26:	> apply tr.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 887;
            data = "Toplevel input, characters 11-32:	> exists (set (r o f)).	> ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 888;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 889;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-29:	>   - apply (Trunc_functor -1).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 890;
            data = "Toplevel input, characters 5-18:	>     intros [a p].	>     ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 891;
            data = "Toplevel input, characters 0-13:	> exists (f a).	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 892;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 893;
            data = "Toplevel input, characters 8-33:	> apply tr; exists a; auto.	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 894;
            data = "Toplevel input, characters 27-38:	> assumption.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 895;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-20:	>   - apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 896;
            data = "Toplevel input, characters 5-22:	>     intros [z [h p]].	>     ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 897;
            data = "Toplevel input, characters 0-13:	> generalize h.	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 898;
            data = "Toplevel input, characters 15-40:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 899;
            data = "Toplevel input, characters 5-19:	>     intros [a p'].	>     ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 900;
            data = "Toplevel input, characters 0-9:	> exists a.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 901;
            data = "Toplevel input, characters 11-52:	> transitivity (r z); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 902;
            data = "Toplevel input, characters 43-59:	> exact (ap r p').	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 903;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 904;
            data = "Toplevel input, characters 85-86:	>   hexists (fun w => forall x, x ∈ w <-> x ∈ a * (C x)).	>                                  ^	Syntax Error: Lexer: Undefined token	";
            responses[i]=data;
          

            i = 905;
            data = "	";
            responses[i]=data;
          

            i = 906;
            data = "Toplevel input, characters 3-30:	>   refine (V_ind_hprop _ _ _).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 907;
            data = "Toplevel input, characters 3-16:	>   intros A f _.	>   ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 908;
            data = "Toplevel input, characters 17-26:	> apply tr.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 909;
            data = "Toplevel input, characters 11-65:	> exists (set (fun z : {a : A & C (f a)} => f (pr1 z))).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 910;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 911;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-20:	>   - apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 912;
            data = "Toplevel input, characters 5-22:	>     intros [[a h] p].	>     ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 913;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 914;
            data = "Toplevel input, characters 8-39:	> apply tr; exists a; assumption.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 915;
            data = "Toplevel input, characters 33-57:	> exact (transport C p h).	> ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 916;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-19:	>   - intros [H1 H2].	>     ^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 917;
            data = "Toplevel input, characters 0-14:	> generalize H1.	> ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 918;
            data = "Toplevel input, characters 16-41:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 919;
            data = "Toplevel input, characters 5-18:	>     intros [a p].	>     ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 920;
            data = "Toplevel input, characters 9-10:	> exists (a; transport C p^ H2).	>          ^	Syntax error: ',' or ')' expected after [constr:operconstr level 200] (in [constr:operconstr]).	";
            responses[i]=data;
          

            i = 921;
            data = "Toplevel input, characters 32-40:	> exact p.	> ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 922;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 923;
            data = "Toplevel input, characters 0-15:	> End AssumingUA.	> ^^^^^^^^^^^^^^^	Error: There is nothing to end.	";
            responses[i]=data;
          

            i = 924;
            data = "";
            responses[i]=data;
          

            i = 925;
            data = "";
            responses[i]=data;
          

            i = 926;
            data = "";
            responses[i]=data;
          

            i = 927;
            data = "";
            responses[i]=data;
          

            i = 928;
            data = "";
            responses[i]=data;
          

            i = 929;
            data = "";
            responses[i]=data;
          

            i = 930;
            data = "";
            responses[i]=data;
          

            i = 931;
            data = "";
            responses[i]=data;
          

            i = 932;
            data = "";
            responses[i]=data;
          

            i = 933;
            data = "";
            responses[i]=data;
          

            i = 934;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.hit.V</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<br>
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab282"></a><h1 class="section">The cumulative hierarchy <span class="inlinecode"><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a></span>.</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.Unit.html#"><span class="id" title="library">Types.Unit</span></a> <a class="idref" href="HoTT.Types.Bool.html#"><span class="id" title="library">Types.Bool</span></a> <a class="idref" href="HoTT.Types.Universe.html#"><span class="id" title="library">Types.Universe</span></a> <a class="idref" href="HoTT.Types.Sigma.html#"><span class="id" title="library">Types.Sigma</span></a> <a class="idref" href="HoTT.Types.Arrow.html#"><span class="id" title="library">Types.Arrow</span></a> <a class="idref" href="HoTT.Types.Forall.html#"><span class="id" title="library">Types.Forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" title="library">HSet</span></a> <a class="idref" href="HoTT.UnivalenceImpliesFunext.html#"><span class="id" title="library">UnivalenceImpliesFunext</span></a> <a class="idref" href="HoTT.TruncType.html#"><span class="id" title="library">TruncType</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.hit.Truncations.html#"><span class="id" title="library">hit.Truncations</span></a> <a class="idref" href="HoTT.hit.quotient.html#"><span class="id" title="library">hit.quotient</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">equiv_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
<a name="lab283"></a><h2 class="section">Pushout with respect to a relation</h2>
<div class="doc" scenenumber="4"> </div>

 This could be implemented using the pushouts in /hit/Pushout.v, where <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.f"><span class="id" title="variable">f</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.g"><span class="id" title="variable">g</span></a></span> are <span class="inlinecode">(<a class="idref" href="HoTT.categories.Functor.Prod.Core.html#fst"><span class="id" title="definition">fst</span></a></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.ToCat.html#pr1"><span class="id" title="definition">pr1</span></a>)</span> and <span class="inlinecode">(<a class="idref" href="HoTT.categories.Functor.Prod.Core.html#snd"><span class="id" title="definition">snd</span></a></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.ToCat.html#pr1"><span class="id" title="definition">pr1</span></a>)</span>, with domain {(a,b) : A * B &amp; R a b}. However, these pushouts weren't implemented when I started this work, and doing it this way is closer to exercise 10.11 of the HoTT book 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="RPushout"><span class="id" title="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a name="RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <span class="id" title="keyword">Type</span> :=<br>
| <a name="RPushout.inL"><span class="id" title="constructor">inL</span></a> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <span class="id" title="var">R</span><br>
| <a name="RPushout.inR"><span class="id" title="constructor">inR</span></a> : <span class="id" title="var">B</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <span class="id" title="var">R</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="RPushout.glue"><span class="id" title="axiom">glue</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout.RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>}<br>
  (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">i</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">j</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
: <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><br>
:= <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">a</span> ⇒ (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="var">a</span>)<br>
                        | <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">b</span> ⇒ (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <span class="id" title="var">b</span>) <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="RPushout.RPushout_comp_glue"><span class="id" title="axiom">RPushout_comp_glue</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>}<br>
  (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">i</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">j</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>),<br>
<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#RPushout"><span class="id" title="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The non-depentent eliminator 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(54, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">i</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">j</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>) <a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(55, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout_comp_nd_glue"><span class="id" title="definition">RPushout_comp_nd_glue</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">i</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">j</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(56, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(57, '0_3_15');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>) (<span class="id" title="var">i</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(58, '0_3_15');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">gl</span>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" title="lemma">apD_const</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">gl</span>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>)<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(60, '0_3_15');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_comp_glue"><span class="id" title="axiom">RPushout_comp_glue</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">P</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(61, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(62, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Bitotal relation 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(66, '0_3_19');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="bitotal"><span class="id" title="definition">bitotal</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(67, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
<a name="lab284"></a><h2 class="section">The cumulative hierarchy V</h2>
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(74, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(75, '0_3_23');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a name="CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U´</span>} :=<br>
| <a name="CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> {<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U</span>}} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(76, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>),<br>
<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(77, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.is0trunc_V"><span class="id" title="axiom">is0trunc_V</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(78, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Fixpoint</span> <a name="CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a><br>
:= (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br>
     | <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.hit.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>))<br>
    <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(79, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncation 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      ">
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_setext"><span class="id" title="definition">V_comp_setext</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The non-dependent eliminator 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(92, '0_3_31');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec"><span class="id" title="definition">V_rec</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>),<br>
    <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(93, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(94, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(95, '0_3_31');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(96, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">H_setext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(97, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(98, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_nd_setext"><span class="id" title="definition">V_comp_nd_setext</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>),<br>
    <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.hit.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(99, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(100, '0_3_31');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(101, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(102, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
<a name="lab285"></a><h2 class="section">Alternative induction principle (This is close to the one from the book)</h2>
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="equal_img"><span class="id" title="definition">equal_img</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="setext%C2%B4"><span class="id" title="definition">setext´</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">R</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">g</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.hit.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <span class="id" title="var">R</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec%C2%B4"><span class="id" title="definition">V_rec´</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext´</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>), <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br>
    <span class="id" title="keyword">∀</span> (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">H_g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>), <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> )<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(117, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(118, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(119, '0_3_35');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(120, '0_3_35');
      "><br>
  <span class="id" title="tactic">apply</span> <span class="id" title="var">H_setext´</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(121, '0_3_35');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(122, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(123, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(124, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(125, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(126, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(127, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(128, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(129, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(130, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(131, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(132, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(133, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(134, '0_3_35');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(135, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(136, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(137, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(138, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(139, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(140, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(141, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(142, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(143, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(144, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(145, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(146, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(147, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(148, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(152, '0_3_39');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_ind%C2%B4"><span class="id" title="definition">V_ind´</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext´</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
    (<span class="id" title="var">eq_img</span>: <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a>)<br>
    (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">H_g</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<br>
    (<span class="id" title="var">H_eqimg</span> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
             <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> ),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img"><span class="id" title="variable">eq_img</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a><br>
  )<br>
: <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(153, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(154, '0_3_39');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">H_set</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(155, '0_3_39');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(156, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">f</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(157, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">B</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(158, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_f</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(159, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_g</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">g</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(160, '0_3_39');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(161, '0_3_39');
      "><br>
  { <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(162, '0_3_39');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(163, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(164, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(165, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(166, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(167, '0_3_39');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(168, '0_3_39');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(169, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(170, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(171, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(172, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(173, '0_3_39');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(174, '0_3_39');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span>) <span class="id" title="var">eq_img</span>)<br>
      (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(175, '0_3_39');
      "><br>
  { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> <a class="idref" href="HoTT.hit.V.html#p"><span class="id" title="variable">p</span></a> (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(176, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
  <span class="id" title="tactic">apply</span> (<span class="id" title="var">H_setext´</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(177, '0_3_39');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(178, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(179, '0_3_39');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">truncb</span> := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">truncb</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">trunca</span> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">trunca</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Simpler induction principle when the goal is an hprop 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(207, '0_3_43');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">isHProp_P</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(208, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(209, '0_3_43');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(210, '0_3_43');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(211, '0_3_43');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(212, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(213, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(214, '0_3_43');
      "><br>
<span class="id" title="keyword">Context</span> `{<span class="id" title="var">ua</span> : <a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(215, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
<a name="lab286"></a><h2 class="section">Membership relation</h2>
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(222, '0_3_47');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="mem"><span class="id" title="definition">mem</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(223, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(224, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rec%C2%B4"><span class="id" title="definition">V_rec´</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(225, '0_3_47');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(226, '0_3_47');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(227, '0_3_47');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(228, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eqimg</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(229, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(230, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(231, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(232, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(233, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(234, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(235, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p´</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p´</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">"</span></a>x ∈ v" := (<a class="idref" href="HoTT.hit.V.html#mem"><span class="id" title="definition">mem</span></a> <span class="id" title="var">x</span> <span class="id" title="var">v</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 30) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
<a name="lab287"></a><h2 class="section">Subset relation</h2>
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(256, '0_3_51');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="subset"><span class="id" title="definition">subset</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">y</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a><br>
:= <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="keyword">∀</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(257, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">"</span></a>x ⊆ y" := (<a class="idref" href="HoTT.hit.V.html#subset"><span class="id" title="definition">subset</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 30) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(258, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
<a name="lab288"></a><h2 class="section">Bisimulation relation</h2>
 The equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in hProp_U : Type{U'}, hence the codomain is hProp@{U'}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(265, '0_3_55');
      ">
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a name="bisim_aux"><span class="id" title="definition">bisim_aux</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(266, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(267, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#V_rec%C2%B4"><span class="id" title="definition">V_rec´</span></a> <span class="id" title="keyword">with</span><br>
    (<span class="id" title="keyword">fun</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> ( <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
                               <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a>)) )<br>
    ).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(268, '0_3_55');
      "><br>
  <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(269, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">B´</span> <span class="id" title="var">g</span> <span class="id" title="var">g´</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_g´</span> <span class="id" title="var">H_img</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(270, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(271, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(272, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(273, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(274, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(275, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(276, '0_3_55');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(277, '0_3_55');
      "><span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">B´</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">g´</span> <span class="id" title="var">b0</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">B´</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g´</span> <span class="id" title="var">b0</span>)<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(278, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b´</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(279, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b´</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(280, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(281, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b´</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(282, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(283, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(284, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(285, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(286, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(287, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(288, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(289, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(290, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(291, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(292, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b´</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(293, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b´</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(294, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(295, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(296, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(297, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(298, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(299, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(300, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b´</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(301, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b´</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(302, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(303, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(304, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(305, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(306, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(307, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="bisimulation"><span class="id" title="definition">bisimulation</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U´</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U´</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U´</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(308, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(309, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rec%C2%B4"><span class="id" title="definition">V_rec´</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.hit.V.html#bisim_aux"><span class="id" title="definition">bisim_aux</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(310, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_img</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(311, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(312, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(313, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(314, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(315, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(316, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(317, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(318, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(319, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(320, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(321, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(322, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(323, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(324, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(325, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(326, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(327, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(328, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(329, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(330, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(331, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(332, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(333, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(334, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(335, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(336, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(337, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(338, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(339, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(340, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(341, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(342, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(343, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(344, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(345, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(346, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(347, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(348, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(349, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(350, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">"</span></a>u ~~ v" := (<a class="idref" href="HoTT.hit.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 30) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(351, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Reflexive"><span class="id" title="class">Reflexive</span></a> <a class="idref" href="HoTT.hit.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(352, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(353, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(354, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>; <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(355, '0_3_55');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(356, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(357, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(358, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(359, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(360, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(361, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(362, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#equiv_iff_hprop"><span class="id" title="definition">equiv_iff_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(363, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.hit.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> (<a class="idref" href="HoTT.hit.V.html#reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> <span class="id" title="var">u</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(364, '0_3_55');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(365, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(366, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(367, '0_3_55');
      "><br>
  <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(368, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(369, '0_3_55');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(370, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(371, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(372, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(373, '0_3_55');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(374, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(375, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(376, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(377, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(378, '0_3_55');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(379, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(380, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(381, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
<a name="lab289"></a><h2 class="section">Canonical presentation of V-sets (Lemma 10.5.6)</h2>
<div class="doc" scenenumber="4"> </div>

 Using the regular kernel (with = instead of ~~) also works, but this seems to be a Coq bug, it should lead to a universe inconsistency in the monic_set_present lemma later. This version is the right way to do it. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(390, '0_3_59');
      ">
<span class="id" title="keyword">Definition</span> <a name="ker_bisim"><span class="id" title="definition">ker_bisim</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>) := (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(391, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
  : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.hit.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(392, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(393, '0_3_59');
      "><br>
  <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(394, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(395, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(396, '0_3_59');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(400, '0_3_63');
      ">
<br>
<span class="id" title="keyword">Context</span> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">Au</span> <span class="id" title="var">Au´</span>: <span class="id" title="keyword">Type</span>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" title="variable">Au</span></a>} {<span class="id" title="var">h´</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au%C2%B4"><span class="id" title="variable">Au´</span></a>} {<span class="id" title="var">mu</span> : <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#mu"><span class="id" title="variable">mu</span></a>}<br>
  {<span class="id" title="var">mu´</span> : <a class="idref" href="HoTT.hit.V.html#Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono´</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#mu%C2%B4"><span class="id" title="variable">mu´</span></a>} {<span class="id" title="var">p</span> : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#mu"><span class="id" title="variable">mu</span></a>} {<span class="id" title="var">p´</span> : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#mu%C2%B4"><span class="id" title="variable">mu´</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(401, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a>, <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a´</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> <span class="id" title="var">a´</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
                     <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a´</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a>, <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> <a class="idref" href="HoTT.hit.V.html#a%C2%B4"><span class="id" title="variable">a´</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(402, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(403, '0_3_63');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(404, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(405, '0_3_63');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono%C2%B4"><span class="id" title="variable">mono´</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p%C2%B4"><span class="id" title="variable">p´</span></a>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(406, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a´</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(407, '0_3_63');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> <span class="id" title="var">a´</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> <span class="id" title="var">a´</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p%C2%B4"><span class="id" title="variable">p´</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a´</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(408, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(409, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(410, '0_3_63');
      "><br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a´</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.hit.V.html#a%C2%B4"><span class="id" title="variable">a´</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(411, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(412, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(413, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a´</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(414, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono%C2%B4"><span class="id" title="variable">mono´</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(415, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(416, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a´</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(417, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(418, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(419, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(420, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(421, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(422, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(423, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(424, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(425, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(426, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(427, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(428, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(429, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(430, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(431, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(432, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mu_eq_mu%C2%B4"><span class="id" title="lemma">mu_eq_mu´</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(433, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(434, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(435, '0_3_63');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">a´</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(436, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#X"><span class="id" title="variable">X</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a´</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(437, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Arrow.html#transport_arrow"><span class="id" title="definition">transport_arrow</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#X"><span class="id" title="variable">X</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(438, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(439, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(440, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(441, '0_3_63');
      "><br>
  2: <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(442, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(443, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> <span class="id" title="var">a´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(444, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">a´</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(445, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#transport_path_universe"><span class="id" title="definition">transport_path_universe</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(446, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(447, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu%C2%B4"><span class="id" title="variable">mu´</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h%C2%B4"><span class="id" title="variable">h´</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono%C2%B4"><span class="id" title="variable">mono´</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p%C2%B4"><span class="id" title="variable">p´</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">m</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <span class="id" title="var">m</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">m</span><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(448, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(449, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(450, '0_3_63');
      "><br>
  <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(451, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transportD"><span class="id" title="definition">transportD</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(452, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au%C2%B4"><span class="id" title="variable">Au´</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(453, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(454, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.hit.V.html#mu_eq_mu%C2%B4"><span class="id" title="lemma">mu_eq_mu´</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(455, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(456, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(457, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
This lemma actually says a little more than 10.5.6, i.e., that Au is a hSet 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(461, '0_3_67');
      ">
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>, <a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">∃</span></a> <a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">(</span></a><span class="id" title="var">Au</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">m</span> : <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" title="variable">Au</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(462, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(463, '0_3_67');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(464, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(465, '0_3_67');
      "><br>
    <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.hit.quotient.html#quotient_kernel_factor"><span class="id" title="lemma">quotient_kernel_factor</span></a> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.hit.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.hit.V.html#ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> <span class="id" title="var">f</span>))<br>
      <span class="id" title="keyword">as</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">eu</span> [<span class="id" title="var">mu</span> (((<span class="id" title="var">hset_Au</span>, <span class="id" title="var">epi_eu</span>), <span class="id" title="var">mono_mu</span>), <span class="id" title="var">factor</span>)]]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(466, '0_3_67');
      "><br>
    <span class="id" title="tactic">∃</span> <span class="id" title="var">Au</span>, <span class="id" title="var">mu</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(467, '0_3_67');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(468, '0_3_67');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">hset_Au</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">mono_mu</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(469, '0_3_67');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(470, '0_3_67');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(471, '0_3_67');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(472, '0_3_67');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(473, '0_3_67');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a´</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(474, '0_3_67');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">epi_eu</span> <span class="id" title="var">a´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(475, '0_3_67');
      "><br>
      <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" title="projection">center</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(476, '0_3_67');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(477, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(478, '0_3_67');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">mu</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(479, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(480, '0_3_67');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">mu</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(481, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(482, '0_3_67');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(483, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">mu</span> ((<span class="id" title="var">hset</span>, <span class="id" title="var">mono</span>), <span class="id" title="var">p</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(484, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au´</span> [<span class="id" title="var">mu´</span> ((<span class="id" title="var">hset´</span>, <span class="id" title="var">mono´</span>), <span class="id" title="var">p´</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(485, '0_3_67');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(486, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(487, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="type_of_members"><span class="id" title="definition">type_of_members</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(488, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">"</span></a>[ u ]" := (<a class="idref" href="HoTT.hit.V.html#type_of_members"><span class="id" title="definition">type_of_members</span></a> <span class="id" title="var">u</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 20) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(489, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="func_of_members"><span class="id" title="definition">func_of_members</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>)) : <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(490, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_hset_typeofmembers"><span class="id" title="definition">is_hset_typeofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> (<a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a>) := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(491, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(492, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(493, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a name="lab290"></a><h2 class="section">Lemmas 10.5.8 (i) &amp; (vii), we put them here because they are useful later</h2>
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(500, '0_3_71');
      ">
<span class="id" title="keyword">Lemma</span> <a name="extensionality"><span class="id" title="lemma">extensionality</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>}, <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(501, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(502, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(503, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(504, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(505, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(506, '0_3_71');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(507, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(508, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(509, '0_3_71');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(510, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(511, '0_3_71');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a>1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(512, '0_3_71');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(513, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(514, '0_3_71');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(515, '0_3_71');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(516, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(517, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<span class="id" title="var">H2</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(518, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(519, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(520, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(521, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(522, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(523, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(524, '0_3_71');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(525, '0_3_71');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
: <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(526, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(527, '0_3_71');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(528, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(529, '0_3_71');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(530, '0_3_71');
      "><span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(531, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(532, '0_3_71');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(533, '0_3_71');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(534, '0_3_71');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(535, '0_3_71');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(536, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
<a name="lab291"></a><h2 class="section">Two useful lemmas</h2>
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(543, '0_3_75');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a name="irreflexive_mem"><span class="id" title="instance">irreflexive_mem</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Irreflexive"><span class="id" title="class">Irreflexive</span></a> <a class="idref" href="HoTT.hit.V.html#mem"><span class="id" title="definition">mem</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(544, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(545, '0_3_75');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">x0</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> ⇒ <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x0"><span class="id" title="variable">x0</span></a>) <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>)).   { </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(546, '0_3_75');
      "><span class="id" title="tactic">intro</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(547, '0_3_75');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(548, '0_3_75');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(549, '0_3_75');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(550, '0_3_75');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">Hv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(551, '0_3_75');
      "><br>
  <span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">v</span> <span class="id" title="var">Hv</span> <span class="id" title="var">Hv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(552, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(553, '0_3_75');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(554, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(555, '0_3_75');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(556, '0_3_75');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(557, '0_3_75');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(558, '0_3_75');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(559, '0_3_75');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(560, '0_3_75');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(561, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p´</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(562, '0_3_75');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(563, '0_3_75');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(564, '0_3_75');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(565, '0_3_75');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(566, '0_3_75');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(567, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p´</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(568, '0_3_75');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p´</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(569, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(570, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
<a name="lab292"></a><h2 class="section">Definitions of particular sets in V</h2>
<div class="doc" scenenumber="4"> </div>

 The empty set 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(579, '0_3_79');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_empty"><span class="id" title="definition">V_empty</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(580, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The singleton {u} 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(584, '0_3_83');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_singleton"><span class="id" title="definition">V_singleton</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U´</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Unit_ind"><span class="id" title="definition">Unit_ind</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(585, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="isequiv_ap_V_singleton"><span class="id" title="instance">isequiv_ap_V_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (@<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(586, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(587, '0_3_83');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#BuildIsEquiv"><span class="id" title="constructor">BuildIsEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> ].</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(588, '0_3_83');
      "><br>
  { <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(589, '0_3_83');
      "><span class="id" title="tactic">specialize</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(590, '0_3_83');
      "><span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(591, '0_3_83');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(592, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(593, '0_3_83');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(594, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The pair {u,v} 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(598, '0_3_87');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair"><span class="id" title="definition">V_pair</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U´</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(599, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair"><span class="id" title="lemma">path_pair</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">u´</span> <span class="id" title="var">v´</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U´</span> <span class="id" title="var">U</span>}} : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#u%C2%B4"><span class="id" title="variable">u´</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v%C2%B4"><span class="id" title="variable">v´</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u%C2%B4"><span class="id" title="variable">u´</span></a> <a class="idref" href="HoTT.hit.V.html#v%C2%B4"><span class="id" title="variable">v´</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(600, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(601, '0_3_87');
      "><br>
  <span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(602, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(603, '0_3_87');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(604, '0_3_87');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(605, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(606, '0_3_87');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(607, '0_3_87');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(608, '0_3_87');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(609, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(610, '0_3_87');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(611, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(612, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(613, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(614, '0_3_87');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(615, '0_3_87');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(616, '0_3_87');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(617, '0_3_87');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(618, '0_3_87');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(619, '0_3_87');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(620, '0_3_87');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p´</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(621, '0_3_87');
      "><br>
    <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>| <span class="id" title="tactic">exact</span> <span class="id" title="var">p´</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(622, '0_3_87');
      "><br>
  + <span class="id" title="tactic">intros</span> (<span class="id" title="var">p1</span>, <span class="id" title="var">p2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(623, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(624, '0_3_87');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(625, '0_3_87');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">p2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(626, '0_3_87');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(627, '0_3_87');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(628, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(629, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The ordered pair (u,v) 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(633, '0_3_91');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> (<a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(634, '0_3_91');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="10570db8ff454b79fa435e153566df40"><span class="id" title="notation">"</span></a> [ u , v ] " := (<a class="idref" href="HoTT.hit.V.html#V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 20) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(635, '0_3_91');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> {<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(636, '0_3_91');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(637, '0_3_91');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(638, '0_3_91');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(639, '0_3_91');
      "><span class="id" title="tactic">assert</span> (<span class="id" title="var">p1</span> : <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(640, '0_3_91');
      "><br>
    + <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(641, '0_3_91');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(642, '0_3_91');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(643, '0_3_91');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(644, '0_3_91');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p´</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(645, '0_3_91');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#88ede747212f43ca2516cbd6e5847b58"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a><a class="idref" href="HoTT.Basics.Overture.html#88ede747212f43ca2516cbd6e5847b58"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">p´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(646, '0_3_91');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(647, '0_3_91');
      "><br>
    + <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(648, '0_3_91');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(649, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.hit.Truncations.html#hor"><span class="id" title="definition">hor</span></a> (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">d</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(650, '0_3_91');
      "><br>
      { <span class="id" title="tactic">assert</span> (<span class="id" title="var">H´</span> : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(651, '0_3_91');
      "><br>
        { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(652, '0_3_91');
      "><br>
          <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H´</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(653, '0_3_91');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p´</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(654, '0_3_91');
      "><br>
        × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">left</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(655, '0_3_91');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(656, '0_3_91');
      "><br>
        × <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">p´</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(657, '0_3_91');
      "><br>
          <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>); <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(658, '0_3_91');
      "><br>
          <span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p´´</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(659, '0_3_91');
      "><br>
          <span class="id" title="tactic">left</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p´´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(660, '0_3_91');
      "><span class="id" title="tactic">right</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p´´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(661, '0_3_91');
      "><span class="id" title="tactic">intro</span> <span class="id" title="tactic">case</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="tactic">case</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">p´</span>| <span class="id" title="var">p´</span>].</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(662, '0_3_91');
      "><br>
      2: <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(663, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H´</span> : <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> (<a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(664, '0_3_91');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(665, '0_3_91');
      "><br>
        <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(666, '0_3_91');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">p´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(667, '0_3_91');
      "><br>
        <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(668, '0_3_91');
      "><br>
        <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">p´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>) | <span class="id" title="tactic">reflexivity</span>]. }</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(669, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H´´</span> : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">c</span> <span class="id" title="var">d</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)<br>
        <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> (<span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">H´</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(670, '0_3_91');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">H´´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(671, '0_3_91');
      "><br>
- <span class="id" title="tactic">intros</span> (<span class="id" title="var">p</span>, <span class="id" title="var">p´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(672, '0_3_91');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(673, '0_3_91');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(674, '0_3_91');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(675, '0_3_91');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(676, '0_3_91');
      "><span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(677, '0_3_91');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(678, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The cartesian product a × b 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(682, '0_3_95');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(683, '0_3_95');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="cff9f46c83d2a5a363b7aa39336cc6c0"><span class="id" title="notation">"</span></a> a × b " := (<a class="idref" href="HoTT.hit.V.html#V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)<br>
  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 25) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(684, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
f is a function with domain a and codomain b 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(688, '0_3_99');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_is_func"><span class="id" title="definition">V_is_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) := <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#cff9f46c83d2a5a363b7aa39336cc6c0"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y´</span>, <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y%C2%B4"><span class="id" title="variable">y´</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y%C2%B4"><span class="id" title="variable">y´</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(689, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The set of functions from a to b 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(693, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_func"><span class="id" title="definition">V_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><br>
:= @<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> )).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(694, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The union of a set Uv 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(698, '0_3_107');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_union"><span class="id" title="definition">V_union</span></a> (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) :=<br>
  @<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(699, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
The ordinal successor x ∪ {x} 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(703, '0_3_111');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_succ"><span class="id" title="definition">V_succ</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(704, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(705, '0_3_111');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rec%C2%B4"><span class="id" title="definition">V_rec´</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(706, '0_3_111');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(707, '0_3_111');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">a</span><br>
                                          | <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span> <span class="id" title="keyword">end</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(708, '0_3_111');
      "><br>
  <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(709, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(710, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(711, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(712, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(713, '0_3_111');
      "><br>
    + <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(714, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(715, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(716, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">b</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(717, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(718, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(719, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(720, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(721, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(722, '0_3_111');
      "><br>
    + <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(723, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(724, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(725, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(726, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(727, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(728, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext%C2%B4"><span class="id" title="definition">setext´</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(729, '0_3_111');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(730, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
The set of finite ordinals 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(734, '0_3_115');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_omega"><span class="id" title="definition">V_omega</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fix</span> <span class="id" title="var">I</span> <span class="id" title="var">n</span> := <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span> 0   ⇒ <a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><br>
                              | <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="HoTT.hit.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> (<a class="idref" href="HoTT.hit.V.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.hit.V.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">end</span>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(735, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
<a name="lab293"></a><h2 class="section">Axioms of set theory (theorem 10.5.8)</h2>
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(742, '0_3_119');
      ">
<br>
<span class="id" title="keyword">Lemma</span> <a name="not_mem_Vempty"><span class="id" title="lemma">not_mem_Vempty</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(743, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(744, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(745, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(746, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">ff</span> <span class="id" title="var">_</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(747, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">ff</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(748, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(749, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pairing"><span class="id" title="lemma">pairing</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hor"><span class="id" title="definition">hor</span></a> (<a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(750, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(751, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(752, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(753, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(754, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(755, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [[|] <span class="id" title="var">p</span>]; [<span class="id" title="tactic">left</span>|<span class="id" title="tactic">right</span>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(756, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">p</span> | <span class="id" title="var">p</span>]; [<span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a> | <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(757, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(758, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="infinity"><span class="id" title="lemma">infinity</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" title="definition">V_empty</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" title="definition">V_omega</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(759, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(760, '0_3_119');
      "><br>
  <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(761, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> 0; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(762, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(763, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(764, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">n</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(765, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(766, '0_3_119');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(767, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(768, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="union"><span class="id" title="lemma">union</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> ⇒ <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(769, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(770, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(771, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_union"><span class="id" title="definition">V_union</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(772, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(773, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(774, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(775, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(776, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">u´</span> <span class="id" title="var">x´</span>] <span class="id" title="var">p</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(777, '0_3_119');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u´</span>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(778, '0_3_119');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u´</span>)<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(779, '0_3_119');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(780, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">x´</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(781, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(782, '0_3_119');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u´</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(783, '0_3_119');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(784, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">u´</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(785, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(786, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u</span> (<span class="id" title="var">Hx</span>, <span class="id" title="var">Hu</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(787, '0_3_119');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>) <span class="id" title="var">Hu</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(788, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(789, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u´</span> <span class="id" title="var">pu</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(790, '0_3_119');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u´</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">pu</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hx</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(791, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(792, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">x´</span> <span class="id" title="var">px</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(793, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(794, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">u´</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">x´</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(795, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">px</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(796, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(797, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="function"><span class="id" title="lemma">function</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#V_is_func"><span class="id" title="definition">V_is_func</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(798, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(799, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(800, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_func"><span class="id" title="definition">V_func</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(801, '0_3_119');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_u</span> : <span class="id" title="var">u</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">u</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(802, '0_3_119');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_v</span> : <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">v</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(803, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">phi</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(804, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(805, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(806, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(807, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(808, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(809, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(810, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(811, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(812, '0_3_119');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(813, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(814, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(815, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(816, '0_3_119');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(817, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(818, '0_3_119');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">memb_u</span> <span class="id" title="var">Hx</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(819, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(820, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(821, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(822, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(823, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(824, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(825, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(826, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">p_phi</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(827, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(828, '0_3_119');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(829, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y´</span> (<span class="id" title="var">Hy</span>, <span class="id" title="var">Hy´</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(830, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(831, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(832, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(833, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(834, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(835, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y´</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy´</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(836, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(837, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a´</span> <span class="id" title="var">p´</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(838, '0_3_119');
      "><br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px</span>, <span class="id" title="var">py</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(839, '0_3_119');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p´</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px´</span>, <span class="id" title="var">py´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(840, '0_3_119');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(841, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a´</span>));<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(842, '0_3_119');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(843, '0_3_119');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(844, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a´</span> (<span class="id" title="var">px</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">px´</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(845, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> ((<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>), <span class="id" title="var">H3</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(846, '0_3_119');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(847, '0_3_119');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><span class="id" title="var">u</span><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a>, <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><span class="id" title="var">v</span><a class="idref" href="HoTT.hit.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(848, '0_3_119');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(849, '0_3_119');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(850, '0_3_119');
      "><br>
      <span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">y</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(851, '0_3_119');
      "><br>
      <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">y</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span><br>
                                 (<span class="id" title="var">H2</span> <span class="id" title="var">x</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_u</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(852, '0_3_119');
      "><br>
      { <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(853, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)] [<span class="id" title="var">y´</span> (<span class="id" title="var">H1_y´</span>, <span class="id" title="var">H2_y´</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(854, '0_3_119');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(855, '0_3_119');
      "><br>
        <span class="id" title="tactic">∃</span> (<span class="id" title="var">H3</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y´</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">H2_y</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">H2_y´</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(856, '0_3_119');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(857, '0_3_119');
      "><br>
      <span class="id" title="tactic">destruct</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.hit.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">y</span>) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">y</span> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span> <span class="id" title="var">H1_y</span>)) <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">Hb</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(858, '0_3_119');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(859, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Hb</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2_y</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(860, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(861, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(862, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(863, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(864, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hz</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(865, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Ha</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(866, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Ha</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(867, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(868, '0_3_119');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(869, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(870, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(871, '0_3_119');
      "><span class="id" title="tactic">intros</span> [(<span class="id" title="var">a</span>,<span class="id" title="var">b</span>) <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(872, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(873, '0_3_119');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(874, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.hit.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(875, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(876, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">H3</span> <span class="id" title="keyword">with</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(877, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(878, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(879, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(880, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(881, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="replacement"><span class="id" title="lemma">replacement</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>),<br>
  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span>, <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(882, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(883, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">r</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(884, '0_3_119');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(885, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(886, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(887, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="var">r</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <span class="id" title="var">f</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(888, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(889, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(890, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(891, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(892, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(893, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(894, '0_3_119');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(895, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(896, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">z</span> [<span class="id" title="var">h</span> <span class="id" title="var">p</span>]]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(897, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(898, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(899, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p´</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(900, '0_3_119');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(901, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">r</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(902, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">r</span> <span class="id" title="var">p´</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(903, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(904, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="separation"><span class="id" title="lemma">separation</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>,<br>
  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(905, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(906, '0_3_119');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(907, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(908, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(909, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">C</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>)<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> ⇒ <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" title="variable">z</span></a>))). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(910, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(911, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(912, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">h</span>] <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(913, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(914, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">assumption</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(915, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(916, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(917, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(918, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(919, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(920, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(921, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(922, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(923, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(924, '0_3_119');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
