<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "Interactive Module RPushout started	";
            responses[i]=data;
          

            i = 45;
            data = "RPushout is defined	";
            responses[i]=data;
          

            i = 46;
            data = "glue is assumed	";
            responses[i]=data;
          

            i = 47;
            data = "RPushout_rect is defined	";
            responses[i]=data;
          

            i = 48;
            data = "RPushout_comp_glue is assumed	";
            responses[i]=data;
          

            i = 49;
            data = "Module RPushout is defined	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "RPushout_rect_nd is defined	";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoals, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   ap (RPushout_rect_nd R P i j gl) (glue R a b r) = gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoals, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   ap (RPushout_rect_nd R P i j gl) (glue R a b r) = gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoals, subgoal 1 (ID 48)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   transport_const (glue R a b r) (i a) @	   ap (RPushout_rect_nd R P i j gl) (glue R a b r) =	   transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 58;
            data = "2 subgoals, subgoal 1 (ID 83)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   transport_const (glue R a b r) (i a) @	   ap (RPushout_rect_nd R P i j gl) (glue R a b r) =	   apD (RPushout_rect_nd R P i j gl) (glue R a b r)		subgoal 2 (ID 84) is:	 apD (RPushout_rect_nd R P i j gl) (glue R a b r) =	 transport_const (glue R a b r) (i a) @ gl a b r	(dependent evars:)		";
            responses[i]=data;
          

            i = 59;
            data = "1 subgoals, subgoal 1 (ID 84)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	   apD (RPushout_rect_nd R P i j gl) (glue R a b r) =	   transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars:)		";
            responses[i]=data;
          

            i = 60;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 61;
            data = "RPushout_comp_nd_glue is defined	";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "bitotal is defined	";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "Interactive Module CumulativeHierarchy started	";
            responses[i]=data;
          

            i = 75;
            data = "V is defined	";
            responses[i]=data;
          

            i = 76;
            data = "setext is assumed	";
            responses[i]=data;
          

            i = 77;
            data = "is0trunc_V is assumed	";
            responses[i]=data;
          

            i = 78;
            data = "V_rect is defined	V_rect is recursively defined (decreasing on 5th argument)	";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "Module CumulativeHierarchy is defined	";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoals, subgoal 1 (ID 97)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   apD (V_rect P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rect P H_0trunc H_set H_setext oD h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 85;
            data = "1 subgoals, subgoal 1 (ID 97)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   apD (V_rect P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rect P H_0trunc H_set H_setext oD h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 86;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 87;
            data = "V_comp_setext is defined	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoals, subgoal 1 (ID 129)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoals, subgoal 1 (ID 129)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 94;
            data = "1 subgoals, subgoal 1 (ID 150)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : RPushout R -> P),	   transport (fun _ : V => P) (setext R bitot_R h)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 95;
            data = "1 subgoals, subgoal 1 (ID 156)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   transport (fun _ : V => P) (setext R bitot_R h)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 96;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 97;
            data = "V_rect_nd is defined	";
            responses[i]=data;
          

            i = 98;
            data = "1 subgoals, subgoal 1 (ID 180)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   ap (V_rect_nd P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rect_nd P H_0trunc H_set H_setext o h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 99;
            data = "1 subgoals, subgoal 1 (ID 180)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	   ap (V_rect_nd P H_0trunc H_set H_setext) (setext R bitot_R h) =	   H_setext A B R bitot_R h (V_rect_nd P H_0trunc H_set H_setext o h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 100;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 101;
            data = "V_comp_nd_setext is defined	";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "equal_img is defined	";
            responses[i]=data;
          

            i = 110;
            data = "1 subgoals, subgoal 1 (ID 196)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 111;
            data = "1 subgoals, subgoal 1 (ID 196)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 112;
            data = "1 subgoals, subgoal 1 (ID 203)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) =>	       {| hproptype := f a = g b; isp := istrunc_paths V (-1) (f a) (g b) |}	    : A -> B -> hProp	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoals, subgoal 1 (ID 207)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) =>	       {| hproptype := f a = g b; isp := istrunc_paths V (-1) (f a) (g b) |}	    : A -> B -> hProp	  h := RPushout_rect_nd R V f g (fun (a : A) (b : B) => idmap)	    : RPushout R -> V	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 114;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 115;
            data = "setext' is defined	";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoals, subgoal 1 (ID 208)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoals, subgoal 1 (ID 208)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   V -> P		(dependent evars:)		";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoals, subgoal 1 (ID 216)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	   forall (A B : Type) (R : A -> B -> hProp),	   bitotal R ->	   forall (h : RPushout R -> V) (H_h : RPushout R -> P),	   H_set A (h o inL R) (H_h o inL R) = H_set B (h o inR R) (H_h o inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoals, subgoal 1 (ID 222)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   H_set A (h o inL R) (H_h o inL R) = H_set B (h o inR R) (H_h o inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 120;
            data = "2 subgoals, subgoal 1 (ID 223)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (h o inL R) (h o inR R)		subgoal 2 (ID 224) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 121;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 223)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (h o inL R) (h o inR R)		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 226)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => (h o inL R) a = (h o inR R) b)		subgoal 2 (ID 227) is:	 forall b : B, hexists (fun a : A => (h o inL R) a = (h o inR R) b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 122;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 226)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => (h o inL R) a = (h o inR R) b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 228)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => (h o inL R) a = (h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 123;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 231)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => R a b) ->	   hexists (fun b : B => (h o inL R) a = (h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 124;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 234)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   {b : B & R a b} -> {b : B & (h o inL R) a = (h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 125;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 239)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & (h o inL R) a = (h o inR R) b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 126;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 241)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   (h o inL R) a = (h o inR R) b		(dependent evars:)		";
            responses[i]=data;
          

            i = 127;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 227)		subgoal 1 (ID 227) is:	 forall b : B, hexists (fun a : A => (h o inL R) a = (h o inR R) b)	subgoal 2 (ID 224) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 128;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 227)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall b : B, hexists (fun a : A => (h o inL R) a = (h o inR R) b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 250)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => (h o inL R) a = (h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 129;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 253)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => R a b) ->	   hexists (fun a : A => (h o inL R) a = (h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 130;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 256)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   {a : A & R a b} -> {a : A & (h o inL R) a = (h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 131;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 261)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & (h o inL R) a0 = (h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 132;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 263)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   (h o inL R) a = (h o inR R) b		(dependent evars:)		";
            responses[i]=data;
          

            i = 133;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 224)		subgoal 1 (ID 224) is:	 equal_img (H_h o inL R) (H_h o inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 134;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 224)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   equal_img (H_h o inL R) (H_h o inR R)		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 273)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => (H_h o inL R) a = (H_h o inR R) b)		subgoal 2 (ID 274) is:	 forall b : B, hexists (fun a : A => (H_h o inL R) a = (H_h o inR R) b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 135;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 273)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall a : A, hexists (fun b : B => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 275)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 136;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 278)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   hexists (fun b : B => R a b) ->	   hexists (fun b : B => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 137;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 281)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	   {b : B & R a b} -> {b : B & (H_h o inL R) a = (H_h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 138;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 286)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & (H_h o inL R) a = (H_h o inR R) b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 139;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 288)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	   (H_h o inL R) a = (H_h o inR R) b		(dependent evars:)		";
            responses[i]=data;
          

            i = 140;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 274)		subgoal 1 (ID 274) is:	 forall b : B, hexists (fun a : A => (H_h o inL R) a = (H_h o inR R) b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 141;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 274)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	   forall b : B, hexists (fun a : A => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 297)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 142;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 300)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   hexists (fun a : A => R a b) ->	   hexists (fun a : A => (H_h o inL R) a = (H_h o inR R) b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 143;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 303)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	   {a : A & R a b} -> {a : A & (H_h o inL R) a = (H_h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 144;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 308)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & (H_h o inL R) a0 = (H_h o inR R) b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 145;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 310)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	   (H_h o inL R) a = (H_h o inR R) b		(dependent evars:)		";
            responses[i]=data;
          

            i = 146;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 147;
            data = "V_rect'_nd is defined	";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoals, subgoal 1 (ID 240)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoals, subgoal 1 (ID 240)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoals, subgoal 1 (ID 243)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoals, subgoal 1 (ID 249)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoals, subgoal 1 (ID 256)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 157;
            data = "1 subgoals, subgoal 1 (ID 263)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoals, subgoal 1 (ID 270)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 159;
            data = "1 subgoals, subgoal 1 (ID 277)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 160;
            data = "2 subgoals, subgoal 1 (ID 281)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   equal_img f g		subgoal 2 (ID 282) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 161;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 281)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   equal_img f g		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 284)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 285) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 162;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 284)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 286)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 163;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 289)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   hexists (fun b : B => R a b) -> hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 164;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 292)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	   {b : B & R a b} -> {b : B & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 165;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 297)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 166;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 299)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 167;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 285)		subgoal 1 (ID 285) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 282) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 168;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 285)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 308)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 169;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 311)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	   hexists (fun a : A => R a b) -> hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 170;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 314)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	   {a : A & R a b} -> {a : A & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 171;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 319)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 172;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 321)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 173;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 282)		subgoal 1 (ID 282) is:	 transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 174;
            data = "1 subgoals, subgoal 1 (ID 282)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R:A -> V) : A -> V	  g := (h o inR R:B -> V) : B -> V	  H_f := (H_h oD inL R:forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R:forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		2 subgoals, subgoal 1 (ID 391)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R))		subgoal 2 (ID 392) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) = H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		";
            responses[i]=data;
          

            i = 175;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 391)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R))		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 412)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   setext R bitot_R h = setext' (h o inL R) (h o inR R) eq_img		(dependent evars:)		";
            responses[i]=data;
          

            i = 176;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 392)		subgoal 1 (ID 392) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) = H_set B (h o inR R) (H_h oD inR R)	(dependent evars:)		1 subgoals, subgoal 1 (ID 392)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   transport P (setext' (h o inL R) (h o inR R) eq_img)	     (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		1 subgoals, subgoal 1 (ID 416)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   (forall a : A,	    hexists	      (fun b : B =>	       hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	   (forall b : B,	    hexists	      (fun a : A =>	       hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)))		(dependent evars:)		";
            responses[i]=data;
          

            i = 177;
            data = "2 subgoals, subgoal 1 (ID 418)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		subgoal 2 (ID 419) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 178;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 418)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 420)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 179;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 424)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 180;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 425)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	   hexists (fun b : B => R a b) ->	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 181;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 428)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	   {b : B & R a b} ->	   {b : B & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 182;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 433)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   {b0 : B & hexists (fun p : f a = g b0 => transport P p (H_f a) = H_g b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 183;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 435)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 184;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 438)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 185;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 448)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 186;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 469)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) =	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a))		(dependent evars:)		";
            responses[i]=data;
          

            i = 187;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 473)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 188;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 474)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 189;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 419)		subgoal 1 (ID 419) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 190;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 419)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	   forall b : B,	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 479)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 191;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 483)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 192;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 484)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   hexists (fun a : A => R a b) ->	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 193;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 487)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	   {a : A & R a b} ->	   {a : A & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 194;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 492)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   {a0 : A & hexists (fun p : f a0 = g b => transport P p (H_f a0) = H_g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 195;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 494)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 196;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 497)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 197;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 507)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 198;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 528)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport P (ap h (glue R a b Rab)) (H_f a) =	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a))		(dependent evars:)		";
            responses[i]=data;
          

            i = 199;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 532)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 200;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 533)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	                (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	                (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := h o inL R : A -> V	  g := h o inR R : B -> V	  H_f := H_h oD inL R : forall a : A, P (f a)	  H_g := H_h oD inR R : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	   transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	   transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 201;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 202;
            data = "V_rect' is defined	";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "1 subgoals, subgoal 1 (ID 245)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 208;
            data = "1 subgoals, subgoal 1 (ID 245)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall v : V, P v		(dependent evars:)		";
            responses[i]=data;
          

            i = 209;
            data = "1 subgoals, subgoal 1 (ID 288)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	   forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	     (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 210;
            data = "1 subgoals, subgoal 1 (ID 294)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	   transport P (setext R bitot_R h) (H_set A (h o inL R) (H_h oD inL R)) =	   H_set B (h o inR R) (H_h oD inR R)		(dependent evars:)		";
            responses[i]=data;
          

            i = 211;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 212;
            data = "V_rect_hprop is defined	";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "ua is assumed	";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "1 subgoals, subgoal 1 (ID 247)	  	  ua : Univalence	  x : V	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 223;
            data = "1 subgoals, subgoal 1 (ID 247)	  	  ua : Univalence	  x : V	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 224;
            data = "2 subgoals, subgoal 1 (ID 257)	  	  ua : Univalence	  x : V	  ============================	   forall A : Type, (A -> V) -> (A -> hProp) -> hProp		subgoal 2 (ID 260) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g -> ?Goal A f H_f = ?Goal B g H_g	(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 open,)		";
            responses[i]=data;
          

            i = 225;
            data = "2 subgoals, subgoal 1 (ID 264)	  	  ua : Univalence	  x : V	  A : Type	  f : A -> V	  ============================	   hProp		subgoal 2 (ID 260) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?Goal@{f:=f0; A:=A0}) A	   f H_f =	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?Goal@{f:=f0; A:=A0}) B	   g H_g	(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 open,)		";
            responses[i]=data;
          

            i = 226;
            data = "1 subgoals, subgoal 1 (ID 260)	  	  ua : Univalence	  x : V	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> hProp) (H_g : B -> hProp),	   equal_img H_f H_g ->	   (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	    {|	    hproptype := hexists (fun a : A0 => f0 a = x);	    isp := istrunc_truncation (-1) {a : A0 & f0 a = x} |}) A f H_f =	   (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	    {|	    hproptype := hexists (fun a : A0 => f0 a = x);	    isp := istrunc_truncation (-1) {a : A0 & f0 a = x} |}) B g H_g		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 227;
            data = "1 subgoals, subgoal 1 (ID 268)	  	  ua : Univalence	  x : V	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> hProp) (H_g : B -> hProp),	   equal_img H_f H_g ->	   {|	   hproptype := hexists (fun a : A => f a = x);	   isp := istrunc_truncation (-1) {a : A & f a = x} |} =	   {|	   hproptype := hexists (fun a : B => g a = x);	   isp := istrunc_truncation (-1) {a : B & g a = x} |}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 228;
            data = "1 subgoals, subgoal 1 (ID 279)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   {|	   hproptype := hexists (fun a : A => f a = x);	   isp := istrunc_truncation (-1) {a : A & f a = x} |} =	   {|	   hproptype := hexists (fun a : B => g a = x);	   isp := istrunc_truncation (-1) {a : B & g a = x} |}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 229;
            data = "2 subgoals, subgoal 1 (ID 289)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   hexists (fun a : A => f a = x) -> hexists (fun a : B => g a = x)		subgoal 2 (ID 290) is:	 hexists (fun a : B => g a = x) -> hexists (fun a : A => f a = x)	(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 230;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 289)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   hexists (fun a : A => f a = x) -> hexists (fun a : B => g a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 291)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  ============================	   hexists (fun a : B => g a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 231;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 305)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  ============================	   {a : A & f a = x} -> hexists (fun a : B => g a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 232;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 310)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  a : A	  p : f a = x	  ============================	   hexists (fun a0 : B => g a0 = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 233;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 313)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  a : A	  p : f a = x	  ============================	   hexists (fun b : B => f a = g b) -> hexists (fun a0 : B => g a0 = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 234;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 316)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  a : A	  p : f a = x	  ============================	   {b : B & f a = g b} -> {a0 : B & g a0 = x}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 235;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 321)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	   {a0 : B & g a0 = x}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 236;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 323)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : A => f a = x)	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	   g b = x		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 237;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 290)		subgoal 1 (ID 290) is:	 hexists (fun a : B => g a = x) -> hexists (fun a : A => f a = x)	(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 238;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 290)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	   hexists (fun a : B => g a = x) -> hexists (fun a : A => f a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 357)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  ============================	   hexists (fun a : A => f a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 239;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 371)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  ============================	   {a : B & g a = x} -> hexists (fun a : A => f a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 240;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 376)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  b : B	  p : g b = x	  ============================	   hexists (fun a : A => f a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 241;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 379)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  b : B	  p : g b = x	  ============================	   hexists (fun a : A => f a = g b) -> hexists (fun a : A => f a = x)		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 242;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 382)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  b : B	  p : g b = x	  ============================	   {a : A & f a = g b} -> {a : A & f a = x}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 243;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 387)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	   {a0 : A & f a0 = x}		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 244;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 389)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : hexists (fun a : B => g a = x)	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	   f a = x		(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 245;
            data = "No more subgoals.	(dependent evars: ?250 using ?255 , ?255 using ?256 , ?256 using ?257 , ?257 using ?261 , ?261 using ?262 , ?262 using ?263 , ?263 using ?264 , ?264 using ,)		";
            responses[i]=data;
          

            i = 246;
            data = "mem is defined	";
            responses[i]=data;
          

            i = 247;
            data = "";
            responses[i]=data;
          

            i = 248;
            data = "";
            responses[i]=data;
          

            i = 249;
            data = "";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "";
            responses[i]=data;
          

            i = 256;
            data = "subset is defined	";
            responses[i]=data;
          

            i = 257;
            data = "";
            responses[i]=data;
          

            i = 258;
            data = "";
            responses[i]=data;
          

            i = 259;
            data = "";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "";
            responses[i]=data;
          

            i = 265;
            data = "1 subgoals, subgoal 1 (ID 288)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 266;
            data = "1 subgoals, subgoal 1 (ID 288)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 267;
            data = "2 subgoals, subgoal 1 (ID 399)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   IsHSet hProp		subgoal 2 (ID 400) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 {|	 hproptype := (forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	              (forall b : A0, hexists (fun a : A => H_f a (f0 b)));	 isp := Prod.trunc_prod |} =	 {|	 hproptype := (forall a : A, hexists (fun b : B => H_f a (g b))) *	              (forall b : B, hexists (fun a : A => H_f a (g b)));	 isp := Prod.trunc_prod |}	(dependent evars:)		";
            responses[i]=data;
          

            i = 268;
            data = "1 subgoals, subgoal 1 (ID 400)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	   forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	   equal_img f0 g ->	   forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	   equal_img H_f0 H_g ->	   {|	   hproptype := (forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	                (forall b : A0, hexists (fun a : A => H_f a (f0 b)));	   isp := Prod.trunc_prod |} =	   {|	   hproptype := (forall a : A, hexists (fun b : B => H_f a (g b))) *	                (forall b : B, hexists (fun a : A => H_f a (g b)));	   isp := Prod.trunc_prod |}		(dependent evars:)		";
            responses[i]=data;
          

            i = 269;
            data = "1 subgoals, subgoal 1 (ID 453)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   {|	   hproptype := (forall a : A, hexists (fun b : B => H_f a (g b))) *	                (forall b : B, hexists (fun a : A => H_f a (g b)));	   isp := fun	            x	             y : (forall a : A, hexists (fun b : B => H_f a (g b))) *	                 (forall b : B, hexists (fun a : A => H_f a (g b))) =>	          trunc_equiv (Prod.path_prod_uncurried x y) |} =	   {|	   hproptype := (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	                (forall b : B', hexists (fun a : A => H_f a (g' b)));	   isp := fun	            x	             y : (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	                 (forall b : B', hexists (fun a : A => H_f a (g' b))) =>	          trunc_equiv (Prod.path_prod_uncurried x y) |}		(dependent evars:)		";
            responses[i]=data;
          

            i = 270;
            data = "2 subgoals, subgoal 1 (ID 463)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, hexists (fun b : B => H_f a (g b))) *	   (forall b : B, hexists (fun a : A => H_f a (g b))) ->	   (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	   (forall b : B', hexists (fun a : A => H_f a (g' b)))		subgoal 2 (ID 464) is:	 (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	 (forall b : B', hexists (fun a : A => H_f a (g' b))) ->	 (forall a : A, hexists (fun b : B => H_f a (g b))) *	 (forall b : B, hexists (fun a : A => H_f a (g b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 271;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 463)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, hexists (fun b : B => H_f a (g b))) *	   (forall b : B, hexists (fun a : A => H_f a (g b))) ->	   (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	   (forall b : B', hexists (fun a : A => H_f a (g' b)))		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 471)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  ============================	   forall a : A, hexists (fun b : B' => H_f a (g' b))		subgoal 2 (ID 472) is:	 forall b : B', hexists (fun a : A => H_f a (g' b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 272;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 471)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  ============================	   forall a : A, hexists (fun b : B' => H_f a (g' b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 473)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  ============================	   hexists (fun b : B' => H_f a (g' b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 273;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 494)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  ============================	   {b : B & H_f a (g b)} -> hexists (fun b : B' => H_f a (g' b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 274;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 499)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   hexists (fun b0 : B' => H_f a (g' b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 275;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 502)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   hexists (fun b0 : B' => g b = g' b0) ->	   hexists (fun b0 : B' => H_f a (g' b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 276;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 503)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   merely {b0 : B' & g b = g' b0} -> merely {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 277;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 525)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	   {b0 : B' & g b = g' b0} -> {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 278;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 530)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	   {b0 : B' & H_f a (g' b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 279;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 532)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	   H_f a (g' b')		(dependent evars:)		";
            responses[i]=data;
          

            i = 280;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 472)		subgoal 1 (ID 472) is:	 forall b : B', hexists (fun a : A => H_f a (g' b))	subgoal 2 (ID 464) is:	 (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	 (forall b : B', hexists (fun a : A => H_f a (g' b))) ->	 (forall a : A, hexists (fun b : B => H_f a (g b))) *	 (forall b : B, hexists (fun a : A => H_f a (g b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 281;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 472)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  ============================	   forall b : B', hexists (fun a : A => H_f a (g' b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 536)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  ============================	   hexists (fun a : A => H_f a (g' b'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 282;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 559)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  ============================	   {a : B & g a = g' b'} -> hexists (fun a : A => H_f a (g' b'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 283;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 564)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   hexists (fun a : A => H_f a (g' b'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 284;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 565)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   hexists (fun a : A => H_f a (g b)) -> hexists (fun a : A => H_f a (g' b'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 285;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 568)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  b : B	  p : g b = g' b'	  ============================	   {a : A & H_f a (g b)} -> {a : A & H_f a (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 286;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 573)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	   {a0 : A & H_f a0 (g' b')}		(dependent evars:)		";
            responses[i]=data;
          

            i = 287;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 575)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B => H_f a (g b))	  H2 : forall b : B, hexists (fun a : A => H_f a (g b))	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	   H_f a (g' b')		(dependent evars:)		";
            responses[i]=data;
          

            i = 288;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 464)		subgoal 1 (ID 464) is:	 (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	 (forall b : B', hexists (fun a : A => H_f a (g' b))) ->	 (forall a : A, hexists (fun b : B => H_f a (g b))) *	 (forall b : B, hexists (fun a : A => H_f a (g b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 289;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 464)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	   (forall a : A, hexists (fun b : B' => H_f a (g' b))) *	   (forall b : B', hexists (fun a : A => H_f a (g' b))) ->	   (forall a : A, hexists (fun b : B => H_f a (g b))) *	   (forall b : B, hexists (fun a : A => H_f a (g b)))		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 585)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  ============================	   forall a : A, hexists (fun b : B => H_f a (g b))		subgoal 2 (ID 586) is:	 forall b : B, hexists (fun a : A => H_f a (g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 290;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 585)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  ============================	   forall a : A, hexists (fun b : B => H_f a (g b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 587)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  ============================	   hexists (fun b : B => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 291;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 608)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  ============================	   {b : B' & H_f a (g' b)} -> hexists (fun b : B => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 292;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 613)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   hexists (fun b : B => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 293;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 616)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   hexists (fun a0 : B => g a0 = g' b') -> hexists (fun b : B => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 294;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 619)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	   {a0 : B & g a0 = g' b'} -> {b : B & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 295;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 624)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	   {b0 : B & H_f a (g b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 296;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 626)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	   H_f a (g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 586)		subgoal 1 (ID 586) is:	 forall b : B, hexists (fun a : A => H_f a (g b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 298;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 586)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  ============================	   forall b : B, hexists (fun a : A => H_f a (g b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 633)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  ============================	   hexists (fun a : A => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 299;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 656)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  ============================	   {b0 : B' & g b = g' b0} -> hexists (fun a : A => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 300;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 661)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   hexists (fun a : A => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 301;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 662)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   hexists (fun a : A => H_f a (g' b')) -> hexists (fun a : A => H_f a (g b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 302;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 665)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  b' : B'	  p : g b = g' b'	  ============================	   {a : A & H_f a (g' b')} -> {a : A & H_f a (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 303;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 670)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	   {a0 : A & H_f a0 (g b)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 304;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 672)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, hexists (fun b : B' => H_f a (g' b))	  H2 : forall b : B', hexists (fun a : A => H_f a (g' b))	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	   H_f a (g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 305;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 306;
            data = "bisim_aux is defined	";
            responses[i]=data;
          

            i = 307;
            data = "1 subgoals, subgoal 1 (ID 289)	  	  ua : Univalence	  ============================	   V -> V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 308;
            data = "1 subgoals, subgoal 1 (ID 289)	  	  ua : Univalence	  ============================	   V -> V -> hProp		(dependent evars:)		";
            responses[i]=data;
          

            i = 309;
            data = "1 subgoals, subgoal 1 (ID 304)	  	  ua : Univalence	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> V -> hProp) (H_g : B -> V -> hProp),	   equal_img H_f H_g -> bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 310;
            data = "1 subgoals, subgoal 1 (ID 312)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 311;
            data = "1 subgoals, subgoal 1 (ID 317)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   bisim_aux A f H_f == bisim_aux B g H_g		(dependent evars:)		";
            responses[i]=data;
          

            i = 312;
            data = "1 subgoals, subgoal 1 (ID 357)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	   forall (A0 : Type) (f0 : A0 -> V),	   (forall a : A0, bisim_aux A f H_f (f0 a) = bisim_aux B g H_g (f0 a)) ->	   bisim_aux A f H_f (set f0) = bisim_aux B g H_g (set f0)		(dependent evars:)		";
            responses[i]=data;
          

            i = 313;
            data = "1 subgoals, subgoal 1 (ID 362)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   bisim_aux A f H_f (set h) = bisim_aux B g H_g (set h)		(dependent evars:)		";
            responses[i]=data;
          

            i = 314;
            data = "2 subgoals, subgoal 1 (ID 374)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : A, hexists (fun b : C => H_f a (h b))) *	   (forall b : C, hexists (fun a : A => H_f a (h b))) ->	   (forall a : B, hexists (fun b : C => H_g a (h b))) *	   (forall b : C, hexists (fun a : B => H_g a (h b)))		subgoal 2 (ID 377) is:	 (forall a : B, hexists (fun b : C => H_g a (h b))) *	 (forall b : C, hexists (fun a : B => H_g a (h b))) ->	 (forall a : A, hexists (fun b : C => H_f a (h b))) *	 (forall b : C, hexists (fun a : A => H_f a (h b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 315;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 374)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : A, hexists (fun b : C => H_f a (h b))) *	   (forall b : C, hexists (fun a : A => H_f a (h b))) ->	   (forall a : B, hexists (fun b : C => H_g a (h b))) *	   (forall b : C, hexists (fun a : B => H_g a (h b)))		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 384)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  ============================	   forall a : B, hexists (fun b : C => H_g a (h b))		subgoal 2 (ID 385) is:	 forall b : C, hexists (fun a : B => H_g a (h b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 316;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 384)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  ============================	   forall a : B, hexists (fun b : C => H_g a (h b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 386)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  ============================	   hexists (fun b0 : C => H_g b (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 317;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 408)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  ============================	   {a : A & H_f a = H_g b} -> hexists (fun b0 : C => H_g b (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 318;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 413)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   hexists (fun b0 : C => H_g b (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 319;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 414)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   hexists (fun b0 : C => H_f a (h b0)) ->	   hexists (fun b0 : C => H_g b (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 320;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 417)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  a : A	  p : H_f a = H_g b	  ============================	   {b0 : C & H_f a (h b0)} -> {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 321;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 422)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	   {b0 : C & H_g b (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 322;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 424)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	   H_g b (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 323;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 385)		subgoal 1 (ID 385) is:	 forall b : C, hexists (fun a : B => H_g a (h b))	subgoal 2 (ID 377) is:	 (forall a : B, hexists (fun b : C => H_g a (h b))) *	 (forall b : C, hexists (fun a : B => H_g a (h b))) ->	 (forall a : A, hexists (fun b : C => H_f a (h b))) *	 (forall b : C, hexists (fun a : A => H_f a (h b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 324;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 385)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  ============================	   forall b : C, hexists (fun a : B => H_g a (h b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 433)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  ============================	   hexists (fun a : B => H_g a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 325;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 453)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  ============================	   {a : A & H_f a (h c)} -> hexists (fun a : B => H_g a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 326;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 458)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   hexists (fun a0 : B => H_g a0 (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 327;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 461)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   hexists (fun b : B => H_f a = H_g b) ->	   hexists (fun a0 : B => H_g a0 (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 328;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 464)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	   {b : B & H_f a = H_g b} -> {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 329;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 469)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	   {a0 : B & H_g a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 330;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 471)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, hexists (fun b : C => H_f a (h b))	  H2 : forall b : C, hexists (fun a : A => H_f a (h b))	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	   H_g b (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 331;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 377)		subgoal 1 (ID 377) is:	 (forall a : B, hexists (fun b : C => H_g a (h b))) *	 (forall b : C, hexists (fun a : B => H_g a (h b))) ->	 (forall a : A, hexists (fun b : C => H_f a (h b))) *	 (forall b : C, hexists (fun a : A => H_f a (h b)))	(dependent evars:)		";
            responses[i]=data;
          

            i = 332;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 377)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	   (forall a : B, hexists (fun b : C => H_g a (h b))) *	   (forall b : C, hexists (fun a : B => H_g a (h b))) ->	   (forall a : A, hexists (fun b : C => H_f a (h b))) *	   (forall b : C, hexists (fun a : A => H_f a (h b)))		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  ============================	   forall a : A, hexists (fun b : C => H_f a (h b))		subgoal 2 (ID 487) is:	 forall b : C, hexists (fun a : A => H_f a (h b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 333;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  ============================	   forall a : A, hexists (fun b : C => H_f a (h b))		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 488)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  ============================	   hexists (fun b : C => H_f a (h b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 334;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 510)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  ============================	   {b : B & H_f a = H_g b} -> hexists (fun b : C => H_f a (h b))		(dependent evars:)		";
            responses[i]=data;
          

            i = 335;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 515)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   hexists (fun b0 : C => H_f a (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 336;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 516)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   hexists (fun b0 : C => H_g b (h b0)) ->	   hexists (fun b0 : C => H_f a (h b0))		(dependent evars:)		";
            responses[i]=data;
          

            i = 337;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 519)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  b : B	  p : H_f a = H_g b	  ============================	   {b0 : C & H_g b (h b0)} -> {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 338;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 524)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	   {b0 : C & H_f a (h b0)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 339;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 526)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	   H_f a (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 340;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 487)		subgoal 1 (ID 487) is:	 forall b : C, hexists (fun a : A => H_f a (h b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 341;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 487)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  ============================	   forall b : C, hexists (fun a : A => H_f a (h b))		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 538)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  ============================	   hexists (fun a : A => H_f a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 342;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 558)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  ============================	   {a : B & H_g a (h c)} -> hexists (fun a : A => H_f a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 343;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 563)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   hexists (fun a : A => H_f a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 344;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 566)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   hexists (fun a : A => H_f a = H_g b) -> hexists (fun a : A => H_f a (h c))		(dependent evars:)		";
            responses[i]=data;
          

            i = 345;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 569)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	   {a : A & H_f a = H_g b} -> {a : A & H_f a (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 346;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 574)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	   {a0 : A & H_f a0 (h c)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 347;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 576)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, hexists (fun b : C => H_g a (h b))	  H2 : forall b : C, hexists (fun a : B => H_g a (h b))	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	   H_f a (h c)		(dependent evars:)		";
            responses[i]=data;
          

            i = 348;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 349;
            data = "bisimulation is defined	";
            responses[i]=data;
          

            i = 350;
            data = "";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "1 subgoals, subgoal 1 (ID 291)	  	  ua : Univalence	  ============================	   Reflexive (fun x x0 : V => x ~~ x0)		(dependent evars:)		";
            responses[i]=data;
          

            i = 353;
            data = "1 subgoals, subgoal 1 (ID 303)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A, f a ~~ f a) -> set f ~~ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 354;
            data = "1 subgoals, subgoal 1 (ID 317)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   (forall a : A,	    hexists	      (fun b : A =>	       V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	         (fun (A0 B : Type) (R : A0 -> B -> hProp) 	            (bitot_R : bitotal R) (h : RPushout R -> V)	            (H_h : RPushout R -> V -> hProp) =>	          transport_const (setext R bitot_R h)	            (bisim_aux A0 (h o inL R) (H_h o inL R)) @	          path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	            (bisim_aux B (h o inR R) (H_h o inR R))	            (V_rect_hprop	               (fun v : V =>	                bisim_aux A0 (h o inL R) (H_h o inL R) v =	                bisim_aux B (h o inR R) (H_h o inR R) v)	               (fun (C : Type) (h0 : C -> V)	                  (_ : forall a0 : C,	                       bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                       bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                path_iff_hProp_uncurried	                  (fun	                     X : (forall a0 : A0,	                          hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                         (forall b0 : C,	                          hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                   (fun b0 : B =>	                    Trunc_rect_nondep	                      (fun	                         X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                       Trunc_functor (-1)	                         (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                          (X1.1;	                          transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                         (fst X X0.1))	                      (Trunc_functor (-1)	                         (fun X0 : {a0 : A0 & R a0 b0} =>	                          (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                         (snd bitot_R b0)),	                   fun c : C =>	                   Trunc_rect_nondep	                     (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B &	                                (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                         (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                        (Trunc_functor (-1)	                           (fun X1 : {b0 : B & R X0.1 b0} =>	                            (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                           (fst bitot_R X0.1))) (snd X c)),	                  fun	                    X : (forall a0 : B,	                         hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	                  (fun a0 : A0 =>	                   Trunc_rect_nondep	                     (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                         (X1.1;	                         transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b0 : B & R a0 b0} =>	                         (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                        (fst bitot_R a0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                        (X1.1;	                        transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a0 : A0 & R a0 X0.1} =>	                           (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	               (fun v : V =>	                istrunc_paths hProp (-1)	                  (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                  (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	         (f a) (f b))) *	   (forall b : A,	    hexists	      (fun a : A =>	       V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	         (fun (A0 B : Type) (R : A0 -> B -> hProp) 	            (bitot_R : bitotal R) (h : RPushout R -> V)	            (H_h : RPushout R -> V -> hProp) =>	          transport_const (setext R bitot_R h)	            (bisim_aux A0 (h o inL R) (H_h o inL R)) @	          path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	            (bisim_aux B (h o inR R) (H_h o inR R))	            (V_rect_hprop	               (fun v : V =>	                bisim_aux A0 (h o inL R) (H_h o inL R) v =	                bisim_aux B (h o inR R) (H_h o inR R) v)	               (fun (C : Type) (h0 : C -> V)	                  (_ : forall a0 : C,	                       bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                       bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	                path_iff_hProp_uncurried	                  (fun	                     X : (forall a0 : A0,	                          hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                         (forall b0 : C,	                          hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                   (fun b0 : B =>	                    Trunc_rect_nondep	                      (fun	                         X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                       Trunc_functor (-1)	                         (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                          (X1.1;	                          transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                         (fst X X0.1))	                      (Trunc_functor (-1)	                         (fun X0 : {a0 : A0 & R a0 b0} =>	                          (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                         (snd bitot_R b0)),	                   fun c : C =>	                   Trunc_rect_nondep	                     (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B &	                                (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                         (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                        (Trunc_functor (-1)	                           (fun X1 : {b0 : B & R X0.1 b0} =>	                            (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                           (fst bitot_R X0.1))) (snd X c)),	                  fun	                    X : (forall a0 : B,	                         hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	                  (fun a0 : A0 =>	                   Trunc_rect_nondep	                     (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                         (X1.1;	                         transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b0 : B & R a0 b0} =>	                         (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                        (fst bitot_R a0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                        (X1.1;	                        transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a0 : A0 & R a0 X0.1} =>	                           (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	               (fun v : V =>	                istrunc_paths hProp (-1)	                  (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                  (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	         (f a) (f b)))		(dependent evars:)		";
            responses[i]=data;
          

            i = 355;
            data = "2 subgoals, subgoal 1 (ID 319)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall a : A,	   hexists	     (fun b : A =>	      V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (f b))		subgoal 2 (ID 320) is:	 forall b : A,	 hexists	   (fun a : A =>	    V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (h o inL R) (H_h o inL R)) @	       path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	         (bisim_aux B (h o inR R) (H_h o inR R))	         (V_rect_hprop	            (fun v : V =>	             bisim_aux A0 (h o inL R) (H_h o inL R) v =	             bisim_aux B (h o inR R) (H_h o inR R) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                    bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	             path_iff_hProp_uncurried	               (fun	                  X : (forall a0 : A0,	                       hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                      (forall b0 : C,	                       hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                (fun b0 : B =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                    Trunc_functor (-1)	                      (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                       (X1.1; transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1; ap H_h (glue R X0.1 b0 X0.2))) 	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rect_nondep	                  (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B & (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                      (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                        (fst bitot_R X0.1))) (snd X c)),	               fun	                 X : (forall a0 : B,	                      hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                     (forall b0 : C,	                      hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	               (fun a0 : A0 =>	                Trunc_rect_nondep	                  (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                   Trunc_functor (-1)	                     (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                      (X1.1;	                      transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1; ap H_h (glue R a0 X0.1 X0.2))) 	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rect_nondep	                 (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                     (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (h o inL R) (H_h o inL R) v)	               (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	      (f a) (f b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 356;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 319)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall a : A,	   hexists	     (fun b : A =>	      V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (f b))		(dependent evars:)		<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 320)		subgoal 1 (ID 320) is:	 forall b : A,	 hexists	   (fun a : A =>	    V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (h o inL R) (H_h o inL R)) @	       path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	         (bisim_aux B (h o inR R) (H_h o inR R))	         (V_rect_hprop	            (fun v : V =>	             bisim_aux A0 (h o inL R) (H_h o inL R) v =	             bisim_aux B (h o inR R) (H_h o inR R) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                    bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	             path_iff_hProp_uncurried	               (fun	                  X : (forall a0 : A0,	                       hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                      (forall b0 : C,	                       hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                (fun b0 : B =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                    Trunc_functor (-1)	                      (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                       (X1.1; transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1; ap H_h (glue R X0.1 b0 X0.2))) 	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rect_nondep	                  (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B & (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                      (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                        (fst bitot_R X0.1))) (snd X c)),	               fun	                 X : (forall a0 : B,	                      hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                     (forall b0 : C,	                      hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	               (fun a0 : A0 =>	                Trunc_rect_nondep	                  (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                   Trunc_functor (-1)	                     (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                      (X1.1;	                      transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1; ap H_h (glue R a0 X0.1 X0.2))) 	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rect_nondep	                 (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                     (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (h o inL R) (H_h o inL R) v)	               (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	      (f a) (f b))	(dependent evars:)		";
            responses[i]=data;
          

            i = 357;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 320)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	   forall b : A,	   hexists	     (fun a : A =>	      V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v =	               bisim_aux B (h o inR R) (H_h o inR R) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v)	                 (bisim_aux B (h o inR R) (H_h o inR R) v)))) 	        (f a) (f b))		(dependent evars:)		No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 358;
            data = "reflexive_bisimulation is defined	";
            responses[i]=data;
          

            i = 359;
            data = "1 subgoals, subgoal 1 (ID 293)	  	  ua : Univalence	  ============================	   forall u v : V, u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 360;
            data = "1 subgoals, subgoal 1 (ID 293)	  	  ua : Univalence	  ============================	   forall u v : V, u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 361;
            data = "1 subgoals, subgoal 1 (ID 295)	  	  ua : Univalence	  u : V	  v : V	  ============================	   u = v <~> u ~~ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 362;
            data = "2 subgoals, subgoal 1 (ID 301)	  	  ua : Univalence	  u : V	  v : V	  ============================	   u = v -> u ~~ v		subgoal 2 (ID 302) is:	 u ~~ v -> u = v	(dependent evars:)		";
            responses[i]=data;
          

            i = 363;
            data = "1 subgoals, subgoal 1 (ID 302)	  	  ua : Univalence	  u : V	  v : V	  ============================	   u ~~ v -> u = v		(dependent evars:)		";
            responses[i]=data;
          

            i = 364;
            data = "1 subgoals, subgoal 1 (ID 307)	  	  ua : Univalence	  u : V	  v : V	  ============================	   forall u0 v0 : V, u0 ~~ v0 -> u0 = v0		(dependent evars:)		";
            responses[i]=data;
          

            i = 365;
            data = "1 subgoals, subgoal 1 (ID 371)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  ============================	   forall v0 : V, set f ~~ v0 -> set f = v0		(dependent evars:)		";
            responses[i]=data;
          

            i = 366;
            data = "1 subgoals, subgoal 1 (ID 423)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  ============================	   set f ~~ set g -> set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 367;
            data = "1 subgoals, subgoal 1 (ID 439)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 368;
            data = "1 subgoals, subgoal 1 (ID 442)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 369;
            data = "2 subgoals, subgoal 1 (ID 444)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 445) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 370;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 444)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 446)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  a : A	  ============================	   hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 371;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 447)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  a : A	  ============================	   hexists	     (fun b : B =>	      V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	           (bitot_R : bitotal R) (h : RPushout R -> V)	           (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B0 (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v0 : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	               bisim_aux B0 (h o inR R) (H_h o inR R) v0)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B0 =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B0 & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B0,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v0 : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                 (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	        (f a) (g b)) -> hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 372;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 450)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  a : A	  ============================	   {b : B &	   V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B0 (h o inR R) (H_h o inR R))	        (V_rect_hprop	           (fun v0 : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	            bisim_aux B0 (h o inR R) (H_h o inR R) v0)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hProp_uncurried	              (fun	                 X : (forall a0 : A0,	                      hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                     (forall b0 : C,	                      hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	               (fun b0 : B0 =>	                Trunc_rect_nondep	                  (fun X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                   Trunc_functor (-1)	                     (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                      (X1.1; transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1; ap H_h (glue R X0.1 b0 X0.2))) 	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rect_nondep	                 (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B0 & (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                     (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B0 & R X0.1 b0} =>	                        (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                       (fst bitot_R X0.1))) (snd X c)),	              fun	                X : (forall a0 : B0,	                     hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                    (forall b0 : C,	                     hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	              (fun a0 : A0 =>	               Trunc_rect_nondep	                 (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                  Trunc_functor (-1)	                    (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                     (X1.1;	                     transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1; ap H_h (glue R a0 X0.1 X0.2))) 	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rect_nondep	                (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                    (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	           (fun v0 : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	              (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	     (f a) (g b)} -> {b : B & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 373;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 455)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  a : A	  b : B	  h : V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	           (bitot_R : bitotal R) (h : RPushout R -> V)	           (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B0 (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v0 : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	               bisim_aux B0 (h o inR R) (H_h o inR R) v0)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B0 =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B0 & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B0,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v0 : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                 (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	        (f a) (g b)	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 374;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 445)		subgoal 1 (ID 445) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 375;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 445)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 458)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 376;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 459)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  b : B	  ============================	   hexists	     (fun a : A =>	      V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	           (bitot_R : bitotal R) (h : RPushout R -> V)	           (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B0 (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v0 : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	               bisim_aux B0 (h o inR R) (H_h o inR R) v0)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B0 =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B0 & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B0,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v0 : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                 (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	        (f a) (g b)) -> hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 377;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 462)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  b : B	  ============================	   {a : A &	   V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (h o inL R) (H_h o inL R)) @	      path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	        (bisim_aux B0 (h o inR R) (H_h o inR R))	        (V_rect_hprop	           (fun v0 : V =>	            bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	            bisim_aux B0 (h o inR R) (H_h o inR R) v0)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                   bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	            path_iff_hProp_uncurried	              (fun	                 X : (forall a0 : A0,	                      hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                     (forall b0 : C,	                      hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	               (fun b0 : B0 =>	                Trunc_rect_nondep	                  (fun X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                   Trunc_functor (-1)	                     (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                      (X1.1; transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1; ap H_h (glue R X0.1 b0 X0.2))) 	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rect_nondep	                 (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B0 & (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                     (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B0 & R X0.1 b0} =>	                        (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                       (fst bitot_R X0.1))) (snd X c)),	              fun	                X : (forall a0 : B0,	                     hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                    (forall b0 : C,	                     hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	              (fun a0 : A0 =>	               Trunc_rect_nondep	                 (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                  Trunc_functor (-1)	                    (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                     (X1.1;	                     transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1; ap H_h (glue R a0 X0.1 X0.2))) 	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rect_nondep	                (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                    (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	           (fun v0 : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	              (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	     (f a) (g b)} -> {a : A & f a = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 378;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 467)	  	  ua : Univalence	  u : V	  v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v0 : V), f a ~~ v0 -> f a = v0	  B : Type	  g : B -> V	  H1 : forall a : A,	       hexists	         (fun b : B =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  H2 : forall b : B,	       hexists	         (fun a : A =>	          V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow)	            bisim_aux	            (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	               (bitot_R : bitotal R) (h : RPushout R -> V)	               (H_h : RPushout R -> V -> hProp) =>	             transport_const (setext R bitot_R h)	               (bisim_aux A0 (h o inL R) (H_h o inL R)) @	             path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	               (bisim_aux B0 (h o inR R) (H_h o inR R))	               (V_rect_hprop	                  (fun v0 : V =>	                   bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	                   bisim_aux B0 (h o inR R) (H_h o inR R) v0)	                  (fun (C : Type) (h0 : C -> V)	                     (_ : forall a0 : C,	                          bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                          bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	                   path_iff_hProp_uncurried	                     (fun	                        X : (forall a0 : A0,	                             hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                            (forall b0 : C,	                             hexists	                               (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                      (fun b0 : B0 =>	                       Trunc_rect_nondep	                         (fun	                            X0 : {a0 : A0 &	                                 (H_h o inL R) a0 = (H_h o inR R) b0} =>	                          Trunc_functor (-1)	                            (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                             (X1.1;	                             transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                            (fst X X0.1))	                         (Trunc_functor (-1)	                            (fun X0 : {a0 : A0 & R a0 b0} =>	                             (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                            (snd bitot_R b0)),	                      fun c : C =>	                      Trunc_rect_nondep	                        (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : B0 &	                                   (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                            (X1.1;	                            transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                           (Trunc_functor (-1)	                              (fun X1 : {b0 : B0 & R X0.1 b0} =>	                               (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                              (fst bitot_R X0.1))) 	                        (snd X c)),	                     fun	                       X : (forall a0 : B0,	                            hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                           (forall b0 : C,	                            hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                     (fun a0 : A0 =>	                      Trunc_rect_nondep	                        (fun	                           X0 : {b0 : B0 &	                                (H_h o inL R) a0 = (H_h o inR R) b0} =>	                         Trunc_functor (-1)	                           (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                            (X1.1;	                            transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B0 & R a0 b0} =>	                            (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rect_nondep	                       (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A0 &	                                  (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                           (X1.1;	                           transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A0 & R a0 X0.1} =>	                              (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                             (snd bitot_R X0.1))) (snd X c))))	                  (fun v0 : V =>	                   istrunc_paths hProp (-1)	                     (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                     (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	            (f a) (g b))	  b : B	  a : A	  h : V_rect (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	           (bitot_R : bitotal R) (h : RPushout R -> V)	           (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A0 (h o inL R) (H_h o inL R)) @	         path_forall (bisim_aux A0 (h o inL R) (H_h o inL R))	           (bisim_aux B0 (h o inR R) (H_h o inR R))	           (V_rect_hprop	              (fun v0 : V =>	               bisim_aux A0 (h o inL R) (H_h o inL R) v0 =	               bisim_aux B0 (h o inR R) (H_h o inR R) v0)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a0 : C,	                      bisim_aux A0 (h o inL R) (H_h o inL R) (h0 a0) =	                      bisim_aux B0 (h o inR R) (H_h o inR R) (h0 a0)) =>	               path_iff_hProp_uncurried	                 (fun	                    X : (forall a0 : A0,	                         hexists (fun b0 : C => (H_h o inL R) a0 (h0 b0))) *	                        (forall b0 : C,	                         hexists (fun a0 : A0 => (H_h o inL R) a0 (h0 b0))) =>	                  (fun b0 : B0 =>	                   Trunc_rect_nondep	                     (fun	                        X0 : {a0 : A0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                      Trunc_functor (-1)	                        (fun X1 : {b1 : C & (H_h o inL R) X0.1 (h0 b1)} =>	                         (X1.1;	                         transport hproptype (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a0 : A0 & R a0 b0} =>	                         (X0.1; ap H_h (glue R X0.1 b0 X0.2)))	                        (snd bitot_R b0)),	                  fun c : C =>	                  Trunc_rect_nondep	                    (fun X0 : {a0 : A0 & (H_h o inL R) a0 (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B0 &	                               (H_h o inL R) X0.1 = (H_h o inR R) b0} =>	                        (X1.1; transport hproptype (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b0 : B0 & R X0.1 b0} =>	                           (X1.1; ap H_h (glue R X0.1 X1.1 X1.2)))	                          (fst bitot_R X0.1))) (snd X c)),	                 fun	                   X : (forall a0 : B0,	                        hexists (fun b0 : C => (H_h o inR R) a0 (h0 b0))) *	                       (forall b0 : C,	                        hexists (fun a0 : B0 => (H_h o inR R) a0 (h0 b0))) =>	                 (fun a0 : A0 =>	                  Trunc_rect_nondep	                    (fun X0 : {b0 : B0 & (H_h o inL R) a0 = (H_h o inR R) b0} =>	                     Trunc_functor (-1)	                       (fun X1 : {b0 : C & (H_h o inR R) X0.1 (h0 b0)} =>	                        (X1.1;	                        transport hproptype (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B0 & R a0 b0} =>	                        (X0.1; ap H_h (glue R a0 X0.1 X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rect_nondep	                   (fun X0 : {a0 : B0 & (H_h o inR R) a0 (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              (H_h o inL R) a0 = (H_h o inR R) X0.1} =>	                       (X1.1; transport hproptype (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1; ap H_h (glue R X1.1 X0.1 X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	              (fun v0 : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A0 (h o inL R) (H_h o inL R) v0)	                 (bisim_aux B0 (h o inR R) (H_h o inR R) v0)))) 	        (f a) (g b)	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 379;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 380;
            data = "bisimulation_equiv_id is defined	";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "ker_bisim is defined	";
            responses[i]=data;
          

            i = 391;
            data = "1 subgoals, subgoal 1 (ID 300)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars:)		";
            responses[i]=data;
          

            i = 392;
            data = "1 subgoals, subgoal 1 (ID 300)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars:)		";
            responses[i]=data;
          

            i = 393;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 394;
            data = "ker_bisim_is_ker is defined	";
            responses[i]=data;
          

            i = 395;
            data = "";
            responses[i]=data;
          

            i = 396;
            data = "";
            responses[i]=data;
          

            i = 397;
            data = "";
            responses[i]=data;
          

            i = 398;
            data = "";
            responses[i]=data;
          

            i = 399;
            data = "";
            responses[i]=data;
          

            i = 400;
            data = "u is assumed	Au is assumed	Au' is assumed	h is assumed	h' is assumed	mu is assumed	mono is assumed	mu' is assumed	mono' is assumed	p is assumed	p' is assumed	";
            responses[i]=data;
          

            i = 401;
            data = "1 subgoals, subgoal 1 (ID 313)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   (forall a : Au, {a' : Au' & mu' a' = mu a}) *	   (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars:)		";
            responses[i]=data;
          

            i = 402;
            data = "1 subgoals, subgoal 1 (ID 313)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   (forall a : Au, {a' : Au' & mu' a' = mu a}) *	   (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars:)		";
            responses[i]=data;
          

            i = 403;
            data = "2 subgoals, subgoal 1 (ID 315)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   forall a : Au, {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 316) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars:)		";
            responses[i]=data;
          

            i = 404;
            data = "2 subgoals, subgoal 1 (ID 317)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a : Au	  ============================	   {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 316) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars:)		";
            responses[i]=data;
          

            i = 405;
            data = "1 subgoals, subgoal 1 (ID 316)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	   forall a' : Au', {a : Au & mu a = mu' a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 406;
            data = "1 subgoals, subgoal 1 (ID 335)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a' : Au'	  ============================	   {a : Au & mu a = mu' a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 407;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 408;
            data = "eq_img_untrunc is defined	";
            responses[i]=data;
          

            i = 409;
            data = "e is defined	";
            responses[i]=data;
          

            i = 410;
            data = "inv_e is defined	";
            responses[i]=data;
          

            i = 411;
            data = "1 subgoals, subgoal 1 (ID 324)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	   Sect inv_e e		(dependent evars:)		";
            responses[i]=data;
          

            i = 412;
            data = "1 subgoals, subgoal 1 (ID 324)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	   Sect inv_e e		(dependent evars:)		";
            responses[i]=data;
          

            i = 413;
            data = "1 subgoals, subgoal 1 (ID 326)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	   e (inv_e a') = a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 414;
            data = "1 subgoals, subgoal 1 (ID 329)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	   mu' (e (inv_e a')) = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 415;
            data = "2 subgoals, subgoal 1 (ID 366)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	   mu' (e (inv_e a')) = mu (inv_e a')		subgoal 2 (ID 367) is:	 mu (inv_e a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 416;
            data = "1 subgoals, subgoal 1 (ID 367)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	   mu (inv_e a') = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 417;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 418;
            data = "hom1 is defined	";
            responses[i]=data;
          

            i = 419;
            data = "1 subgoals, subgoal 1 (ID 327)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	   Sect e inv_e		(dependent evars:)		";
            responses[i]=data;
          

            i = 420;
            data = "1 subgoals, subgoal 1 (ID 327)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	   Sect e inv_e		(dependent evars:)		";
            responses[i]=data;
          

            i = 421;
            data = "1 subgoals, subgoal 1 (ID 329)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	   inv_e (e a) = a		(dependent evars:)		";
            responses[i]=data;
          

            i = 422;
            data = "1 subgoals, subgoal 1 (ID 332)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	   mu (inv_e (e a)) = mu a		(dependent evars:)		";
            responses[i]=data;
          

            i = 423;
            data = "2 subgoals, subgoal 1 (ID 371)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  a : Au	  ============================	   mu (inv_e (e a)) = mu' (e a)		subgoal 2 (ID 372) is:	 mu' (e a) = mu a	(dependent evars:)		";
            responses[i]=data;
          

            i = 424;
            data = "1 subgoals, subgoal 1 (ID 372)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  a : Au	  ============================	   mu' (e a) = mu a		(dependent evars:)		";
            responses[i]=data;
          

            i = 425;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 426;
            data = "hom2 is defined	";
            responses[i]=data;
          

            i = 427;
            data = "1 subgoals, subgoal 1 (ID 329)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' = Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 428;
            data = "1 subgoals, subgoal 1 (ID 329)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' = Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 429;
            data = "1 subgoals, subgoal 1 (ID 333)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	   Au' <~> Au		(dependent evars:)		";
            responses[i]=data;
          

            i = 430;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 431;
            data = "path is defined	";
            responses[i]=data;
          

            i = 432;
            data = "1 subgoals, subgoal 1 (ID 337)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoals, subgoal 1 (ID 337)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 434;
            data = "1 subgoals, subgoal 1 (ID 342)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu == mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoals, subgoal 1 (ID 344)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun A : Type => A -> V) path^ mu a' = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 436;
            data = "2 subgoals, subgoal 1 (ID 402)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun A : Type => A -> V) path^ mu a' =	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))		subgoal 2 (ID 403) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 437;
            data = "1 subgoals, subgoal 1 (ID 403)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	   mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 438;
            data = "2 subgoals, subgoal 1 (ID 458)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	   mu (transport idmap (path^)^ a')		subgoal 2 (ID 459) is:	 mu (transport idmap (path^)^ a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 439;
            data = "1 subgoals, subgoal 1 (ID 459)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu' a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 440;
            data = "2 subgoals, subgoal 1 (ID 506)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu (inv_e a')		subgoal 2 (ID 507) is:	 mu (inv_e a') = mu' a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 441;
            data = "1 subgoals, subgoal 1 (ID 506)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   mu (transport idmap (path^)^ a') = mu (inv_e a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 442;
            data = "1 subgoals, subgoal 1 (ID 535)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap (path^)^ a' = inv_e a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 443;
            data = "2 subgoals, subgoal 1 (ID 581)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap (path^)^ a' = transport idmap path a'		subgoal 2 (ID 582) is:	 transport idmap path a' = inv_e a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 444;
            data = "1 subgoals, subgoal 1 (ID 582)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	   transport idmap path a' = inv_e a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 445;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 446;
            data = "mu_eq_mu' is defined	";
            responses[i]=data;
          

            i = 447;
            data = "1 subgoals, subgoal 1 (ID 360)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 448;
            data = "1 subgoals, subgoal 1 (ID 360)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 449;
            data = "1 subgoals, subgoal 1 (ID 363)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   {p0 : Au = Au' &	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     p0 (mu; (h, mono, p)) = (mu'; (h', mono', p'))}		(dependent evars:)		";
            responses[i]=data;
          

            i = 450;
            data = "1 subgoals, subgoal 1 (ID 368)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     path^ (mu; (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 451;
            data = "2 subgoals, subgoal 1 (ID 432)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport	     (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	     path^ (mu; (h, mono, p)) =	   (transport (fun A : Type => A -> V) path^ mu;	   transportD (fun A : Type => A -> V)	     (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	      IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	     (h, mono, p))		subgoal 2 (ID 433) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 452;
            data = "1 subgoals, subgoal 1 (ID 433)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   (transport (fun A : Type => A -> V) path^ mu;	   transportD (fun A : Type => A -> V)	     (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	      IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	     (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 453;
            data = "1 subgoals, subgoal 1 (ID 577)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := fun a' : Au' =>	          isinj_embedding mu' mono' (e (inv_e a')) a'	            ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2)	       : Sect inv_e e	  hom2 := fun a : Au =>	          isinj_embedding mu mono (inv_e (e a)) a	            ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2)	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	   transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars:)		";
            responses[i]=data;
          

            i = 454;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 455;
            data = "monic_set_present_uniqueness is defined	";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "";
            responses[i]=data;
          

            i = 461;
            data = "1 subgoals, subgoal 1 (ID 307)	  	  ua : Univalence	  ============================	   forall u : V,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 462;
            data = "1 subgoals, subgoal 1 (ID 307)	  	  ua : Univalence	  ============================	   forall u : V,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 463;
            data = "2 subgoals, subgoal 1 (ID 308)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A,	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		subgoal 2 (ID 309) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 464;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 308)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall a : A,	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 313)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 465;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 371)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   {Au0 : Type &	   {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (set f = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 466;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 375)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   IsHSet Au * IsEmbedding mu * (set f = set mu)		(dependent evars:)		";
            responses[i]=data;
          

            i = 467;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 377)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   IsHSet Au * IsEmbedding mu		subgoal 2 (ID 378) is:	 set f = set mu	(dependent evars:)		";
            responses[i]=data;
          

            i = 468;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 378)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   set f = set mu		(dependent evars:)		";
            responses[i]=data;
          

            i = 469;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 385)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall a : A, hexists (fun b : Au => f a = mu b)		subgoal 2 (ID 386) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 470;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 385)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall a : A, hexists (fun b : Au => f a = mu b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 387)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a : A	  ============================	   hexists (fun b : Au => f a = mu b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 471;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 392)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a : A	  ============================	   f a = mu (eu a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 472;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 386)		subgoal 1 (ID 386) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	subgoal 2 (ID 309) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 473;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 386)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  ============================	   forall b : Au, hexists (fun a : A => f a = mu b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 397)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  ============================	   hexists (fun a : A => f a = mu a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 474;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 398)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  ============================	   Connectedness.IsConnected (-1) (hfiber eu a') ->	   hexists (fun a : A => f a = mu a')		(dependent evars:)		";
            responses[i]=data;
          

            i = 475;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 445)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : Connectedness.IsConnected (-1) (hfiber eu a')	  ============================	   hfiber eu a' -> {a : A & f a = mu a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 476;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 450)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : Connectedness.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   {a0 : A & f a0 = mu a'}		(dependent evars:)		";
            responses[i]=data;
          

            i = 477;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 452)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : Connectedness.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   f a = mu a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 478;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 487)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : Connectedness.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   f a = mu (eu a)		subgoal 2 (ID 488) is:	 mu (eu a) = mu a'	(dependent evars:)		";
            responses[i]=data;
          

            i = 479;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 488)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : Connectedness.IsConnMap (-1) eu	  mono_mu : IsEmbedding mu	  factor : f = mu o eu	  a' : Au	  X : Connectedness.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	   mu (eu a) = mu a'		(dependent evars:)		";
            responses[i]=data;
          

            i = 480;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 309)		subgoal 1 (ID 309) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars:)		";
            responses[i]=data;
          

            i = 481;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 309)	  	  ua : Univalence	  ============================	   forall v : V,	   IsHProp	     {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 497)	  	  ua : Univalence	  v : V	  ============================	   IsHProp	     {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars:)		";
            responses[i]=data;
          

            i = 482;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 498)	  	  ua : Univalence	  v : V	  ============================	   forall	     x	      y : {Au : Type &	          {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}, 	   x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 483;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 515)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  ============================	   forall	     y : {Au0 : Type &	         {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (v = set m)}},	   (Au; (mu; (hset, mono, p))) = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 484;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 532)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  Au' : Type	  mu' : Au' -> V	  hset' : IsHSet Au'	  mono' : IsEmbedding mu'	  p' : v = set mu'	  ============================	   (Au; (mu; (hset, mono, p))) = (Au'; (mu'; (hset', mono', p')))		(dependent evars:)		";
            responses[i]=data;
          

            i = 485;
            data = "No more subgoals.	(dependent evars: ?533 using , ?534 using , ?535 using , ?538 using , ?540 using ,)		";
            responses[i]=data;
          

            i = 486;
            data = "monic_set_present is defined	";
            responses[i]=data;
          

            i = 487;
            data = "type_of_members is defined	";
            responses[i]=data;
          

            i = 488;
            data = "";
            responses[i]=data;
          

            i = 489;
            data = "func_of_members is defined	";
            responses[i]=data;
          

            i = 490;
            data = "is_hset_typeofmembers is defined	";
            responses[i]=data;
          

            i = 491;
            data = "IsEmbedding_funcofmembers is defined	";
            responses[i]=data;
          

            i = 492;
            data = "is_valid_presentation is defined	";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "";
            responses[i]=data;
          

            i = 497;
            data = "";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "1 subgoals, subgoal 1 (ID 343)	  	  ua : Univalence	  ============================	   forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 501;
            data = "1 subgoals, subgoal 1 (ID 343)	  	  ua : Univalence	  ============================	   forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 502;
            data = "1 subgoals, subgoal 1 (ID 420)	  	  ua : Univalence	  ============================	   forall (A : Type) (f : A -> V),	   (forall (a : A) (y : V), f a ⊆ y * y ⊆ f a <-> f a = y) ->	   forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 503;
            data = "1 subgoals, subgoal 1 (ID 424)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars:)		";
            responses[i]=data;
          

            i = 504;
            data = "1 subgoals, subgoal 1 (ID 497)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   forall (A0 : Type) (f0 : A0 -> V),	   (forall a : A0, set f ⊆ f0 a * f0 a ⊆ set f <-> set f = f0 a) ->	   set f ⊆ set f0 * set f0 ⊆ set f <-> set f = set f0		(dependent evars:)		";
            responses[i]=data;
          

            i = 505;
            data = "1 subgoals, subgoal 1 (ID 501)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f <-> set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 506;
            data = "2 subgoals, subgoal 1 (ID 503)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f -> set f = set g		subgoal 2 (ID 504) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 507;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 503)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f ⊆ set g * set g ⊆ set f -> set f = set g		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 509)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   set f = set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 508;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 512)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 509;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 514)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 515) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 510;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 514)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 516)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	   hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 511;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 536)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	   {a0 : B & g a0 = f a} -> hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 512;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 541)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   hexists (fun b0 : B => f a = g b0)		(dependent evars:)		";
            responses[i]=data;
          

            i = 513;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 544)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 514;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 546)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	   f a = g b		(dependent evars:)		";
            responses[i]=data;
          

            i = 515;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 515)		subgoal 1 (ID 515) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 504) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 516;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 515)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 550)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 517;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 551)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	   g b ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 518;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 504)		subgoal 1 (ID 504) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 519;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 504)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	   set f = set g -> set f ⊆ set g * set g ⊆ set f		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 560)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set f ⊆ set g		subgoal 2 (ID 561) is:	 set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 520;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 560)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set f ⊆ set g		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 564)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set f	  ============================	   z ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 521;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 561)		subgoal 1 (ID 561) is:	 set g ⊆ set f	(dependent evars:)		";
            responses[i]=data;
          

            i = 522;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 561)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	   set g ⊆ set f		(dependent evars:)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 570)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set g	  ============================	   z ∈ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 523;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 524;
            data = "extensionality is defined	";
            responses[i]=data;
          

            i = 525;
            data = "1 subgoals, subgoal 1 (ID 348)	  	  ua : Univalence	  C : V -> hProp	  ============================	   (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 526;
            data = "1 subgoals, subgoal 1 (ID 348)	  	  ua : Univalence	  C : V -> hProp	  ============================	   (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 527;
            data = "1 subgoals, subgoal 1 (ID 349)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	   forall v : V, C v		(dependent evars:)		";
            responses[i]=data;
          

            i = 528;
            data = "1 subgoals, subgoal 1 (ID 367)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	   forall (A : Type) (f : A -> V), (forall a : A, C (f a)) -> C (set f)		(dependent evars:)		";
            responses[i]=data;
          

            i = 529;
            data = "1 subgoals, subgoal 1 (ID 370)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	   C (set f)		(dependent evars:)		";
            responses[i]=data;
          

            i = 530;
            data = "1 subgoals, subgoal 1 (ID 371)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	   forall x : V, x ∈ set f -> C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 531;
            data = "1 subgoals, subgoal 1 (ID 373)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	   C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 532;
            data = "1 subgoals, subgoal 1 (ID 379)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	   {a : A & f a = x} -> C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 533;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  a : A	  p : f a = x	  ============================	   C x		(dependent evars:)		";
            responses[i]=data;
          

            i = 534;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 535;
            data = "mem_induction is defined	";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "";
            responses[i]=data;
          

            i = 543;
            data = "";
            responses[i]=data;
          

            i = 544;
            data = "1 subgoals, subgoal 1 (ID 350)	  	  ua : Univalence	  ============================	   Irreflexive (fun x x0 : V => x ∈ x0)		(dependent evars:)		";
            responses[i]=data;
          

            i = 545;
            data = "1 subgoals, subgoal 1 (ID 366)	  	  ua : Univalence	  ============================	   forall v : V, (forall x : V, x ∈ v -> ~ x ∈ x) -> ~ v ∈ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 546;
            data = "1 subgoals, subgoal 1 (ID 368)	  	  ua : Univalence	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  ============================	   ~ v ∈ v		(dependent evars:)		";
            responses[i]=data;
          

            i = 547;
            data = "1 subgoals, subgoal 1 (ID 370)	  	  ua : Univalence	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  Hv : v ∈ v	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 548;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 549;
            data = "irreflexive_mem is defined	";
            responses[i]=data;
          

            i = 550;
            data = "1 subgoals, subgoal 1 (ID 363)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	   set f = set g -> equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 551;
            data = "1 subgoals, subgoal 1 (ID 363)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	   set f = set g -> equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 552;
            data = "1 subgoals, subgoal 1 (ID 364)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   equal_img f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 553;
            data = "2 subgoals, subgoal 1 (ID 366)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 367) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 554;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 366)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall a : A, hexists (fun b : B => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 368)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 555;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 370)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set g		subgoal 2 (ID 371) is:	 hexists (fun b : B => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 556;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 370)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set g		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 379)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	   f a ∈ set f		(dependent evars:)		";
            responses[i]=data;
          

            i = 557;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 371)		subgoal 1 (ID 371) is:	 hexists (fun b : B => f a = g b)	subgoal 2 (ID 367) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 371)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	   hexists (fun b : B => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 558;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 389)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	   {a0 : B & g a0 = f a} -> {b : B & f a = g b}		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 394)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  b : B	  p' : g b = f a	  ============================	   {b0 : B & f a = g b0}		(dependent evars:)		";
            responses[i]=data;
          

            i = 559;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 367)		subgoal 1 (ID 367) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 560;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 367)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	   forall b : B, hexists (fun a : A => f a = g b)		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 400)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 561;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 402)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set f		subgoal 2 (ID 403) is:	 hexists (fun a : A => f a = g b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 562;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 402)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set f		(dependent evars:)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 414)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	   g b ∈ set g		(dependent evars:)		";
            responses[i]=data;
          

            i = 563;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 403)		subgoal 1 (ID 403) is:	 hexists (fun a : A => f a = g b)	(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 403)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	   hexists (fun a : A => f a = g b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 564;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 424)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	   {a : A & f a = g b} -> {a : A & f a = g b}		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 429)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  a : A	  p' : f a = g b	  ============================	   {a0 : A & f a0 = g b}		(dependent evars:)		";
            responses[i]=data;
          

            i = 565;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 566;
            data = "path_V_eqimg is defined	";
            responses[i]=data;
          

            i = 567;
            data = "";
            responses[i]=data;
          

            i = 568;
            data = "";
            responses[i]=data;
          

            i = 569;
            data = "";
            responses[i]=data;
          

            i = 570;
            data = "";
            responses[i]=data;
          

            i = 571;
            data = "";
            responses[i]=data;
          

            i = 572;
            data = "";
            responses[i]=data;
          

            i = 573;
            data = "";
            responses[i]=data;
          

            i = 574;
            data = "";
            responses[i]=data;
          

            i = 575;
            data = "";
            responses[i]=data;
          

            i = 576;
            data = "V_empty is defined	";
            responses[i]=data;
          

            i = 577;
            data = "";
            responses[i]=data;
          

            i = 578;
            data = "";
            responses[i]=data;
          

            i = 579;
            data = "";
            responses[i]=data;
          

            i = 580;
            data = "";
            responses[i]=data;
          

            i = 581;
            data = "V_singleton is defined	";
            responses[i]=data;
          

            i = 582;
            data = "";
            responses[i]=data;
          

            i = 583;
            data = "1 subgoals, subgoal 1 (ID 373)	  	  ua : Univalence	  u : V	  v : V	  ============================	   IsEquiv (ap V_singleton)		(dependent evars:)		";
            responses[i]=data;
          

            i = 584;
            data = "1 subgoals, subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  v : V	  ============================	   V_singleton u = V_singleton v -> u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 open, ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 ,)		";
            responses[i]=data;
          

            i = 585;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 384)	  	  ua : Univalence	  u : V	  v : V	  ============================	   V_singleton u = V_singleton v -> u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 open, ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 560)	  	  ua : Univalence	  u : V	  v : V	  H : V_singleton u = V_singleton v	  ============================	   u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 open,)		";
            responses[i]=data;
          

            i = 586;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 565)	  	  ua : Univalence	  u : V	  v : V	  H : V_singleton u = V_singleton v	  ============================	   equal_img (Unit_rect u) (Unit_rect v) -> u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 open, ?566 using ,)		";
            responses[i]=data;
          

            i = 587;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 571)	  	  ua : Univalence	  u : V	  v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit,	       hexists (fun b : Unit => Unit_rect u a = Unit_rect v b)	  H2 : forall b : Unit,	       hexists (fun a : Unit => Unit_rect u a = Unit_rect v b)	  ============================	   u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 using ?567 , ?566 using , ?567 using ?568 , ?568 using ?569 , ?569 using ?570 , ?570 using ?571 , ?571 open,)		";
            responses[i]=data;
          

            i = 588;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 584)	  	  ua : Univalence	  u : V	  v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit,	       hexists (fun b : Unit => Unit_rect u a = Unit_rect v b)	  H2 : forall b : Unit,	       hexists (fun a : Unit => Unit_rect u a = Unit_rect v b)	  ============================	   {b : Unit & Unit_rect u tt = Unit_rect v b} -> u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 using ?567 , ?566 using , ?567 using ?568 , ?568 using ?569 , ?569 using ?570 , ?570 using ?571 , ?571 using ?576 , ?576 using ?578 , ?578 using ?579 , ?579 using ?580 , ?580 using ?581 , ?581 using ?582 , ?582 using ?583 , ?583 using ?584 , ?584 open,)		";
            responses[i]=data;
          

            i = 589;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 589)	  	  ua : Univalence	  u : V	  v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit,	       hexists (fun b : Unit => Unit_rect u a = Unit_rect v b)	  H2 : forall b : Unit,	       hexists (fun a : Unit => Unit_rect u a = Unit_rect v b)	  t : Unit	  p : Unit_rect u tt = Unit_rect v t	  ============================	   u = v		(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 using ?567 , ?566 using , ?567 using ?568 , ?568 using ?569 , ?569 using ?570 , ?570 using ?571 , ?571 using ?576 , ?576 using ?578 , ?578 using ?579 , ?579 using ?580 , ?580 using ?581 , ?581 using ?582 , ?582 using ?583 , ?583 using ?584 , ?584 using ?585 , ?585 using ?586 , ?586 using ?587 , ?587 using ?588 , ?588 using ?589 , ?589 open,)		";
            responses[i]=data;
          

            i = 590;
            data = "No more subgoals.	(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 using ?567 , ?566 using , ?567 using ?568 , ?568 using ?569 , ?569 using ?570 , ?570 using ?571 , ?571 using ?576 , ?576 using ?578 , ?578 using ?579 , ?579 using ?580 , ?580 using ?581 , ?581 using ?582 , ?582 using ?583 , ?583 using ?584 , ?584 using ?585 , ?585 using ?586 , ?586 using ?587 , ?587 using ?588 , ?588 using ?589 , ?589 using ?590 , ?590 using ?591 , ?591 using ?592 , ?592 using ?593 , ?593 using ?594 , ?594 using ,)		No more subgoals.	(dependent evars: ?377 using ?381 , ?378 using ?385 ?377 , ?379 using ?389 ?377 , ?381 using ?382 , ?382 using ?383 , ?383 using ?384 , ?384 using ?560 , ?385 using ?386 , ?386 using ?387 , ?387 using ?388 , ?388 using ?519 ?384 , ?389 using ?390 , ?390 using ?391 , ?391 using ?392 , ?392 using ?524 ?384 , ?519 using ?520 , ?520 using ?384 , ?524 using ?525 , ?525 using ?384 , ?560 using ?566 ?565 , ?565 using ?567 , ?566 using , ?567 using ?568 , ?568 using ?569 , ?569 using ?570 , ?570 using ?571 , ?571 using ?576 , ?576 using ?578 , ?578 using ?579 , ?579 using ?580 , ?580 using ?581 , ?581 using ?582 , ?582 using ?583 , ?583 using ?584 , ?584 using ?585 , ?585 using ?586 , ?586 using ?587 , ?587 using ?588 , ?588 using ?589 , ?589 using ?590 , ?590 using ?591 , ?591 using ?592 , ?592 using ?593 , ?593 using ?594 , ?594 using ,)		";
            responses[i]=data;
          

            i = 591;
            data = "";
            responses[i]=data;
          

            i = 592;
            data = "";
            responses[i]=data;
          

            i = 593;
            data = "";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "isequiv_ap_V_singleton is defined	";
            responses[i]=data;
          

            i = 596;
            data = "V_pair is defined	";
            responses[i]=data;
          

            i = 597;
            data = "1 subgoals, subgoal 1 (ID 382)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  ============================	   (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars:)		1 subgoals, subgoal 1 (ID 382)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  ============================	   (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars:)		";
            responses[i]=data;
          

            i = 598;
            data = "1 subgoals, subgoal 1 (ID 387)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   V_pair u v = V_pair u' v'		(dependent evars:)		";
            responses[i]=data;
          

            i = 599;
            data = "1 subgoals, subgoal 1 (ID 390)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   equal_img (fun b : Bool => if b then u else v)	     (fun b : Bool => if b then u' else v')		(dependent evars:)		";
            responses[i]=data;
          

            i = 600;
            data = "2 subgoals, subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall a : Bool,	   hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		subgoal 2 (ID 393) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 601;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall a : Bool,	   hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars:)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 394)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun b : Bool => u = (if b then u' else v'))		subgoal 2 (ID 395) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 602;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 400)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   u = u'		subgoal 2 (ID 395) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 603;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 395)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun b : Bool => v = (if b then u' else v'))		(dependent evars:)		";
            responses[i]=data;
          

            i = 604;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 393)		subgoal 1 (ID 393) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars:)		";
            responses[i]=data;
          

            i = 605;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 393)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   forall b : Bool,	   hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars:)		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 406)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun a : Bool => (if a then u else v) = u')		subgoal 2 (ID 407) is:	 hexists (fun a : Bool => (if a then u else v) = v')	(dependent evars:)		";
            responses[i]=data;
          

            i = 606;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 407)	  	  ua : Univalence	  u : V	  v : V	  u' : V	  v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	   hexists (fun a : Bool => (if a then u else v) = v')		(dependent evars:)		";
            responses[i]=data;
          

            i = 607;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 608;
            data = "path_pair is defined	";
            responses[i]=data;
          

            i = 609;
            data = "1 subgoals, subgoal 1 (ID 389)	  	  ua : Univalence	  u : V	  v : V	  w : V	  ============================	   V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 610;
            data = "1 subgoals, subgoal 1 (ID 389)	  	  ua : Univalence	  u : V	  v : V	  w : V	  ============================	   V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 611;
            data = "2 subgoals, subgoal 1 (ID 391)	  	  ua : Univalence	  u : V	  v : V	  w : V	  ============================	   V_pair u v = V_singleton w -> (u = w) * (v = w)		subgoal 2 (ID 392) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars:)		";
            responses[i]=data;
          

            i = 612;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 391)	  	  ua : Univalence	  u : V	  v : V	  w : V	  ============================	   V_pair u v = V_singleton w -> (u = w) * (v = w)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 393)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 613;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 404)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 614;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 438)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	  ============================	   {b : Unit & u = Unit_rect w b} -> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 615;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 448)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	  p : u = Unit_rect w tt	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 616;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 485)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	  p : u = Unit_rect w tt	  ============================	   {b : Unit & v = Unit_rect w b} -> (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 617;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 495)	  	  ua : Univalence	  u : V	  v : V	  w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	  p : u = Unit_rect w tt	  p' : v = Unit_rect w tt	  ============================	   (u = w) * (v = w)		(dependent evars:)		";
            responses[i]=data;
          

            i = 618;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 392)		subgoal 1 (ID 392) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars:)		";
            responses[i]=data;
          

            i = 619;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 392)	  	  ua : Univalence	  u : V	  v : V	  w : V	  ============================	   (u = w) * (v = w) -> V_pair u v = V_singleton w		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 503)	  	  ua : Univalence	  u : V	  v : V	  w : V	  p1 : u = w	  p2 : v = w	  ============================	   V_pair u v = V_singleton w		(dependent evars:)		";
            responses[i]=data;
          

            i = 620;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 508)	  	  ua : Univalence	  u : V	  v : V	  w : V	  p1 : u = w	  p2 : v = w	  ============================	   forall a : Bool,	   hexists (fun b : Unit => (if a then u else v) = Unit_rect w b)		subgoal 2 (ID 509) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 621;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 515)	  	  ua : Univalence	  u : V	  v : V	  w : V	  p1 : u = w	  p2 : v = w	  a : Bool	  ============================	   (if a then u else v) = Unit_rect w tt		subgoal 2 (ID 509) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)	(dependent evars:)		";
            responses[i]=data;
          

            i = 622;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 509)	  	  ua : Univalence	  u : V	  v : V	  w : V	  p1 : u = w	  p2 : v = w	  ============================	   forall b : Unit,	   hexists (fun a : Bool => (if a then u else v) = Unit_rect w b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 623;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 525)	  	  ua : Univalence	  u : V	  v : V	  w : V	  p1 : u = w	  p2 : v = w	  t : Unit	  ============================	   u = Unit_rect w t		(dependent evars:)		";
            responses[i]=data;
          

            i = 624;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 625;
            data = "pair_eq_singleton is defined	";
            responses[i]=data;
          

            i = 626;
            data = "";
            responses[i]=data;
          

            i = 627;
            data = "";
            responses[i]=data;
          

            i = 628;
            data = "";
            responses[i]=data;
          

            i = 629;
            data = "";
            responses[i]=data;
          

            i = 630;
            data = "V_pair_ord is defined	";
            responses[i]=data;
          

            i = 631;
            data = "";
            responses[i]=data;
          

            i = 632;
            data = "1 subgoals, subgoal 1 (ID 397)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  ============================	   [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 633;
            data = "1 subgoals, subgoal 1 (ID 397)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  ============================	   [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 634;
            data = "2 subgoals, subgoal 1 (ID 399)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  ============================	   [a, b] = [c, d] -> (a = c) * (b = d)		subgoal 2 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 635;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 399)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  ============================	   [a, b] = [c, d] -> (a = c) * (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 401)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 636;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 403)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   a = c		subgoal 2 (ID 404) is:	 (a = c) * (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 637;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 403)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   a = c		(dependent evars:)		2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 405)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [c, d]		subgoal 2 (ID 406) is:	 a = c	(dependent evars:)		";
            responses[i]=data;
          

            i = 638;
            data = "1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 405)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 414)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   V_singleton a ∈ [a, b]		(dependent evars:)		";
            responses[i]=data;
          

            i = 639;
            data = "1 focused subgoals	(unfocused: 1-1-1), subgoal 1 (ID 416)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  ============================	   hexists	     (fun a0 : Bool =>	      (if a0 then V_singleton a else V_pair a b) = V_singleton a)		(dependent evars:)		";
            responses[i]=data;
          

            i = 640;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 406)		subgoal 1 (ID 406) is:	 a = c	subgoal 2 (ID 404) is:	 (a = c) * (b = d)	subgoal 3 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 406)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	   a = c		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 436)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	   {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_singleton a} ->	   a = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 641;
            data = "2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 448)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	   a = c		subgoal 2 (ID 449) is:	 a = c	(dependent evars:)		";
            responses[i]=data;
          

            i = 642;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 449)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_pair c d = V_singleton a	  ============================	   a = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 643;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 404)		subgoal 1 (ID 404) is:	 (a = c) * (b = d)	subgoal 2 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 644;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 404)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   (a = c) * (b = d)		(dependent evars:)		2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 481)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   a = c		subgoal 2 (ID 482) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 645;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 482)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 646;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 485)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   hor (b = c) (b = d)		subgoal 2 (ID 486) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 647;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 485)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   hor (b = c) (b = d)		(dependent evars:)		2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 487)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [c, d]		subgoal 2 (ID 488) is:	 hor (b = c) (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 648;
            data = "1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 487)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 496)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	   V_pair a b ∈ [a, b]		(dependent evars:)		";
            responses[i]=data;
          

            i = 649;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 488)		subgoal 1 (ID 488) is:	 hor (b = c) (b = d)	subgoal 2 (ID 486) is:	 b = d	subgoal 3 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 488)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	   hor (b = c) (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 650;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 516)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	   {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_pair a b} ->	   hor (b = c) (b = d)		(dependent evars:)		2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 528)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   hor (b = c) (b = d)		subgoal 2 (ID 529) is:	 hor (b = c) (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 651;
            data = "1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 528)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   hor (b = c) (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 1-1-0-1), subgoal 1 (ID 534)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	   b = c		(dependent evars:)		";
            responses[i]=data;
          

            i = 652;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		3 subgoals, subgoal 1 (ID 529)		subgoal 1 (ID 529) is:	 hor (b = c) (b = d)	subgoal 2 (ID 486) is:	 b = d	subgoal 3 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 653;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 529)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  ============================	   hor (b = c) (b = d)		(dependent evars:)		1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 557)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	   hor (b = c) (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 654;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 561)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	   {a0 : Bool & (if a0 then c else d) = b} -> (b = c) + (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 655;
            data = "2 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 573)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	   (b = c) + (b = d)		subgoal 2 (ID 574) is:	 (b = c) + (b = d)	(dependent evars:)		";
            responses[i]=data;
          

            i = 656;
            data = "1 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 574)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : d = b	  ============================	   (b = c) + (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 657;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 486)		subgoal 1 (ID 486) is:	 b = d	subgoal 2 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 486)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	   b = d		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 599)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	   (b = c) + (b = d) -> b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 658;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 605)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   b = d		subgoal 2 (ID 606) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 659;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 605)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 660;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 608)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   [a, b] = V_singleton (V_singleton b)		subgoal 2 (ID 609) is:	 b = d	(dependent evars:)		";
            responses[i]=data;
          

            i = 661;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 608)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   [a, b] = V_singleton (V_singleton b)		(dependent evars:)		1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 615)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   (V_singleton a = V_singleton b) * (V_pair a b = V_singleton b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 662;
            data = "2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 617)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   V_singleton a = V_singleton b		subgoal 2 (ID 618) is:	 V_pair a b = V_singleton b	(dependent evars:)		";
            responses[i]=data;
          

            i = 663;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 618)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   V_pair a b = V_singleton b		(dependent evars:)		";
            responses[i]=data;
          

            i = 664;
            data = "1 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 634)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	   (a = b) * (b = b)		(dependent evars:)		";
            responses[i]=data;
          

            i = 665;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 609)		subgoal 1 (ID 609) is:	 b = d	subgoal 2 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 666;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 609)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  ============================	   b = d		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 648)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  H'' : V_pair c d = V_singleton b	  ============================	   b = d		(dependent evars:)		";
            responses[i]=data;
          

            i = 667;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 400)		subgoal 1 (ID 400) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars:)		";
            responses[i]=data;
          

            i = 668;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 400)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  ============================	   (a = c) * (b = d) -> [a, b] = [c, d]		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 694)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : a = c	  p' : b = d	  ============================	   [a, b] = [c, d]		(dependent evars:)		";
            responses[i]=data;
          

            i = 669;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 699)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : a = c	  p' : b = d	  ============================	   (V_singleton a = V_singleton c) * (V_pair a b = V_pair c d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 670;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 701)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : a = c	  p' : b = d	  ============================	   V_singleton a = V_singleton c		subgoal 2 (ID 702) is:	 V_pair a b = V_pair c d	(dependent evars:)		";
            responses[i]=data;
          

            i = 671;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 702)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : a = c	  p' : b = d	  ============================	   V_pair a b = V_pair c d		(dependent evars:)		";
            responses[i]=data;
          

            i = 672;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 710)	  	  ua : Univalence	  a : V	  b : V	  c : V	  d : V	  p : a = c	  p' : b = d	  ============================	   (a = c) * (b = d)		(dependent evars:)		";
            responses[i]=data;
          

            i = 673;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 674;
            data = "path_pair_ord is defined	";
            responses[i]=data;
          

            i = 675;
            data = "";
            responses[i]=data;
          

            i = 676;
            data = "";
            responses[i]=data;
          

            i = 677;
            data = "";
            responses[i]=data;
          

            i = 678;
            data = "";
            responses[i]=data;
          

            i = 679;
            data = "V_cart_prod is defined	";
            responses[i]=data;
          

            i = 680;
            data = "Toplevel input, characters 0-68:	> Notation \" a * b \" := (V_cart_prod a b)	>   (at level 25) : set_scope. 	Error: Notation _ * _ is already defined at level 40 with arguments	at level 40, at next level while it is now required to be at level 25	with arguments at next level, at next level.	";
            responses[i]=data;
          

            i = 681;
            data = "";
            responses[i]=data;
          

            i = 682;
            data = "";
            responses[i]=data;
          

            i = 683;
            data = "";
            responses[i]=data;
          

            i = 684;
            data = "";
            responses[i]=data;
          

            i = 685;
            data = "Toplevel input, characters 58-59:	> Definition V_is_func (a : V) (b : V) (f : V) := f ⊆ a * b	>                                                         ^	Error:	In environment	ua : Univalence	a : V	b : V	f : V	The term \"b\" has type \"V\" while it is expected to have type \"Type\".	";
            responses[i]=data;
          

            i = 686;
            data = "";
            responses[i]=data;
          

            i = 687;
            data = "";
            responses[i]=data;
          

            i = 688;
            data = "";
            responses[i]=data;
          

            i = 689;
            data = "";
            responses[i]=data;
          

            i = 690;
            data = "V_func is defined	";
            responses[i]=data;
          

            i = 691;
            data = "";
            responses[i]=data;
          

            i = 692;
            data = "";
            responses[i]=data;
          

            i = 693;
            data = "";
            responses[i]=data;
          

            i = 694;
            data = "";
            responses[i]=data;
          

            i = 695;
            data = "V_union is defined	";
            responses[i]=data;
          

            i = 696;
            data = "";
            responses[i]=data;
          

            i = 697;
            data = "";
            responses[i]=data;
          

            i = 698;
            data = "";
            responses[i]=data;
          

            i = 699;
            data = "";
            responses[i]=data;
          

            i = 700;
            data = "1 subgoals, subgoal 1 (ID 414)	  	  ua : Univalence	  ============================	   V -> V		(dependent evars:)		";
            responses[i]=data;
          

            i = 701;
            data = "1 subgoals, subgoal 1 (ID 414)	  	  ua : Univalence	  ============================	   V -> V		(dependent evars:)		";
            responses[i]=data;
          

            i = 702;
            data = "2 subgoals, subgoal 1 (ID 420)	  	  ua : Univalence	  ============================	   forall A : Type, (A -> V) -> (A -> V) -> V		subgoal 2 (ID 422) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g -> ?Goal0 A f H_f = ?Goal0 B g H_g	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 open,)		";
            responses[i]=data;
          

            i = 703;
            data = "2 subgoals, subgoal 1 (ID 426)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	   V		subgoal 2 (ID 422) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?Goal0@{f:=f0; A:=A0}) A f H_f =	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?Goal0@{f:=f0; A:=A0}) B g H_g	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 open,)		";
            responses[i]=data;
          

            i = 704;
            data = "1 subgoals, subgoal 1 (ID 422)	  	  ua : Univalence	  ============================	   forall (A B : Type) (f : A -> V) (g : B -> V),	   equal_img f g ->	   forall (H_f : A -> V) (H_g : B -> V),	   equal_img H_f H_g ->	   (fun (A0 : Type) (f0 _ : A0 -> V) =>	    set	      (fun x : A0 + Unit =>	       match x with	       | inl a => f0 a	       | inr tt => set f0	       end)) A f H_f =	   (fun (A0 : Type) (f0 _ : A0 -> V) =>	    set	      (fun x : A0 + Unit =>	       match x with	       | inl a => f0 a	       | inr tt => set f0	       end)) B g H_g		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 705;
            data = "1 subgoals, subgoal 1 (ID 440)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set	     (fun x : A + Unit => match x with	                          | inl a => f a	                          | inr tt => set f	                          end) =	   set	     (fun x : B + Unit => match x with	                          | inl a => g a	                          | inr tt => set g	                          end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 706;
            data = "1 subgoals, subgoal 1 (ID 443)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   equal_img	     (fun x : A + Unit => match x with	                          | inl a => f a	                          | inr tt => set f	                          end)	     (fun x : B + Unit => match x with	                          | inl a => g a	                          | inr tt => set g	                          end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 707;
            data = "2 subgoals, subgoal 1 (ID 445)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall a : A + Unit,	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		subgoal 2 (ID 446) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 708;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 445)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall a : A + Unit,	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 447)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A + Unit	  ============================	   hexists	     (fun b : B + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 709;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 452)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		subgoal 2 (ID 453) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 710;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 452)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 456)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   hexists (fun b : B => f a = g b) ->	   hexists	     (fun b : B + Unit =>	      f a = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 711;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 459)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	   {b : B & f a = g b} ->	   {b : B + Unit & f a = match b with	                         | inl a0 => g a0	                         | inr tt => set g	                         end}		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 712;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 464)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  b : B	  p : f a = g b	  ============================	   {b0 : B + Unit &	   f a = match b0 with	         | inl a0 => g a0	         | inr tt => set g	         end}		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 713;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 453)		subgoal 1 (ID 453) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	subgoal 2 (ID 446) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 714;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 453)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   hexists	     (fun b : B + Unit =>	      match u with	      | tt => set f	      end = match b with	            | inl a => g a	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 475)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   match u with	   | tt => set f	   end = set g		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 715;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 477)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 716;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 446)		subgoal 1 (ID 446) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 717;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 446)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   forall b : B + Unit,	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 481)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B + Unit	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match b with	            | inl a0 => g a0	            | inr tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 718;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		subgoal 2 (ID 487) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 719;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 490)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   hexists (fun a : A => f a = g b) ->	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = g b)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 720;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 493)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	   {a : A & f a = g b} ->	   {a : A + Unit & match a with	                   | inl a0 => f a0	                   | inr tt => set f	                   end = g b}		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 721;
            data = "1 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 498)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  a : A	  p : f a = g b	  ============================	   {a0 : A + Unit &	   match a0 with	   | inl a1 => f a1	   | inr tt => set f	   end = g b}		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 722;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 487)		subgoal 1 (ID 487) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 723;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 487)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   hexists	     (fun a : A + Unit =>	      match a with	      | inl a0 => f a0	      | inr tt => set f	      end = match u with	            | tt => set g	            end)		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 509)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	   set f = match u with	           | tt => set g	           end		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 724;
            data = "1 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 511)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	   set f = set g		(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 725;
            data = "No more subgoals.	(dependent evars: ?417 using ?419 , ?419 using ?420 , ?420 using ?423 , ?423 using ?424 , ?424 using ?425 , ?425 using ?426 , ?426 using ,)		";
            responses[i]=data;
          

            i = 726;
            data = "V_succ is defined	";
            responses[i]=data;
          

            i = 727;
            data = "";
            responses[i]=data;
          

            i = 728;
            data = "";
            responses[i]=data;
          

            i = 729;
            data = "";
            responses[i]=data;
          

            i = 730;
            data = "";
            responses[i]=data;
          

            i = 731;
            data = "V_omega is defined	";
            responses[i]=data;
          

            i = 732;
            data = "";
            responses[i]=data;
          

            i = 733;
            data = "";
            responses[i]=data;
          

            i = 734;
            data = "";
            responses[i]=data;
          

            i = 735;
            data = "";
            responses[i]=data;
          

            i = 736;
            data = "";
            responses[i]=data;
          

            i = 737;
            data = "";
            responses[i]=data;
          

            i = 738;
            data = "";
            responses[i]=data;
          

            i = 739;
            data = "1 subgoals, subgoal 1 (ID 420)	  	  ua : Univalence	  ============================	   forall x : V, ~ x ∈ V_empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 740;
            data = "1 subgoals, subgoal 1 (ID 420)	  	  ua : Univalence	  ============================	   forall x : V, ~ x ∈ V_empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 741;
            data = "1 subgoals, subgoal 1 (ID 423)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 742;
            data = "1 subgoals, subgoal 1 (ID 429)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	   {a : Empty & Empty_rect (fun _ : Empty => V) a = x} -> Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 743;
            data = "1 subgoals, subgoal 1 (ID 435)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ff : Empty	  ============================	   Empty		(dependent evars:)		";
            responses[i]=data;
          

            i = 744;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 745;
            data = "not_mem_Vempty is defined	";
            responses[i]=data;
          

            i = 746;
            data = "1 subgoals, subgoal 1 (ID 427)	  	  ua : Univalence	  ============================	   forall u v : V,	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 747;
            data = "1 subgoals, subgoal 1 (ID 427)	  	  ua : Univalence	  ============================	   forall u v : V,	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 748;
            data = "1 subgoals, subgoal 1 (ID 429)	  	  ua : Univalence	  u : V	  v : V	  ============================	   hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 749;
            data = "1 subgoals, subgoal 1 (ID 432)	  	  ua : Univalence	  u : V	  v : V	  ============================	   {w : V & forall x : V, x ∈ w <-> hor (x = u) (x = v)}		(dependent evars:)		";
            responses[i]=data;
          

            i = 750;
            data = "1 subgoals, subgoal 1 (ID 434)	  	  ua : Univalence	  u : V	  v : V	  ============================	   forall x : V, x ∈ V_pair u v <-> hor (x = u) (x = v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 751;
            data = "2 subgoals, subgoal 1 (ID 441)	  	  ua : Univalence	  u : V	  v : V	  x : V	  ============================	   {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		subgoal 2 (ID 444) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars:)		";
            responses[i]=data;
          

            i = 752;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 441)	  	  ua : Univalence	  u : V	  v : V	  x : V	  ============================	   {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		(dependent evars:)		<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 444)		subgoal 1 (ID 444) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars:)		";
            responses[i]=data;
          

            i = 753;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 444)	  	  ua : Univalence	  u : V	  v : V	  x : V	  ============================	   (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}		(dependent evars:)		No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 754;
            data = "pairing is defined	";
            responses[i]=data;
          

            i = 755;
            data = "1 subgoals, subgoal 1 (ID 429)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars:)		";
            responses[i]=data;
          

            i = 756;
            data = "1 subgoals, subgoal 1 (ID 429)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars:)		";
            responses[i]=data;
          

            i = 757;
            data = "2 subgoals, subgoal 1 (ID 431)	  	  ua : Univalence	  ============================	   V_empty ∈ V_omega		subgoal 2 (ID 432) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	(dependent evars:)		";
            responses[i]=data;
          

            i = 758;
            data = "1 subgoals, subgoal 1 (ID 432)	  	  ua : Univalence	  ============================	   forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars:)		";
            responses[i]=data;
          

            i = 759;
            data = "1 subgoals, subgoal 1 (ID 438)	  	  ua : Univalence	  x : V	  ============================	   x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars:)		";
            responses[i]=data;
          

            i = 760;
            data = "1 subgoals, subgoal 1 (ID 441)	  	  ua : Univalence	  x : V	  ============================	   {a : nat &	   (fix I (n : nat) : V :=	      match n with	      | 0 => V_empty	      | n0.+1 => V_succ (I n0)	      end) a = x} ->	   {a : nat &	   (fix I (n : nat) : V :=	      match n with	      | 0 => V_empty	      | n0.+1 => V_succ (I n0)	      end) a = V_succ x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 761;
            data = "1 subgoals, subgoal 1 (ID 446)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n0 : nat) : V :=	         match n0 with	         | 0 => V_empty	         | n1.+1 => V_succ (I n1)	         end) n = x	  ============================	   {a : nat &	   (fix I (n0 : nat) : V :=	      match n0 with	      | 0 => V_empty	      | n1.+1 => V_succ (I n1)	      end) a = V_succ x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 762;
            data = "1 subgoals, subgoal 1 (ID 448)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n0 : nat) : V :=	         match n0 with	         | 0 => V_empty	         | n1.+1 => V_succ (I n1)	         end) n = x	  ============================	   V_succ	     ((fix I (n0 : nat) : V :=	         match n0 with	         | 0 => V_empty	         | n1.+1 => V_succ (I n1)	         end) n) = V_succ x		(dependent evars:)		";
            responses[i]=data;
          

            i = 763;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 764;
            data = "infinity is defined	";
            responses[i]=data;
          

            i = 765;
            data = "1 subgoals, subgoal 1 (ID 434)	  	  ua : Univalence	  ============================	   forall v : V,	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 766;
            data = "1 subgoals, subgoal 1 (ID 434)	  	  ua : Univalence	  ============================	   forall v : V,	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 767;
            data = "1 subgoals, subgoal 1 (ID 435)	  	  ua : Univalence	  v : V	  ============================	   hexists	     (fun w : V =>	      forall x : V, x ∈ w <-> hexists (fun u : V => x ∈ u * u ∈ v))		(dependent evars:)		";
            responses[i]=data;
          

            i = 768;
            data = "1 subgoals, subgoal 1 (ID 440)	  	  ua : Univalence	  v : V	  ============================	   forall x : V, x ∈ V_union v <-> hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 769;
            data = "2 subgoals, subgoal 1 (ID 443)	  	  ua : Univalence	  v : V	  x : V	  ============================	   x ∈ V_union v -> hexists (fun u : V => x ∈ u * u ∈ v)		subgoal 2 (ID 444) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 770;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 443)	  	  ua : Univalence	  v : V	  x : V	  ============================	   x ∈ V_union v -> hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		1 focused subgoals	(unfocused: 1), subgoal 1 (ID 445)	  	  ua : Univalence	  v : V	  x : V	  H : x ∈ V_union v	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 771;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 447)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v)		(dependent evars:)		";
            responses[i]=data;
          

            i = 772;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 451)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  ============================	   {a : {x0 : [v] & [func_of_members x0]} & func_of_members a.2 = x} ->	   {u : V & x ∈ u * u ∈ v}		(dependent evars:)		";
            responses[i]=data;
          

            i = 773;
            data = "1 focused subgoals	(unfocused: 1), subgoal 1 (ID 461)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   {u : V & x ∈ u * u ∈ v}		(dependent evars:)		";
            responses[i]=data;
          

            i = 774;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 466)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ func_of_members u'		subgoal 2 (ID 467) is:	 func_of_members u' ∈ v	(dependent evars:)		";
            responses[i]=data;
          

            i = 775;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 466)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ func_of_members u'		(dependent evars:)		1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 483)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   x ∈ set func_of_members		(dependent evars:)		";
            responses[i]=data;
          

            i = 776;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 485)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   hexists (fun a : [func_of_members u'] => func_of_members a = x)		(dependent evars:)		";
            responses[i]=data;
          

            i = 777;
            data = "1 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 490)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members x' = x		(dependent evars:)		";
            responses[i]=data;
          

            i = 778;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		2 subgoals, subgoal 1 (ID 467)		subgoal 1 (ID 467) is:	 func_of_members u' ∈ v	subgoal 2 (ID 444) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 779;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 467)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members u' ∈ v		(dependent evars:)		1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 506)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   func_of_members u' ∈ set func_of_members		(dependent evars:)		";
            responses[i]=data;
          

            i = 780;
            data = "1 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 508)	  	  ua : Univalence	  v : V	  x : V	  H : hexists	        (fun a : {x0 : [v] & [func_of_members x0]} => func_of_members a.2 = x)	  u' : [v]	  x' : [func_of_members u']	  p : func_of_members x' = x	  ============================	   hexists (fun a : [v] => func_of_members a = func_of_members u')		(dependent evars:)		";
            responses[i]=data;
          

            i = 781;
            data = "<infomsg>This subproof is complete, but there are still unfocused goals.</infomsg>		1 subgoals, subgoal 1 (ID 444)		subgoal 1 (ID 444) is:	 hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v	(dependent evars:)		";
            responses[i]=data;
          

            i = 782;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 444)	  	  ua : Univalence	  v : V	  x : V	  ============================	   hexists (fun u : V => x ∈ u * u ∈ v) -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 783;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 519)	  	  ua : Univalence	  v : V	  x : V	  ============================	   {u : V & x ∈ u * u ∈ v} -> x ∈ V_union v		(dependent evars:)		1 focused subgoals	(unfocused: 0), subgoal 1 (ID 528)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 784;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 532)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   u ∈ set func_of_members -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 785;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 537)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  ============================	   {a : [v] & func_of_members a = u} -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 786;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 542)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 787;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 553)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   x ∈ set func_of_members -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 788;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 558)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  ============================	   {a : [func_of_members u'] & func_of_members a = x} -> x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 789;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 563)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   x ∈ V_union v		(dependent evars:)		";
            responses[i]=data;
          

            i = 790;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 566)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   {a : {x0 : [v] & [func_of_members x0]} & func_of_members a.2 = x}		(dependent evars:)		";
            responses[i]=data;
          

            i = 791;
            data = "1 focused subgoals	(unfocused: 0), subgoal 1 (ID 570)	  	  ua : Univalence	  v : V	  x : V	  u : V	  Hx : x ∈ u	  Hu : u ∈ v	  u' : [v]	  pu : func_of_members u' = u	  x' : [func_of_members u']	  px : func_of_members x' = x	  ============================	   func_of_members (u'; x').2 = x		(dependent evars:)		";
            responses[i]=data;
          

            i = 792;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 793;
            data = "union is defined	";
            responses[i]=data;
          

            i = 794;
            data = "Toplevel input, characters 69-78:	> Lemma function : forall u v, hexists (fun w => forall x, x ∈ w <-> V_is_func u v x).	>                                                                    ^^^^^^^^^	Error: The reference V_is_func was not found in the current environment.	";
            responses[i]=data;
          

            i = 795;
            data = "Toplevel input, characters 0-6:	> Proof.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 796;
            data = "Toplevel input, characters 3-14:	>   intros u v.	>   ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 797;
            data = "Toplevel input, characters 15-45:	> apply tr; exists (V_func u v).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 798;
            data = "Toplevel input, characters 3-85:	>   assert (memb_u : u = set (@func_of_members u)) by exact (is_valid_presentation u).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 799;
            data = "Toplevel input, characters 3-85:	>   assert (memb_v : v = set (@func_of_members v)) by exact (is_valid_presentation v).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 800;
            data = "Toplevel input, characters 3-20:	>   intro phi; split.	>   ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 801;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-12:	>   - intro H.	>     ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 802;
            data = "Toplevel input, characters 14-20:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 803;
            data = "Toplevel input, characters 8-14:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 804;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 805;
            data = "Toplevel input, characters 20-31:	> simpl in *.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 806;
            data = "Toplevel input, characters 0-13:	> generalize H.	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 807;
            data = "Toplevel input, characters 15-39:	> apply Trunc_rect_nondep.	> ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 808;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 809;
            data = "Toplevel input, characters 0-52:	> generalize (transport (fun x => z ∈ x) p_phi^ Hz).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 810;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 811;
            data = "Toplevel input, characters 7-20:	>       intros [a p].	>       ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 812;
            data = "Toplevel input, characters 0-16:	> exists (a, h a).	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 813;
            data = "Toplevel input, characters 18-29:	> assumption.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 814;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros x Hx.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 815;
            data = "Toplevel input, characters 20-72:	> generalize (transport (fun y => x ∈ y) memb_u Hx).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 816;
            data = "Toplevel input, characters 7-31:	>       apply Trunc_rect_nondep.	>       ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 817;
            data = "Toplevel input, characters 32-45:	> intros [a p].	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 818;
            data = "Toplevel input, characters 0-39:	> generalize H; apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 819;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 820;
            data = "Toplevel input, characters 0-31:	> exists (func_of_members (h a)).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 821;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 822;
            data = "Toplevel input, characters 7-86:	>       exact (transport (fun z => func_of_members (h a) ∈ z) memb_v^ (tr (h a; 1))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 823;
            data = "Toplevel input, characters 7-75:	>       apply (transport (fun y => [x, func_of_members (h a)] ∈ y) p_phi).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 824;
            data = "Toplevel input, characters 7-26:	>       apply tr; exists a.	>       ^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 825;
            data = "Toplevel input, characters 27-50:	> rewrite p; reflexivity.	> ^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 826;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-30:	>     + intros x y y' (Hy, Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 827;
            data = "Toplevel input, characters 0-38:	> generalize H; apply Trunc_rect_nondep.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 828;
            data = "Toplevel input, characters 40-57:	> intros [h p_phi].	> ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 829;
            data = "Toplevel input, characters 7-64:	>       generalize (transport (fun z => [x, y] ∈ z) p_phi^ Hy).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 830;
            data = "Toplevel input, characters 0-24:	> apply Trunc_rect_nondep.	> ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 831;
            data = "Toplevel input, characters 26-39:	> intros [a p].	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 832;
            data = "Toplevel input, characters 7-66:	>       generalize (transport (fun z => [x, y'] ∈ z) p_phi^ Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 833;
            data = "Toplevel input, characters 0-24:	> apply Trunc_rect_nondep.	> ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 834;
            data = "Toplevel input, characters 26-41:	> intros [a' p'].	> ^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 835;
            data = "Toplevel input, characters 7-50:	>       destruct (fst path_pair_ord p) as (px, py).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 836;
            data = "Toplevel input, characters 0-46:	> destruct (fst path_pair_ord p') as (px', py').	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 837;
            data = "Toplevel input, characters 7-66:	>       transitivity (func_of_members (h a)); auto with path_hints.	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 838;
            data = "Toplevel input, characters 67-126:	> transitivity (func_of_members (h a'));auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 839;
            data = "Toplevel input, characters 7-37:	>       refine (ap func_of_members _).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 840;
            data = "Toplevel input, characters 0-16:	> refine (ap h _).	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 841;
            data = "Toplevel input, characters 7-90:	>       apply (isinj_embedding func_of_members IsEmbedding_funcofmembers a a' (px @ px'^)).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 842;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-26:	>   - intros ((H1, H2), H3).	>     ^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 843;
            data = "Toplevel input, characters 0-6:	> simpl.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 844;
            data = "Toplevel input, characters 5-93:	>     assert (h : forall a : [u], {b : [v] & [func_of_members a, func_of_members b] ∈ phi}).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 845;
            data = "Toplevel input, characters 5-6:	>     {	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-14:	>     { intro a.	>       ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 846;
            data = "Toplevel input, characters 16-46:	> pose (x := func_of_members a).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 847;
            data = "Toplevel input, characters 7-67:	>       transparent assert (H : {y : V & y ∈ v * [x, y] ∈ phi}).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 848;
            data = "Toplevel input, characters 7-164:	> ..... refine (@untrunc_istrunc -1 {y : V & y ∈ v * [x, y] ∈ phi} _	>                                  (H2 x (transport (fun z => x ∈ z) memb_u^ (tr (a; 1))))). 	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 849;
            data = "Toplevel input, characters 7-8:	>       {	>       ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 8-28:	>       { apply hprop_allpath.	>         ^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 850;
            data = "Toplevel input, characters 30-74:	> intros [y (H1_y, H2_y)] [y' (H1_y', H2_y')].	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 851;
            data = "Toplevel input, characters 9-43:	>         apply path_sigma_uncurried; simpl.	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 852;
            data = "Toplevel input, characters 9-42:	>         exists (H3 x y y' (H2_y, H2_y')).	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 853;
            data = "Toplevel input, characters 9-28:	>         apply path_ishprop.	>         ^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	Toplevel input, characters 28-29:	>         apply path_ishprop. }	>                             ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-37:	>       destruct H as [y (H1_y, H2_y)].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 854;
            data = "Toplevel input, characters 7-123:	>       destruct (@untrunc_istrunc -1 _ (IsEmbedding_funcofmembers y) (transport (fun z => y ∈ z) memb_v H1_y)) as [b Hb].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 855;
            data = "Toplevel input, characters 7-16:	>       exists b.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 856;
            data = "Toplevel input, characters 17-70:	> exact (transport (fun z => [x, z] ∈ phi) Hb^ H2_y).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 857;
            data = "Toplevel input, characters 1-2:	>  }	>  ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-42:	>     apply tr; exists (fun a => pr1 (h a)).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 858;
            data = "Toplevel input, characters 0-21:	> apply extensionality.	> ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 859;
            data = "Toplevel input, characters 23-29:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 860;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 861;
            data = "Toplevel input, characters 20-59:	> generalize Hz; apply Trunc_rect_nondep.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 862;
            data = "Toplevel input, characters 41-55:	> intros [a Ha].	> ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 863;
            data = "Toplevel input, characters 7-61:	>       exact (transport (fun w => w ∈ phi) Ha (pr2 (h a))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 864;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 865;
            data = "Toplevel input, characters 20-26:	> simpl.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 866;
            data = "Toplevel input, characters 7-28:	>       generalize (H1 z Hz).	>       ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 867;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 868;
            data = "Toplevel input, characters 0-17:	> intros [(a,b) p].	> ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 869;
            data = "Toplevel input, characters 0-11:	> simpl in p.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 870;
            data = "Toplevel input, characters 7-16:	>       exists a.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 871;
            data = "Toplevel input, characters 17-93:	> transitivity ([func_of_members a, func_of_members b]); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 872;
            data = "Toplevel input, characters 7-16:	>       apply ap.	>       ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 873;
            data = "Toplevel input, characters 7-41:	>       apply H3 with (func_of_members a).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 874;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 875;
            data = "Toplevel input, characters 7-25:	>       exact (pr2 (h a)).	>       ^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 876;
            data = "Toplevel input, characters 7-52:	>       exact (transport (fun w => w ∈ phi) p^ Hz).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 877;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 878;
            data = "Toplevel input, characters 84-85:	>   hexists (fun w => forall y, y ∈ w <-> hexists (fun z => z ∈ x * (r z = y))).	>                                  ^	Syntax Error: Lexer: Undefined token	";
            responses[i]=data;
          

            i = 879;
            data = "Toplevel input, characters 0-6:	> Proof.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 880;
            data = "Toplevel input, characters 3-11:	>   intro r.	>   ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 881;
            data = "Toplevel input, characters 12-40:	> refine (V_rect_hprop _ _ _).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 882;
            data = "Toplevel input, characters 3-16:	>   intros A f _.	>   ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 883;
            data = "Toplevel input, characters 17-26:	> apply tr.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 884;
            data = "Toplevel input, characters 11-32:	> exists (set (r o f)).	> ^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 885;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 886;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-29:	>   - apply (Trunc_functor -1).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 887;
            data = "Toplevel input, characters 5-18:	>     intros [a p].	>     ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 888;
            data = "Toplevel input, characters 0-13:	> exists (f a).	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 889;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 890;
            data = "Toplevel input, characters 8-33:	> apply tr; exists a; auto.	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 891;
            data = "Toplevel input, characters 27-38:	> assumption.	> ^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 892;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-28:	>   - apply Trunc_rect_nondep.	>     ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 893;
            data = "Toplevel input, characters 5-22:	>     intros [z [h p]].	>     ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 894;
            data = "Toplevel input, characters 0-13:	> generalize h.	> ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 895;
            data = "Toplevel input, characters 15-40:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 896;
            data = "Toplevel input, characters 5-19:	>     intros [a p'].	>     ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 897;
            data = "Toplevel input, characters 0-9:	> exists a.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 898;
            data = "Toplevel input, characters 11-52:	> transitivity (r z); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 899;
            data = "Toplevel input, characters 43-59:	> exact (ap r p').	> ^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 900;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 901;
            data = "Toplevel input, characters 85-86:	>   hexists (fun w => forall x, x ∈ w <-> x ∈ a * (C x)).	>                                  ^	Syntax Error: Lexer: Undefined token	";
            responses[i]=data;
          

            i = 902;
            data = "Toplevel input, characters 0-6:	> Proof.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 903;
            data = "Toplevel input, characters 3-31:	>   refine (V_rect_hprop _ _ _).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 904;
            data = "Toplevel input, characters 3-16:	>   intros A f _.	>   ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 905;
            data = "Toplevel input, characters 17-26:	> apply tr.	> ^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 906;
            data = "Toplevel input, characters 11-65:	> exists (set (fun z : {a : A & C (f a)} => f (pr1 z))).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 907;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 908;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-28:	>   - apply Trunc_rect_nondep.	>     ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 909;
            data = "Toplevel input, characters 5-22:	>     intros [[a h] p].	>     ^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 910;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 911;
            data = "Toplevel input, characters 8-39:	> apply tr; exists a; assumption.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 912;
            data = "Toplevel input, characters 33-57:	> exact (transport C p h).	> ^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 913;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-19:	>   - intros [H1 H2].	>     ^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 914;
            data = "Toplevel input, characters 0-14:	> generalize H1.	> ^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 915;
            data = "Toplevel input, characters 16-41:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 916;
            data = "Toplevel input, characters 5-18:	>     intros [a p].	>     ^^^^^^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 917;
            data = "Toplevel input, characters 9-10:	> exists (a; transport C p^ H2).	>          ^	Syntax error: ',' or ')' expected after [constr:operconstr level 200] (in [constr:operconstr]).	";
            responses[i]=data;
          

            i = 918;
            data = "Toplevel input, characters 32-40:	> exact p.	> ^^^^^^^^	Error: Unknown command of the non proof-editing mode.	";
            responses[i]=data;
          

            i = 919;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 920;
            data = "Toplevel input, characters 0-15:	> End AssumingUA.	> ^^^^^^^^^^^^^^^	Error: There is nothing to end.	";
            responses[i]=data;
          

            i = 921;
            data = "";
            responses[i]=data;
          

            i = 922;
            data = "";
            responses[i]=data;
          

            i = 923;
            data = "";
            responses[i]=data;
          

            i = 924;
            data = "";
            responses[i]=data;
          

            i = 925;
            data = "";
            responses[i]=data;
          

            i = 926;
            data = "";
            responses[i]=data;
          

            i = 927;
            data = "";
            responses[i]=data;
          

            i = 928;
            data = "";
            responses[i]=data;
          

            i = 929;
            data = "";
            responses[i]=data;
          

            i = 930;
            data = "";
            responses[i]=data;
          

            i = 931;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.hit.V</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<br>
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab189"></a><h1 class="section">The cumulative hierarchy <span class="inlinecode"><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a></span>.</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      ">
<br>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" type="library">HoTT.Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.types.Unit.html#"><span class="id" type="library">types.Unit</span></a> <a class="idref" href="HoTT.types.Bool.html#"><span class="id" type="library">types.Bool</span></a> <a class="idref" href="HoTT.types.Universe.html#"><span class="id" type="library">types.Universe</span></a> <a class="idref" href="HoTT.types.Sigma.html#"><span class="id" type="library">types.Sigma</span></a> <a class="idref" href="HoTT.types.Arrow.html#"><span class="id" type="library">types.Arrow</span></a> <a class="idref" href="HoTT.types.Forall.html#"><span class="id" type="library">types.Forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" type="library">HProp</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" type="library">HSet</span></a> <a class="idref" href="HoTT.EquivalenceVarieties.html#"><span class="id" type="library">EquivalenceVarieties</span></a> <a class="idref" href="HoTT.UnivalenceImpliesFunext.html#"><span class="id" type="library">UnivalenceImpliesFunext</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.hit.Truncations.html#"><span class="id" type="library">hit.Truncations</span></a> <a class="idref" href="HoTT.hit.quotient.html#"><span class="id" type="library">hit.quotient</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" type="keyword">Local</span> <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" type="keyword">Local</span> <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">equiv_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
<a name="lab190"></a><h2 class="section">Pushout with respect to a relation</h2>
<div class="doc" scenenumber="4"> </div>

 This could be implemented using the pushouts in /hit/Pushout.v, where <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.f"><span class="id" type="variable">f</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.g"><span class="id" type="variable">g</span></a></span> are <span class="inlinecode">(<a class="idref" href="HoTT.categories.Functor.Prod.Core.html#fst"><span class="id" type="definition">fst</span></a></span> <span class="inlinecode"><span class="id" type="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.ToCat.html#pr1"><span class="id" type="definition">pr1</span></a>)</span> and <span class="inlinecode">(<a class="idref" href="HoTT.categories.Functor.Prod.Core.html#snd"><span class="id" type="definition">snd</span></a></span> <span class="inlinecode"><span class="id" type="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Grothendieck.ToCat.html#pr1"><span class="id" type="definition">pr1</span></a>)</span>, with domain {(a,b) : A * B &amp; R a b}. However, these pushouts weren't implemented when I started this work, and doing it this way is closer to exercise 10.11 of the HoTT book 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      ">
<br>
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Export</span> <a name="RPushout"><span class="id" type="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<br>
<span class="id" type="var">Private</span> <span class="id" type="keyword">Inductive</span> <a name="RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) : <span class="id" type="keyword">Type</span> :=<br>
| <a name="RPushout.inL"><span class="id" type="constructor">inL</span></a> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout"><span class="id" type="inductive">RPushout</span></a> <span class="id" type="var">R</span><br>
| <a name="RPushout.inR"><span class="id" type="constructor">inR</span></a> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout"><span class="id" type="inductive">RPushout</span></a> <span class="id" type="var">R</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<br>
<span class="id" type="keyword">Axiom</span> <a name="RPushout.glue"><span class="id" type="axiom">glue</span></a> : <span class="id" type="keyword">∀</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>)<br>
  (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="RPushout.RPushout_rect"><span class="id" type="definition">RPushout_rect</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>}<br>
  (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">i</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)) (<span class="id" type="var">j</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<br>
  (<span class="id" type="var">gl</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>)<br>
: <span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><br>
:= <span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ (<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">a</span> ⇒ (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">a</span>)<br>
                        | <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <span class="id" type="var">b</span> ⇒ (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <span class="id" type="var">b</span>) <span class="id" type="keyword">end</span>) <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
<br>
<span class="id" type="keyword">Axiom</span> <a name="RPushout.RPushout_comp_glue"><span class="id" type="axiom">RPushout_comp_glue</span></a> : <span class="id" type="keyword">∀</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} {<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>}<br>
  (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">i</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)) (<span class="id" type="var">j</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<br>
  (<span class="id" type="var">gl</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>)<br>
  (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>),<br>
<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" type="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_rect"><span class="id" type="definition">RPushout_rect</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
<br>
<span class="id" type="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#"><span class="id" type="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The non-depentent eliminator 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(54, '0_3_15');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="RPushout_rect_nd"><span class="id" type="definition">RPushout_rect_nd</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>)<br>
  (<span class="id" type="var">P</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">i</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>) (<span class="id" type="var">j</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">gl</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_rect"><span class="id" type="definition">RPushout_rect</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>) <a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" type="definition">transport_const</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(55, '0_3_15');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="RPushout_comp_nd_glue"><span class="id" type="definition">RPushout_comp_nd_glue</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>)<br>
  (<span class="id" type="var">P</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">i</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>) (<span class="id" type="var">j</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">gl</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>), <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>)<br>
  (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rect_nd"><span class="id" type="definition">RPushout_rect_nd</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="HoTT.hit.V.html#j"><span class="id" type="variable">j</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#gl"><span class="id" type="variable">gl</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(56, '0_3_15');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(57, '0_3_15');
      "><br>
  <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" type="lemma">cancelL</span></a> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" type="definition">transport_const</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">r</span>) (<span class="id" type="var">i</span> <span class="id" type="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(58, '0_3_15');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" type="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rect_nd"><span class="id" type="definition">RPushout_rect_nd</span></a> <span class="id" type="var">R</span> <span class="id" type="var">P</span> <span class="id" type="var">i</span> <span class="id" type="var">j</span> <span class="id" type="var">gl</span>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" type="lemma">apD_const</span></a> (<a class="idref" href="HoTT.hit.V.html#RPushout_rect_nd"><span class="id" type="definition">RPushout_rect_nd</span></a> <span class="id" type="var">R</span> <span class="id" type="var">P</span> <span class="id" type="var">i</span> <span class="id" type="var">j</span> <span class="id" type="var">gl</span>) (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">r</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(60, '0_3_15');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.RPushout_comp_glue"><span class="id" type="axiom">RPushout_comp_glue</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <span class="id" type="var">P</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(61, '0_3_15');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(62, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Bitotal relation 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(66, '0_3_19');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="bitotal"><span class="id" type="definition">bitotal</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(67, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
<a name="lab191"></a><h2 class="section">The cumulative hierarchy V</h2>
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(74, '0_3_23');
      ">
<br>
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Export</span> <a name="CumulativeHierarchy"><span class="id" type="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(75, '0_3_23');
      "><br>
<br>
<span class="id" type="var">Private</span> <span class="id" type="keyword">Inductive</span> <a name="CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> : <span class="id" type="var">Type@</span>{<span class="id" type="var">U'</span>} :=<br>
| <a name="CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> {<span class="id" type="var">A</span> : <span class="id" type="var">Type@</span>{<span class="id" type="var">U</span>}} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#V"><span class="id" type="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(76, '0_3_23');
      "><br>
<br>
<span class="id" type="keyword">Axiom</span> <a name="CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> : <span class="id" type="keyword">∀</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>)<br>
  (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>),<br>
<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(77, '0_3_23');
      "><br>
<br>
<span class="id" type="keyword">Axiom</span> <a name="CumulativeHierarchy.is0trunc_V"><span class="id" type="axiom">is0trunc_V</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(78, '0_3_23');
      "><br>
<br>
<span class="id" type="keyword">Fixpoint</span> <a name="CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>))<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a>))<br>
  (<span class="id" type="var">H_setext</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<br>
    (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_h</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>)),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) )<br>
  (<span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a><br>
:= (<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">with</span><br>
     | <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <span class="id" type="var">A</span> <span class="id" type="var">f</span> ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <span class="id" type="var">A</span> <span class="id" type="var">f</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="HoTT.hit.V.html#V_rect"><span class="id" type="definition">V_rect</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a> (<span class="id" type="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>))<br>
    <span class="id" type="keyword">end</span>) <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(79, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncation 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      ">
<br>
<span class="id" type="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#"><span class="id" type="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="V_comp_setext"><span class="id" type="definition">V_comp_setext</span></a> (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>))<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a>))<br>
  (<span class="id" type="var">H_setext</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<br>
    (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_h</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>)),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) )<br>
  (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" type="definition">apD</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a>) (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The non-dependent eliminator 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(92, '0_3_31');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="V_rect_nd"><span class="id" type="definition">V_rect_nd</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_setext</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<br>
    (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>),<br>
    <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) )<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(93, '0_3_31');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(94, '0_3_31');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H_set</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(95, '0_3_31');
      "><br>
  <span class="id" type="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(96, '0_3_31');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" type="definition">transport_const</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">H_setext</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">R</span> <span class="id" type="var">bitot_R</span> <span class="id" type="var">h</span> <span class="id" type="var">H_h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(97, '0_3_31');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(98, '0_3_31');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="V_comp_nd_setext"><span class="id" type="definition">V_comp_nd_setext</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_setext</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>)<br>
    (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>),<br>
    <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> (<a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<a class="idref" href="HoTT.hit.V.html#H_h"><span class="id" type="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) )<br>
  (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">R</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) (<span class="id" type="var">bitot_R</span> : <a class="idref" href="HoTT.hit.V.html#bitotal"><span class="id" type="definition">bitotal</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a>) (<span class="id" type="var">h</span> : <a class="idref" href="HoTT.hit.V.html#RPushout.RPushout"><span class="id" type="inductive">RPushout</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<a class="idref" href="HoTT.hit.V.html#V_rect_nd"><span class="id" type="definition">V_rect_nd</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a>) (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="HoTT.hit.V.html#bitot_R"><span class="id" type="variable">bitot_R</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#V_rect_nd"><span class="id" type="definition">V_rect_nd</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#H_0trunc"><span class="id" type="variable">H_0trunc</span></a> <a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#H_setext"><span class="id" type="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#h"><span class="id" type="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(99, '0_3_31');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(100, '0_3_31');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(101, '0_3_31');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(102, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
<a name="lab192"></a><h2 class="section">Alternative induction principle (This is close to the one from the book)</h2>
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="equal_img"><span class="id" type="definition">equal_img</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a>) (<span class="id" type="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="setext'"><span class="id" type="definition">setext'</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">eq_img</span> : <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a>)<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">R</span> := <span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> ⇒ <a class="idref" href="HoTT.HProp.html#hp"><span class="id" type="constructor">hp</span></a> (<span class="id" type="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">g</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>) <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">h</span> := <a class="idref" href="HoTT.hit.V.html#RPushout_rect_nd"><span class="id" type="definition">RPushout_rect_nd</span></a> <span class="id" type="var">R</span> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <span class="id" type="var">f</span> <span class="id" type="var">g</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span> ⇒ <a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.setext"><span class="id" type="axiom">setext</span></a> <span class="id" type="var">R</span> <span class="id" type="var">eq_img</span> <span class="id" type="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="V_rect'_nd"><span class="id" type="definition">V_rect'_nd</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>), <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>)<br>
  (<span class="id" type="var">H_setext'</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>), <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a><br>
    <span class="id" type="keyword">∀</span> (<span class="id" type="var">H_f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>) (<span class="id" type="var">H_g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>), <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" type="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" type="variable">H_g</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" type="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" type="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> )<br>
: <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(117, '0_3_35');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(118, '0_3_35');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_nd"><span class="id" type="definition">V_rect_nd</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H_set</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(119, '0_3_35');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">R</span> <span class="id" type="var">bitot_R</span> <span class="id" type="var">h</span> <span class="id" type="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(120, '0_3_35');
      "><br>
  <span class="id" type="tactic">apply</span> <span class="id" type="var">H_setext'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(121, '0_3_35');
      "><br>
  - <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(122, '0_3_35');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(123, '0_3_35');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(124, '0_3_35');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(125, '0_3_35');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(126, '0_3_35');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(127, '0_3_35');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(128, '0_3_35');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(129, '0_3_35');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(130, '0_3_35');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(131, '0_3_35');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(132, '0_3_35');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(133, '0_3_35');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(134, '0_3_35');
      "><br>
  - <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(135, '0_3_35');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(136, '0_3_35');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(137, '0_3_35');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(138, '0_3_35');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(139, '0_3_35');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(140, '0_3_35');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(141, '0_3_35');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(142, '0_3_35');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(143, '0_3_35');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(144, '0_3_35');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(145, '0_3_35');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(146, '0_3_35');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(147, '0_3_35');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(148, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(152, '0_3_39');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_rect'"><span class="id" type="definition">V_rect'</span></a> (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_0trunc</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" type="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>))<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a>))<br>
  (<span class="id" type="var">H_setext'</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)<br>
    (<span class="id" type="var">eq_img</span>: <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a>)<br>
    (<span class="id" type="var">H_f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)) (<span class="id" type="var">H_g</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<br>
    (<span class="id" type="var">H_eqimg</span> : <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">p</span>:<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" type="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" type="variable">H_g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
             <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">p</span>:<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.hit.V.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" type="variable">H_f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" type="variable">H_g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> ),<br>
    <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img"><span class="id" type="variable">eq_img</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#H_f"><span class="id" type="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#H_set"><span class="id" type="variable">H_set</span></a> <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#H_g"><span class="id" type="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a><br>
  )<br>
: <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(153, '0_3_39');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(154, '0_3_39');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">H_set</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(155, '0_3_39');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">R</span> <span class="id" type="var">bitot_R</span> <span class="id" type="var">h</span> <span class="id" type="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(156, '0_3_39');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">f</span> := <span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(157, '0_3_39');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">g</span> := <span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <span class="id" type="var">R</span> : <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(158, '0_3_39');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">H_f</span> := <span class="id" type="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <span class="id" type="var">A</span>, <span class="id" type="var">P</span> (<span class="id" type="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(159, '0_3_39');
      "><br>
  <span class="id" type="tactic">pose</span> (<span class="id" type="var">H_g</span> := <span class="id" type="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <span class="id" type="var">R</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <span class="id" type="var">B</span>, <span class="id" type="var">P</span> (<span class="id" type="var">g</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(160, '0_3_39');
      "><br>
  <span class="id" type="tactic">assert</span> (<span class="id" type="var">eq_img</span> : <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <span class="id" type="var">f</span> <span class="id" type="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(161, '0_3_39');
      "><br>
  { <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(162, '0_3_39');
      "><br>
    - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(163, '0_3_39');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(164, '0_3_39');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(165, '0_3_39');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(166, '0_3_39');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(167, '0_3_39');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(168, '0_3_39');
      "><br>
    - <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(169, '0_3_39');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(170, '0_3_39');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(171, '0_3_39');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(172, '0_3_39');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(173, '0_3_39');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(174, '0_3_39');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">P</span> (<a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a> (<span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span>) (<span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inR"><span class="id" type="constructor">inR</span></a> <span class="id" type="var">R</span>) <span class="id" type="var">eq_img</span>)<br>
      (<span class="id" type="var">H_set</span> <span class="id" type="var">A</span> (<span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span>) (<span class="id" type="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(175, '0_3_39');
      "><br>
  { <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">P</span> <a class="idref" href="HoTT.hit.V.html#p"><span class="id" type="variable">p</span></a> (<span class="id" type="var">H_set</span> <span class="id" type="var">A</span> (<span class="id" type="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span>) (<span class="id" type="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'oD'_x"><span class="id" type="notation">oD</span></a> <a class="idref" href="HoTT.hit.V.html#RPushout.inL"><span class="id" type="constructor">inL</span></a> <span class="id" type="var">R</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(176, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a>. }<br>
  <span class="id" type="tactic">apply</span> (<span class="id" type="var">H_setext'</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">eq_img</span> <span class="id" type="var">H_f</span> <span class="id" type="var">H_g</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(177, '0_3_39');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(178, '0_3_39');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(179, '0_3_39');
      "><br>
    <span class="id" type="tactic">set</span> (<span class="id" type="var">truncb</span> := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">truncb</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
    <span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" type="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" type="definition">apD</span></a> <span class="id" type="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" type="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><span class="id" type="tactic">unfold</span> <span class="id" type="var">f</span>, <span class="id" type="var">g</span>, <a class="idref" href="HoTT.Basics.Overture.html#compose"><span class="id" type="definition">compose</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" type="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
  - <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><br>
    <span class="id" type="tactic">set</span> (<span class="id" type="var">trunca</span> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">bitot_R</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">trunca</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
    <span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" type="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" type="definition">apD</span></a> <span class="id" type="var">H_h</span> (<a class="idref" href="HoTT.hit.V.html#RPushout.glue"><span class="id" type="axiom">glue</span></a> <span class="id" type="var">R</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" type="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><span class="id" type="tactic">unfold</span> <span class="id" type="var">f</span>, <span class="id" type="var">g</span>, <a class="idref" href="HoTT.Basics.Overture.html#compose"><span class="id" type="definition">compose</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" type="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Simpler induction principle when the goal is an hprop 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(207, '0_3_43');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> (<span class="id" type="var">P</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">Type</span>)<br>
  (<span class="id" type="var">H_set</span> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_f</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)), <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a>))<br>
  (<span class="id" type="var">isHProp_P</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" type="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>))<br>
  : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(208, '0_3_43');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(209, '0_3_43');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V_rect"><span class="id" type="definition">V_rect</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H_set</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(210, '0_3_43');
      "><br>
  <span class="id" type="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(211, '0_3_43');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(212, '0_3_43');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(213, '0_3_43');
      "><br>
<br>
<span class="id" type="keyword">Section</span> <a name="AssumingUA"><span class="id" type="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(214, '0_3_43');
      "><br>
<span class="id" type="keyword">Context</span> `{<span class="id" type="var">ua</span> : <a class="idref" href="HoTT.types.Universe.html#Univalence"><span class="id" type="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(215, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
<a name="lab193"></a><h2 class="section">Membership relation</h2>
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(222, '0_3_47');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="mem"><span class="id" type="definition">mem</span></a> (<span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(223, '0_3_47');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(224, '0_3_47');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect'_nd"><span class="id" type="definition">V_rect'_nd</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(225, '0_3_47');
      "><span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(226, '0_3_47');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.HProp.html#hp"><span class="id" type="constructor">hp</span></a> (<a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> : <span class="id" type="var">A</span> ⇒ <span class="id" type="var">f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">x</span>)) <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(227, '0_3_47');
      "><span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(228, '0_3_47');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">eqimg</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(229, '0_3_47');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Universe.html#path_iff_hProp_uncurried"><span class="id" type="definition">path_iff_hProp_uncurried</span></a>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(230, '0_3_47');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(231, '0_3_47');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> <span class="id" type="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(232, '0_3_47');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(233, '0_3_47');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">eqimg</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(234, '0_3_47');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(235, '0_3_47');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><span class="id" type="tactic">transitivity</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> <span class="id" type="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">eqimg</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><span class="id" type="tactic">transitivity</span> (<span class="id" type="var">g</span> <span class="id" type="var">b</span>); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">"</span></a>x ∈ v" := (<a class="idref" href="HoTT.hit.V.html#mem"><span class="id" type="definition">mem</span></a> <span class="id" type="var">x</span> <span class="id" type="var">v</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 30) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
<a name="lab194"></a><h2 class="section">Subset relation</h2>
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(256, '0_3_51');
      ">
<br>
<span class="id" type="keyword">Definition</span> <a name="subset"><span class="id" type="definition">subset</span></a> (<span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">y</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a><br>
:= <a class="idref" href="HoTT.HProp.html#hp"><span class="id" type="constructor">hp</span></a> (<span class="id" type="keyword">∀</span> <span class="id" type="var">z</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>) <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(257, '0_3_51');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:x_'%E2%8A%86'_x"><span class="id" type="notation">"</span></a>x ⊆ y" := (<a class="idref" href="HoTT.hit.V.html#subset"><span class="id" type="definition">subset</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 30) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(258, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
<a name="lab195"></a><h2 class="section">Bisimulation relation</h2>
 The equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in hProp_U : Type{U'}, hence the codomain is hProp@{U'}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(265, '0_3_55');
      ">
<br>
<span class="id" type="keyword">Local</span> <span class="id" type="keyword">Definition</span> <a name="bisim_aux"><span class="id" type="definition">bisim_aux</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">H_f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(266, '0_3_55');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(267, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#V_rect'_nd"><span class="id" type="definition">V_rect'_nd</span></a> <span class="id" type="keyword">with</span><br>
    (<span class="id" type="keyword">fun</span> <span class="id" type="var">B</span> <span class="id" type="var">g</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.HProp.html#hp"><span class="id" type="constructor">hp</span></a> ( <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span> ⇒ <span class="id" type="var">H_f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
                      <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <span class="id" type="var">H_f</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a>)) ) <span class="id" type="var">_</span><br>
    ).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(268, '0_3_55');
      "><br>
  <span class="id" type="tactic">exact</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(269, '0_3_55');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">B</span> <span class="id" type="var">B'</span> <span class="id" type="var">g</span> <span class="id" type="var">g'</span> <span class="id" type="var">eq_img</span> <span class="id" type="var">H_g</span> <span class="id" type="var">H_g'</span> <span class="id" type="var">H_img</span>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(270, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Universe.html#path_iff_hProp_uncurried"><span class="id" type="definition">path_iff_hProp_uncurried</span></a>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(271, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(272, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(273, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(274, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(275, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(276, '0_3_55');
      "><br>
      <span class="id" type="tactic">unfold</span> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(277, '0_3_55');
      "><span class="id" type="tactic">refine</span> (@<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <span class="id" type="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">g</span> <span class="id" type="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">g'</span> <span class="id" type="var">b0</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <span class="id" type="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">H_f</span> <span class="id" type="var">a</span> (<span class="id" type="var">g'</span> <span class="id" type="var">b0</span>)<a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(278, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b'</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(279, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(280, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">H_f</span> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(281, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(282, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">b'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(283, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(284, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H2</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(285, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(286, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(287, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(288, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">H_f</span> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(289, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(290, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(291, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(292, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b'</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(293, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(294, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(295, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(296, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(297, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">H_f</span> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(298, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(299, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(300, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b'</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(301, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H2</span> <span class="id" type="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(302, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(303, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(304, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(305, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">H_f</span> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(306, '0_3_55');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(307, '0_3_55');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="bisimulation"><span class="id" type="definition">bisimulation</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">U'</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">U'</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp@</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">U'</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(308, '0_3_55');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(309, '0_3_55');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect'_nd"><span class="id" type="definition">V_rect'_nd</span></a> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) <span class="id" type="var">_</span> <a class="idref" href="HoTT.hit.V.html#bisim_aux"><span class="id" type="definition">bisim_aux</span></a> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(310, '0_3_55');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">eq_img</span> <span class="id" type="var">H_f</span> <span class="id" type="var">H_g</span> <span class="id" type="var">H_img</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(311, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(312, '0_3_55');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(313, '0_3_55');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">C</span> <span class="id" type="var">h</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(314, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Universe.html#path_iff_hProp_uncurried"><span class="id" type="definition">path_iff_hProp_uncurried</span></a>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(315, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(316, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(317, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">H_img</span> <span class="id" type="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(318, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(319, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H1</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(320, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(321, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">c</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(322, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(323, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">p</span> (<span class="id" type="var">h</span> <span class="id" type="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(324, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(325, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H2</span> <span class="id" type="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(326, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(327, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">H_img</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(328, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(329, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(330, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(331, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">p</span> (<span class="id" type="var">h</span> <span class="id" type="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(332, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(333, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(334, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">H_img</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(335, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(336, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H1</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(337, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(338, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">c</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(339, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(340, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(341, '0_3_55');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(342, '0_3_55');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H2</span> <span class="id" type="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(343, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(344, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">H_img</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(345, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(346, '0_3_55');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(347, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(348, '0_3_55');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <span class="id" type="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(349, '0_3_55');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(350, '0_3_55');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:x_'~~'_x"><span class="id" type="notation">"</span></a>u ~~ v" := (<a class="idref" href="HoTT.hit.V.html#bisimulation"><span class="id" type="definition">bisimulation</span></a> <span class="id" type="var">u</span> <span class="id" type="var">v</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 30) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(351, '0_3_55');
      "><br>
<br>
<span class="id" type="keyword">Global Instance</span> <a name="reflexive_bisimulation"><span class="id" type="instance">reflexive_bisimulation</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Reflexive"><span class="id" type="class">Reflexive</span></a> <a class="idref" href="HoTT.hit.V.html#bisimulation"><span class="id" type="definition">bisimulation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(352, '0_3_55');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(353, '0_3_55');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(354, '0_3_55');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">H_f</span>; <span class="id" type="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(355, '0_3_55');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(356, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(357, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(358, '0_3_55');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(359, '0_3_55');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="bisimulation_equiv_id"><span class="id" type="lemma">bisimulation_equiv_id</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'~~'_x"><span class="id" type="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(360, '0_3_55');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(361, '0_3_55');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(362, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#equiv_iff_hprop"><span class="id" type="definition">equiv_iff_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(363, '0_3_55');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">u</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'~~'_x"><span class="id" type="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span> (<a class="idref" href="HoTT.hit.V.html#reflexive_bisimulation"><span class="id" type="instance">reflexive_bisimulation</span></a> <span class="id" type="var">u</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(364, '0_3_55');
      "><br>
  <span class="id" type="tactic">generalize</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(365, '0_3_55');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">H_f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(366, '0_3_55');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">intros</span> <span class="id" type="var">B</span> <span class="id" type="var">g</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(367, '0_3_55');
      "><br>
  <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(368, '0_3_55');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(369, '0_3_55');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(370, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(371, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H1</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(372, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(373, '0_3_55');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(374, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">exact</span> (<span class="id" type="var">H_f</span> <span class="id" type="var">a</span> (<span class="id" type="var">g</span> <span class="id" type="var">b</span>) <span class="id" type="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(375, '0_3_55');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(376, '0_3_55');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">H2</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(377, '0_3_55');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(378, '0_3_55');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(379, '0_3_55');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">exact</span> (<span class="id" type="var">H_f</span> <span class="id" type="var">a</span> (<span class="id" type="var">g</span> <span class="id" type="var">b</span>) <span class="id" type="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(380, '0_3_55');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(381, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
<a name="lab196"></a><h2 class="section">Canonical presentation of V-sets (Lemma 10.5.6)</h2>
<div class="doc" scenenumber="4"> </div>

 Using the regular kernel (with = instead of ~~) also works, but this seems to be a Coq bug, it should lead to a universe inconsistency in the monic_set_present lemma later. This version is the right way to do it. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(390, '0_3_59');
      ">
<span class="id" type="keyword">Definition</span> <a name="ker_bisim"><span class="id" type="definition">ker_bisim</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>) := (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'~~'_x"><span class="id" type="notation">~~</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(391, '0_3_59');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="ker_bisim_is_ker"><span class="id" type="definition">ker_bisim_is_ker</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)<br>
  : <span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a>), <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'&lt;~&gt;'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.hit.V.html#ker_bisim"><span class="id" type="definition">ker_bisim</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(392, '0_3_59');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(393, '0_3_59');
      "><br>
  <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#bisimulation_equiv_id"><span class="id" type="lemma">bisimulation_equiv_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(394, '0_3_59');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(395, '0_3_59');
      "><br>
<br>
<span class="id" type="keyword">Section</span> <a name="AssumingUA.MonicSetPresent_Uniqueness"><span class="id" type="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(396, '0_3_59');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(400, '0_3_63');
      ">
<br>
<span class="id" type="keyword">Context</span> {<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} {<span class="id" type="var">Au</span> <span class="id" type="var">Au'</span>: <span class="id" type="keyword">Type</span>} {<span class="id" type="var">h</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" type="variable">Au</span></a>} {<span class="id" type="var">h'</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au'"><span class="id" type="variable">Au'</span></a>} {<span class="id" type="var">mu</span> : <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} {<span class="id" type="var">mono</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#mu"><span class="id" type="variable">mu</span></a>}<br>
  {<span class="id" type="var">mu'</span> : <a class="idref" href="HoTT.hit.V.html#Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} {<span class="id" type="var">mono'</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#mu'"><span class="id" type="variable">mu'</span></a>} {<span class="id" type="var">p</span> : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#mu"><span class="id" type="variable">mu</span></a>} {<span class="id" type="var">p'</span> : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#mu'"><span class="id" type="variable">mu'</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(401, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a>, <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">a'</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> <span class="id" type="var">a'</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
                     <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">a'</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a>, <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <span class="id" type="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> <a class="idref" href="HoTT.hit.V.html#a'"><span class="id" type="variable">a'</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(402, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(403, '0_3_63');
      "><br>
  <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(404, '0_3_63');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(405, '0_3_63');
      "><span class="id" type="tactic">exact</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" type="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" type="variable">mono'</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <span class="id" type="var">a</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" type="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" type="variable">p'</span></a>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(406, '0_3_63');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(407, '0_3_63');
      "><span class="id" type="tactic">exact</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" type="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" type="variable">mono</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> <span class="id" type="var">a'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> <span class="id" type="var">a'</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" type="variable">p'</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" type="variable">p</span></a>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a'</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(408, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(409, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(410, '0_3_63');
      "><br>
<span class="id" type="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">a'</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.hit.V.html#a'"><span class="id" type="variable">a'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(411, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" type="variable">hom1</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(412, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(413, '0_3_63');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(414, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" type="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" type="variable">mono'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(415, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> <span class="id" type="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(416, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> <span class="id" type="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(417, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> <span class="id" type="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(418, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(419, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" type="variable">hom2</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(420, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(421, '0_3_63');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(422, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" type="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" type="variable">mono</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(423, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(424, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a> <span class="id" type="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(425, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(426, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(427, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(428, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(429, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Universe.html#path_universe_uncurried"><span class="id" type="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(430, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" type="variable">e</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" type="variable">hom2</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" type="variable">hom1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(431, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(432, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="mu_eq_mu'"><span class="id" type="lemma">mu_eq_mu'</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(433, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(434, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" type="definition">path_forall</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(435, '0_3_63');
      "><span class="id" type="tactic">intro</span> <span class="id" type="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(436, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">X</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#X"><span class="id" type="variable">X</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^^</span></a> <span class="id" type="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(437, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> (@<a class="idref" href="HoTT.types.Arrow.html#transport_arrow"><span class="id" type="definition">transport_arrow</span></a> <span class="id" type="keyword">Type</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span> ⇒ <a class="idref" href="HoTT.hit.V.html#X"><span class="id" type="variable">X</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">X</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <span class="id" type="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(438, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" type="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^^</span></a> <span class="id" type="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(439, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" type="definition">transport_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(440, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" type="variable">inv_e</span></a> <span class="id" type="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(441, '0_3_63');
      "><br>
  2: <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#eq_img_untrunc"><span class="id" type="lemma">eq_img_untrunc</span></a> <span class="id" type="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(442, '0_3_63');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(443, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" type="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a> <span class="id" type="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(444, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" type="abbreviation">idmap</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="var">a'</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" type="definition">inv_V</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(445, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Universe.html#transport_path_universe"><span class="id" type="definition">transport_path_universe</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(446, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(447, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="monic_set_present_uniqueness"><span class="id" type="lemma">monic_set_present_uniqueness</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" type="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" type="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" type="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x_':&gt;'_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" type="variable">mu'</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h'"><span class="id" type="variable">h'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" type="variable">mono'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" type="variable">p'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x_':&gt;'_x"><span class="id" type="notation">:&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <span class="id" type="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">m</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <span class="id" type="var">m</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <span class="id" type="var">m</span><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(448, '0_3_63');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(449, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(450, '0_3_63');
      "><br>
  <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(451, '0_3_63');
      "><br>
  <span class="id" type="tactic">transitivity</span> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'#'_x"><span class="id" type="notation">#</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transportD"><span class="id" type="definition">transportD</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> <span class="id" type="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" type="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" type="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" type="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(452, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> (@<a class="idref" href="HoTT.types.Sigma.html#transport_sigma"><span class="id" type="definition">transport_sigma</span></a> <span class="id" type="keyword">Type</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> ⇒ <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> <span class="id" type="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" type="variable">Au'</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" type="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" type="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" type="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" type="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" type="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(453, '0_3_63');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_sigma_hprop"><span class="id" type="definition">path_sigma_hprop</span></a>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(454, '0_3_63');
      "><br>
  <span class="id" type="tactic">exact</span> <a class="idref" href="HoTT.hit.V.html#mu_eq_mu'"><span class="id" type="lemma">mu_eq_mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(455, '0_3_63');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(456, '0_3_63');
      "><br>
<br>
<span class="id" type="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" type="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(457, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
This lemma actually says a little more than 10.5.6, i.e., that Au is a hSet 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(461, '0_3_67');
      ">
<span class="id" type="keyword">Lemma</span> <a name="monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>, <a class="idref" href="Coq.Init.Specif.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Au</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">m</span> : <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" type="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">),</span></a><br>
  <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.hit.V.html#Au"><span class="id" type="variable">Au</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(462, '0_3_67');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(463, '0_3_67');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(464, '0_3_67');
      "><br>
  - <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(465, '0_3_67');
      "><br>
    <span class="id" type="tactic">destruct</span> (<a class="idref" href="HoTT.hit.quotient.html#quotient_kernel_factor"><span class="id" type="lemma">quotient_kernel_factor</span></a> <span class="id" type="var">f</span> (<a class="idref" href="HoTT.hit.V.html#ker_bisim"><span class="id" type="definition">ker_bisim</span></a> <span class="id" type="var">f</span>) (<a class="idref" href="HoTT.hit.V.html#ker_bisim_is_ker"><span class="id" type="definition">ker_bisim_is_ker</span></a> <span class="id" type="var">f</span>))<br>
      <span class="id" type="keyword">as</span> [<span class="id" type="var">Au</span> [<span class="id" type="var">eu</span> [<span class="id" type="var">mu</span> (((<span class="id" type="var">hset_Au</span>, <span class="id" type="var">epi_eu</span>), <span class="id" type="var">mono_mu</span>), <span class="id" type="var">factor</span>)]]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(466, '0_3_67');
      "><br>
    <span class="id" type="tactic">∃</span> <span class="id" type="var">Au</span>, <span class="id" type="var">mu</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(467, '0_3_67');
      "><span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(468, '0_3_67');
      "><span class="id" type="tactic">exact</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">hset_Au</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">mono_mu</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(469, '0_3_67');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(470, '0_3_67');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(471, '0_3_67');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<span class="id" type="var">eu</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(472, '0_3_67');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">factor</span> <span class="id" type="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(473, '0_3_67');
      "><br>
    + <span class="id" type="tactic">intro</span> <span class="id" type="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(474, '0_3_67');
      "><span class="id" type="tactic">generalize</span> (<span class="id" type="var">epi_eu</span> <span class="id" type="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(475, '0_3_67');
      "><br>
      <span class="id" type="tactic">intros</span> ?; <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" type="method">center</span></a> <span class="id" type="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(476, '0_3_67');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(477, '0_3_67');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(478, '0_3_67');
      "><span class="id" type="tactic">transitivity</span> (<span class="id" type="var">mu</span> (<span class="id" type="var">eu</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(479, '0_3_67');
      "><br>
      <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" type="definition">ap10</span></a> <span class="id" type="var">factor</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(480, '0_3_67');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">mu</span> <span class="id" type="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(481, '0_3_67');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(482, '0_3_67');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#hprop_allpath"><span class="id" type="lemma">hprop_allpath</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(483, '0_3_67');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">Au</span> [<span class="id" type="var">mu</span> ((<span class="id" type="var">hset</span>, <span class="id" type="var">mono</span>), <span class="id" type="var">p</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(484, '0_3_67');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">Au'</span> [<span class="id" type="var">mu'</span> ((<span class="id" type="var">hset'</span>, <span class="id" type="var">mono'</span>), <span class="id" type="var">p'</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(485, '0_3_67');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#monic_set_present_uniqueness"><span class="id" type="lemma">monic_set_present_uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(486, '0_3_67');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(487, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="type_of_members"><span class="id" type="definition">type_of_members</span></a> (<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <span class="id" type="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(488, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">"</span></a>[ u ]" := (<a class="idref" href="HoTT.hit.V.html#type_of_members"><span class="id" type="definition">type_of_members</span></a> <span class="id" type="var">u</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 20) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(489, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="func_of_members"><span class="id" type="definition">func_of_members</span></a> {<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>)) : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(490, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="is_hset_typeofmembers"><span class="id" type="definition">is_hset_typeofmembers</span></a> {<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" type="abbreviation">IsHSet</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a>) := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(491, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="IsEmbedding_funcofmembers"><span class="id" type="definition">IsEmbedding_funcofmembers</span></a> {<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" type="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(492, '0_3_67');
      "><br>
<br>
<span class="id" type="keyword">Definition</span> <a name="is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> (<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.hit.V.html#monic_set_present"><span class="id" type="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(493, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a name="lab197"></a><h2 class="section">Lemmas 10.5.8 (i) &amp; (vii), we put them here because they are useful later</h2>
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(500, '0_3_71');
      ">
<span class="id" type="keyword">Lemma</span> <a name="extensionality"><span class="id" type="lemma">extensionality</span></a> : <span class="id" type="keyword">∀</span> {<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>}, <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%8A%86'_x"><span class="id" type="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%8A%86'_x"><span class="id" type="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(501, '0_3_71');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(502, '0_3_71');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(503, '0_3_71');
      "><span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(504, '0_3_71');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(505, '0_3_71');
      "><span class="id" type="tactic">intros</span> <span class="id" type="var">B</span> <span class="id" type="var">g</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(506, '0_3_71');
      "><br>
  <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(507, '0_3_71');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(508, '0_3_71');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(509, '0_3_71');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(510, '0_3_71');
      "><br>
    + <span class="id" type="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(511, '0_3_71');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>) (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a>1<a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(512, '0_3_71');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(513, '0_3_71');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(514, '0_3_71');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(515, '0_3_71');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(516, '0_3_71');
      "><br>
    + <span class="id" type="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(517, '0_3_71');
      "><span class="id" type="tactic">apply</span> (<span class="id" type="var">H2</span> (<span class="id" type="var">g</span> <span class="id" type="var">b</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(518, '0_3_71');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(519, '0_3_71');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(520, '0_3_71');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(521, '0_3_71');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">z</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span> <span class="id" type="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(522, '0_3_71');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(523, '0_3_71');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">z</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(524, '0_3_71');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(525, '0_3_71');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="mem_induction"><span class="id" type="lemma">mem_induction</span></a> (<span class="id" type="var">C</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>)<br>
: <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">v</span>, <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span>, <a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(526, '0_3_71');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(527, '0_3_71');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(528, '0_3_71');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(529, '0_3_71');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">H_f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(530, '0_3_71');
      "><span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(531, '0_3_71');
      "><span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">Hx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(532, '0_3_71');
      "><br>
  <span class="id" type="tactic">generalize</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(533, '0_3_71');
      "><br>
  <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(534, '0_3_71');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">C</span> <span class="id" type="var">p</span> (<span class="id" type="var">H_f</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(535, '0_3_71');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(536, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
<a name="lab198"></a><h2 class="section">Two useful lemmas</h2>
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(543, '0_3_75');
      ">
<br>
<span class="id" type="keyword">Global Instance</span> <a name="irreflexive_mem"><span class="id" type="instance">irreflexive_mem</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Irreflexive"><span class="id" type="class">Irreflexive</span></a> <a class="idref" href="HoTT.hit.V.html#mem"><span class="id" type="definition">mem</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(544, '0_3_75');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(545, '0_3_75');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#mem_induction"><span class="id" type="lemma">mem_induction</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.HProp.html#hp"><span class="id" type="constructor">hp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">_</span>) <span class="id" type="var">_</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(546, '0_3_75');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(547, '0_3_75');
      "><span class="id" type="tactic">intro</span> <span class="id" type="var">Hv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(548, '0_3_75');
      "><br>
  <span class="id" type="tactic">exact</span> (<span class="id" type="var">H</span> <span class="id" type="var">v</span> <span class="id" type="var">Hv</span> <span class="id" type="var">Hv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(549, '0_3_75');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(550, '0_3_75');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="path_V_eqimg"><span class="id" type="lemma">path_V_eqimg</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} {<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} {<span class="id" type="var">g</span> : <a class="idref" href="HoTT.hit.V.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#equal_img"><span class="id" type="definition">equal_img</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#g"><span class="id" type="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(551, '0_3_75');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(552, '0_3_75');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(553, '0_3_75');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(554, '0_3_75');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(555, '0_3_75');
      "><br>
    <span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">f</span> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <span class="id" type="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(556, '0_3_75');
      "><br>
    { <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" type="lemma">extensionality</span></a> <span class="id" type="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(557, '0_3_75');
      "><br>
      <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">reflexivity</span>. }<br>
    <span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(558, '0_3_75');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(559, '0_3_75');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(560, '0_3_75');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(561, '0_3_75');
      "><br>
    <span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">g</span> <span class="id" type="var">b</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <span class="id" type="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(562, '0_3_75');
      "><br>
    { <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" type="lemma">extensionality</span></a> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(563, '0_3_75');
      "><br>
      <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">reflexivity</span>. }<br>
    <span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(564, '0_3_75');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(565, '0_3_75');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(566, '0_3_75');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(567, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
<a name="lab199"></a><h2 class="section">Definitions of particular sets in V</h2>
<div class="doc" scenenumber="4"> </div>

 The empty set 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(576, '0_3_79');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_empty"><span class="id" type="definition">V_empty</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Empty_rect"><span class="id" type="definition">Empty_rect</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(577, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The singleton {u} 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(581, '0_3_83');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_singleton"><span class="id" type="definition">V_singleton</span></a> (<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V@</span></a>{<span class="id" type="var">U'</span> <span class="id" type="var">U</span>} := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Unit_rect"><span class="id" type="definition">Unit_rect</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(582, '0_3_83');
      "><br>
<br>
<span class="id" type="keyword">Global Instance</span> <a name="isequiv_ap_V_singleton"><span class="id" type="instance">isequiv_ap_V_singleton</span></a> {<span class="id" type="var">u</span> <span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> (@<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(583, '0_3_83');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(584, '0_3_83');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">try</span> <span class="id" type="tactic">solve</span> [ <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a> ].</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(585, '0_3_83');
      "><br>
  { <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(586, '0_3_83');
      "><span class="id" type="tactic">specialize</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" type="lemma">path_V_eqimg</span></a> <span class="id" type="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(587, '0_3_83');
      "><span class="id" type="tactic">intros</span> (<span class="id" type="var">H1</span>, <span class="id" type="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(588, '0_3_83');
      "><br>
    <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" type="constructor">tt</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(589, '0_3_83');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(590, '0_3_83');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>. }<br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(591, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The pair {u,v} 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(595, '0_3_87');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_pair"><span class="id" type="definition">V_pair</span></a> (<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V@</span></a>{<span class="id" type="var">U'</span> <span class="id" type="var">U</span>} := <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span> : <a class="idref" href="HoTT.types.Bool.html#Bool"><span class="id" type="inductive">Bool</span></a> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">then</span> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(596, '0_3_87');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="path_pair"><span class="id" type="lemma">path_pair</span></a> {<span class="id" type="var">u</span> <span class="id" type="var">v</span> <span class="id" type="var">u'</span> <span class="id" type="var">v'</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V@</span></a>{<span class="id" type="var">U'</span> <span class="id" type="var">U</span>}} : <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#u'"><span class="id" type="variable">u'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v'"><span class="id" type="variable">v'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u'"><span class="id" type="variable">u'</span></a> <a class="idref" href="HoTT.hit.V.html#v'"><span class="id" type="variable">v'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(597, '0_3_87');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(598, '0_3_87');
      "><br>
  <span class="id" type="tactic">intros</span> (<span class="id" type="var">H1</span>, <span class="id" type="var">H2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(599, '0_3_87');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(600, '0_3_87');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(601, '0_3_87');
      "><br>
  + <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Bool.html#Bool_rect"><span class="id" type="definition">Bool_rect</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(602, '0_3_87');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(603, '0_3_87');
      "><span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(604, '0_3_87');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>; <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(605, '0_3_87');
      "><br>
  + <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Bool.html#Bool_rect"><span class="id" type="definition">Bool_rect</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(606, '0_3_87');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a>; <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(607, '0_3_87');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>; <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(608, '0_3_87');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(609, '0_3_87');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a> {<span class="id" type="var">u</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(610, '0_3_87');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(611, '0_3_87');
      "><br>
  <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(612, '0_3_87');
      "><br>
  + <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(613, '0_3_87');
      "><span class="id" type="tactic">destruct</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" type="lemma">path_V_eqimg</span></a> <span class="id" type="var">H</span>) <span class="id" type="keyword">as</span> (<span class="id" type="var">H1</span>, <span class="id" type="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(614, '0_3_87');
      "><br>
    <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(615, '0_3_87');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(616, '0_3_87');
      "><br>
    <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> (<span class="id" type="var">H1</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(617, '0_3_87');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p'</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(618, '0_3_87');
      "><br>
    <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>| <span class="id" type="tactic">exact</span> <span class="id" type="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(619, '0_3_87');
      "><br>
  + <span class="id" type="tactic">intros</span> (<span class="id" type="var">p1</span>, <span class="id" type="var">p2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(620, '0_3_87');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(621, '0_3_87');
      "><br>
    <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" type="constructor">tt</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(622, '0_3_87');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">a</span>; [<span class="id" type="tactic">exact</span> <span class="id" type="var">p1</span> | <span class="id" type="tactic">exact</span> <span class="id" type="var">p2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(623, '0_3_87');
      "><br>
    <span class="id" type="tactic">intro</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(624, '0_3_87');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(625, '0_3_87');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(626, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The ordered pair (u,v) 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(630, '0_3_91');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_pair_ord"><span class="id" type="definition">V_pair_ord</span></a> (<span class="id" type="var">u</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> := <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> (<a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>) (<a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(631, '0_3_91');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">"</span></a> [ u , v ] " := (<a class="idref" href="HoTT.hit.V.html#V_pair_ord"><span class="id" type="definition">V_pair_ord</span></a> <span class="id" type="var">u</span> <span class="id" type="var">v</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 20) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(632, '0_3_91');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="path_pair_ord"><span class="id" type="lemma">path_pair_ord</span></a> {<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>} : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(633, '0_3_91');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(634, '0_3_91');
      "><br>
  <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(635, '0_3_91');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(636, '0_3_91');
      "><span class="id" type="tactic">assert</span> (<span class="id" type="var">p1</span> : <span class="id" type="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">c</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(637, '0_3_91');
      "><br>
    + <span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <span class="id" type="var">a</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">c</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">d</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(638, '0_3_91');
      "><br>
      { <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" type="lemma">extensionality</span></a> <span class="id" type="var">p</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(639, '0_3_91');
      "><span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(640, '0_3_91');
      "><br>
        <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a>; <span class="id" type="tactic">reflexivity</span>. }<br>
      <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> <span class="id" type="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(641, '0_3_91');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p'</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(642, '0_3_91');
      "><br>
      <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'%5E-1'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a><a class="idref" href="HoTT.Basics.Overture.html#:equiv_scope:x_'%5E-1'"><span class="id" type="notation">)^-1</span></a> <span class="id" type="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(643, '0_3_91');
      "><br>
      <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a> <span class="id" type="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(644, '0_3_91');
      "><br>
    + <span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(645, '0_3_91');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(646, '0_3_91');
      "><br>
      <span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <a class="idref" href="HoTT.hit.Truncations.html#hor"><span class="id" type="definition">hor</span></a> (<span class="id" type="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">c</span>) (<span class="id" type="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">d</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(647, '0_3_91');
      "><br>
      { <span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">c</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">d</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(648, '0_3_91');
      "><br>
        { <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" type="lemma">extensionality</span></a> <span class="id" type="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(649, '0_3_91');
      "><br>
          <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>; <span class="id" type="tactic">reflexivity</span>. }<br>
        <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> <span class="id" type="var">H'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(650, '0_3_91');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p'</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(651, '0_3_91');
      "><br>
        × <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">left</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(652, '0_3_91');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a> <span class="id" type="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(653, '0_3_91');
      "><br>
        × <span class="id" type="tactic">destruct</span> (<a class="idref" href="HoTT.hit.V.html#path_V_eqimg"><span class="id" type="lemma">path_V_eqimg</span></a> <span class="id" type="var">p'</span>) <span class="id" type="keyword">as</span> (<span class="id" type="var">H1</span>, <span class="id" type="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(654, '0_3_91');
      "><br>
          <span class="id" type="tactic">generalize</span> (<span class="id" type="var">H2</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>); <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(655, '0_3_91');
      "><br>
          <span class="id" type="tactic">intros</span> [<span class="id" type="var">t</span> <span class="id" type="var">p''</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(656, '0_3_91');
      "><br>
          <span class="id" type="tactic">left</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(657, '0_3_91');
      "><span class="id" type="tactic">right</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>. }<br>
      <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a> <span class="id" type="var">_</span> <span class="id" type="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(658, '0_3_91');
      "><span class="id" type="tactic">intro</span> <span class="id" type="tactic">case</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="tactic">case</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">p'</span>| <span class="id" type="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(659, '0_3_91');
      "><br>
      2: <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(660, '0_3_91');
      "><br>
      <span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">b</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> (<a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <span class="id" type="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(661, '0_3_91');
      "><br>
      { <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(662, '0_3_91');
      "><br>
        <span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(663, '0_3_91');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a>; <span class="id" type="tactic">exact</span> (<span class="id" type="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(664, '0_3_91');
      "><br>
        <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(665, '0_3_91');
      "><br>
        <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">exact</span> (<span class="id" type="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>) | <span class="id" type="tactic">reflexivity</span>]. }</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(666, '0_3_91');
      "><br>
      <span class="id" type="tactic">assert</span> (<span class="id" type="var">H''</span> : <a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#V_singleton"><span class="id" type="definition">V_singleton</span></a> <span class="id" type="var">b</span>)<br>
        <span class="id" type="tactic">by</span> <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a> (<span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">H'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(667, '0_3_91');
      "><br>
      <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#pair_eq_singleton"><span class="id" type="lemma">pair_eq_singleton</span></a> <span class="id" type="var">H''</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(668, '0_3_91');
      "><br>
- <span class="id" type="tactic">intros</span> (<span class="id" type="var">p</span>, <span class="id" type="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(669, '0_3_91');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#path_pair"><span class="id" type="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(670, '0_3_91');
      "><span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(671, '0_3_91');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a>; <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(672, '0_3_91');
      "><br>
  <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#path_pair"><span class="id" type="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(673, '0_3_91');
      "><span class="id" type="tactic">split</span>; <span class="id" type="tactic">assumption</span>; <span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(674, '0_3_91');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(675, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The cartesian product a × b 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(679, '0_3_95');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_cart_prod"><span class="id" type="definition">V_cart_prod</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(680, '0_3_95');
      "><br>
<br>
<span class="id" type="keyword">Notation</span> <a name="AssumingUA.:set_scope:x_'%C3%97'_x"><span class="id" type="notation">"</span></a> a × b " := (<a class="idref" href="HoTT.hit.V.html#V_cart_prod"><span class="id" type="definition">V_cart_prod</span></a> <span class="id" type="var">a</span> <span class="id" type="var">b</span>)<br>
  (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 25) : <span class="id" type="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(681, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
f is a function with domain a and codomain b 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(685, '0_3_99');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_is_func"><span class="id" type="definition">V_is_func</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) := <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%8A%86'_x"><span class="id" type="notation">⊆</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%C3%97'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">y</span> ⇒ <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">y'</span>, <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a><a class="idref" href="HoTT.hit.V.html#y'"><span class="id" type="variable">y'</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y'"><span class="id" type="variable">y'</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(686, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The set of functions from a to b 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(690, '0_3_103');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_func"><span class="id" type="definition">V_func</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">b</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><br>
:= @<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">f</span> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<a class="idref" href="HoTT.hit.V.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>)<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> )).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(691, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The union of a set Uv 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(695, '0_3_107');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_union"><span class="id" type="definition">V_union</span></a> (<span class="id" type="var">v</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) :=<br>
  @<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(696, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
The ordinal successor x ∪ {x} 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(700, '0_3_111');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_succ"><span class="id" type="definition">V_succ</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(701, '0_3_111');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(702, '0_3_111');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect'_nd"><span class="id" type="definition">V_rect'_nd</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(703, '0_3_111');
      "><span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(704, '0_3_111');
      "><br>
  <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">x</span> : <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" type="inductive">Unit</span></a>) ⇒ <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" type="constructor">inl</span></a> <span class="id" type="var">a</span> ⇒ <span class="id" type="var">f</span> <span class="id" type="var">a</span><br>
                                          | <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" type="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" type="constructor">tt</span></a> ⇒ <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> <span class="id" type="var">f</span> <span class="id" type="keyword">end</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(705, '0_3_111');
      "><br>
  <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">eq_img</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(706, '0_3_111');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(707, '0_3_111');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(708, '0_3_111');
      "><br>
  - <span class="id" type="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(709, '0_3_111');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(710, '0_3_111');
      "><br>
    + <span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(711, '0_3_111');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(712, '0_3_111');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">b</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(713, '0_3_111');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" type="constructor">inl</span></a> <span class="id" type="var">b</span>); <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(714, '0_3_111');
      "><br>
    + <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" type="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" type="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(715, '0_3_111');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(716, '0_3_111');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(717, '0_3_111');
      "><br>
  - <span class="id" type="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(718, '0_3_111');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(719, '0_3_111');
      "><br>
    + <span class="id" type="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" type="projection">snd</span></a> <span class="id" type="var">eq_img</span> <span class="id" type="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(720, '0_3_111');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(721, '0_3_111');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(722, '0_3_111');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" type="constructor">inl</span></a> <span class="id" type="var">a</span>); <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(723, '0_3_111');
      "><br>
    + <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" type="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" type="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(724, '0_3_111');
      "><span class="id" type="tactic">destruct</span> <span class="id" type="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(725, '0_3_111');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#setext'"><span class="id" type="definition">setext'</span></a>; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(726, '0_3_111');
      "><br>
<span class="id" type="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(727, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
The set of finite ordinals 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(731, '0_3_115');
      ">
<span class="id" type="keyword">Definition</span> <a name="V_omega"><span class="id" type="definition">V_omega</span></a> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fix</span> <span class="id" type="var">I</span> <span class="id" type="var">n</span> := <span class="id" type="keyword">match</span> <a class="idref" href="HoTT.hit.V.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">with</span> 0   ⇒ <a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" type="definition">V_empty</span></a><br>
                              | <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span> ⇒ <a class="idref" href="HoTT.hit.V.html#V_succ"><span class="id" type="definition">V_succ</span></a> (<a class="idref" href="HoTT.hit.V.html#I"><span class="id" type="variable">I</span></a> <a class="idref" href="HoTT.hit.V.html#n"><span class="id" type="variable">n</span></a>) <span class="id" type="keyword">end</span>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(732, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
<a name="lab200"></a><h2 class="section">Axioms of set theory (theorem 10.5.8)</h2>
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(739, '0_3_119');
      ">
<br>
<span class="id" type="keyword">Lemma</span> <a name="not_mem_Vempty"><span class="id" type="lemma">not_mem_Vempty</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" type="definition">V_empty</span></a><a class="idref" href="HoTT.Basics.Overture.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(740, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(741, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(742, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(743, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> [<span class="id" type="var">ff</span> <span class="id" type="var">_</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(744, '0_3_119');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">ff</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(745, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(746, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="pairing"><span class="id" type="lemma">pairing</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hor"><span class="id" type="definition">hor</span></a> (<a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a>) (<a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(747, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(748, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(749, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(750, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_pair"><span class="id" type="definition">V_pair</span></a> <span class="id" type="var">u</span> <span class="id" type="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(751, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(752, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intros</span> [[|] <span class="id" type="var">p</span>]; [<span class="id" type="tactic">left</span>|<span class="id" type="tactic">right</span>]; <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(753, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">p</span> | <span class="id" type="var">p</span>]; [<span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#true"><span class="id" type="constructor">true</span></a> | <span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.types.Bool.html#false"><span class="id" type="constructor">false</span></a>]; <span class="id" type="tactic">exact</span> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(754, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(755, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="infinity"><span class="id" type="lemma">infinity</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#V_empty"><span class="id" type="definition">V_empty</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" type="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" type="definition">V_omega</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#V_succ"><span class="id" type="definition">V_succ</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#V_omega"><span class="id" type="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(756, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(757, '0_3_119');
      "><br>
  <span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(758, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> 0; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(759, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(760, '0_3_119');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(761, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> [<span class="id" type="var">n</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(762, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(763, '0_3_119');
      "><span class="id" type="tactic">rewrite</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(764, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(765, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="union"><span class="id" type="lemma">union</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(766, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(767, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(768, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_union"><span class="id" type="definition">V_union</span></a> <span class="id" type="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(769, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(770, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(771, '0_3_119');
      "><span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(772, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(773, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [[<span class="id" type="var">u'</span> <span class="id" type="var">x'</span>] <span class="id" type="var">p</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(774, '0_3_119');
      "><br>
    <span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">u'</span>); <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(775, '0_3_119');
      "><br>
    + <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">x</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">u'</span>)<a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">)^</span></a> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(776, '0_3_119');
      "><br>
      <span class="id" type="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(777, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">x'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(778, '0_3_119');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(779, '0_3_119');
      "><br>
    + <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">u'</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> <span class="id" type="var">v</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">)^</span></a> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(780, '0_3_119');
      "><br>
      <span class="id" type="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(781, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">u'</span>; <span class="id" type="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(782, '0_3_119');
      "><br>
  - <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(783, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">u</span> (<span class="id" type="var">Hx</span>, <span class="id" type="var">Hu</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(784, '0_3_119');
      "><br>
    <span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">u</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> <span class="id" type="var">v</span>) <span class="id" type="var">Hu</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(785, '0_3_119');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(786, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">u'</span> <span class="id" type="var">pu</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(787, '0_3_119');
      "><br>
    <span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">x</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">u'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">x</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">pu</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hx</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(788, '0_3_119');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(789, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">x'</span> <span class="id" type="var">px</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(790, '0_3_119');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(791, '0_3_119');
      "><span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">u'</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">x'</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(792, '0_3_119');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">px</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(793, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(794, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="function"><span class="id" type="lemma">function</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>, <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#V_is_func"><span class="id" type="definition">V_is_func</span></a> <a class="idref" href="HoTT.hit.V.html#u"><span class="id" type="variable">u</span></a> <a class="idref" href="HoTT.hit.V.html#v"><span class="id" type="variable">v</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(795, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(796, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(797, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#V_func"><span class="id" type="definition">V_func</span></a> <span class="id" type="var">u</span> <span class="id" type="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(798, '0_3_119');
      "><br>
  <span class="id" type="tactic">assert</span> (<span class="id" type="var">memb_u</span> : <span class="id" type="var">u</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (@<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">u</span>)) <span class="id" type="tactic">by</span> <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> <span class="id" type="var">u</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(799, '0_3_119');
      "><br>
  <span class="id" type="tactic">assert</span> (<span class="id" type="var">memb_v</span> : <span class="id" type="var">v</span> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (@<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">v</span>)) <span class="id" type="tactic">by</span> <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.hit.V.html#is_valid_presentation"><span class="id" type="definition">is_valid_presentation</span></a> <span class="id" type="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(800, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">phi</span>; <span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(801, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(802, '0_3_119');
      "><span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(803, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(804, '0_3_119');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(805, '0_3_119');
      "><span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(806, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(807, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(808, '0_3_119');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">h</span> <span class="id" type="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(809, '0_3_119');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">z</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a>) <span class="id" type="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(810, '0_3_119');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(811, '0_3_119');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(812, '0_3_119');
      "><span class="id" type="tactic">∃</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">h</span> <span class="id" type="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(813, '0_3_119');
      "><span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(814, '0_3_119');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(815, '0_3_119');
      "><span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">y</span> ⇒ <span class="id" type="var">x</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>) <span class="id" type="var">memb_u</span> <span class="id" type="var">Hx</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(816, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(817, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(818, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(819, '0_3_119');
      "><br>
      <span class="id" type="tactic">intros</span> [<span class="id" type="var">h</span> <span class="id" type="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(820, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(821, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(822, '0_3_119');
      "><br>
      <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>) <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">memb_v</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">h</span> <span class="id" type="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(823, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">y</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>)<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a>) <span class="id" type="var">p_phi</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(824, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(825, '0_3_119');
      "><span class="id" type="tactic">rewrite</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(826, '0_3_119');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">y'</span> (<span class="id" type="var">Hy</span>, <span class="id" type="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(827, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(828, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">h</span> <span class="id" type="var">p_phi</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(829, '0_3_119');
      "><br>
      <span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hy</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(830, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(831, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(832, '0_3_119');
      "><br>
      <span class="id" type="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y'</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(833, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(834, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">a'</span> <span class="id" type="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(835, '0_3_119');
      "><br>
      <span class="id" type="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#path_pair_ord"><span class="id" type="lemma">path_pair_ord</span></a> <span class="id" type="var">p</span>) <span class="id" type="keyword">as</span> (<span class="id" type="var">px</span>, <span class="id" type="var">py</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(836, '0_3_119');
      "><span class="id" type="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" type="projection">fst</span></a> <a class="idref" href="HoTT.hit.V.html#path_pair_ord"><span class="id" type="lemma">path_pair_ord</span></a> <span class="id" type="var">p'</span>) <span class="id" type="keyword">as</span> (<span class="id" type="var">px'</span>, <span class="id" type="var">py'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(837, '0_3_119');
      "><br>
      <span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>)); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(838, '0_3_119');
      "><span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a'</span>));<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(839, '0_3_119');
      "><br>
      <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(840, '0_3_119');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">h</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(841, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" type="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#IsEmbedding_funcofmembers"><span class="id" type="definition">IsEmbedding_funcofmembers</span></a> <span class="id" type="var">a</span> <span class="id" type="var">a'</span> (<span class="id" type="var">px</span> <a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'@'_x"><span class="id" type="notation">@</span></a> <span class="id" type="var">px'</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(842, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intros</span> ((<span class="id" type="var">H1</span>, <span class="id" type="var">H2</span>), <span class="id" type="var">H3</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(843, '0_3_119');
      "><span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(844, '0_3_119');
      "><br>
    <span class="id" type="tactic">assert</span> (<span class="id" type="var">h</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">u</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a>, <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">b</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">v</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">b</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(845, '0_3_119');
      "><br>
    { <span class="id" type="tactic">intro</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(846, '0_3_119');
      "><span class="id" type="tactic">pose</span> (<span class="id" type="var">x</span> := <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(847, '0_3_119');
      "><br>
      <span class="id" type="var">transparent</span> <span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">y</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(848, '0_3_119');
      "><br>
      <span class="id" type="tactic">refine</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" type="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">y</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <span class="id" type="var">y</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a> <span class="id" type="var">_</span><br>
                                 (<span class="id" type="var">H2</span> <span class="id" type="var">x</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">x</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">memb_u</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(849, '0_3_119');
      "><br>
      { <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#hprop_allpath"><span class="id" type="lemma">hprop_allpath</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(850, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">y</span> (<span class="id" type="var">H1_y</span>, <span class="id" type="var">H2_y</span>)] [<span class="id" type="var">y'</span> (<span class="id" type="var">H1_y'</span>, <span class="id" type="var">H2_y'</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(851, '0_3_119');
      "><br>
        <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.types.Sigma.html#path_sigma_uncurried"><span class="id" type="definition">path_sigma_uncurried</span></a>; <span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(852, '0_3_119');
      "><br>
        <span class="id" type="tactic">∃</span> (<span class="id" type="var">H3</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">y'</span> <a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">H2_y</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">H2_y'</span><a class="idref" href="Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(853, '0_3_119');
      "><br>
        <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.HProp.html#path_ishprop"><span class="id" type="lemma">path_ishprop</span></a>. }<br>
      <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> (<span class="id" type="var">H1_y</span>, <span class="id" type="var">H2_y</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(854, '0_3_119');
      "><br>
      <span class="id" type="tactic">destruct</span> (@<a class="idref" href="HoTT.hit.Truncations.html#untrunc_istrunc"><span class="id" type="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a> <span class="id" type="var">_</span> (<a class="idref" href="HoTT.hit.V.html#IsEmbedding_funcofmembers"><span class="id" type="definition">IsEmbedding_funcofmembers</span></a> <span class="id" type="var">y</span>) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <span class="id" type="var">y</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>) <span class="id" type="var">memb_v</span> <span class="id" type="var">H1_y</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">b</span> <span class="id" type="var">Hb</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(855, '0_3_119');
      "><br>
      <span class="id" type="tactic">∃</span> <span class="id" type="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(856, '0_3_119');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><span class="id" type="var">x</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span>) <span class="id" type="var">Hb</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">H2_y</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(857, '0_3_119');
      "><br>
    <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> (<span class="id" type="var">h</span> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(858, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.V.html#extensionality"><span class="id" type="lemma">extensionality</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(859, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(860, '0_3_119');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(861, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(862, '0_3_119');
      "><span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">Ha</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(863, '0_3_119');
      "><br>
      <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span>) <span class="id" type="var">Ha</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(864, '0_3_119');
      "><br>
    + <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(865, '0_3_119');
      "><span class="id" type="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(866, '0_3_119');
      "><br>
      <span class="id" type="tactic">generalize</span> (<span class="id" type="var">H1</span> <span class="id" type="var">z</span> <span class="id" type="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(867, '0_3_119');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(868, '0_3_119');
      "><span class="id" type="tactic">intros</span> [(<span class="id" type="var">a</span>,<span class="id" type="var">b</span>) <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(869, '0_3_119');
      "><span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(870, '0_3_119');
      "><br>
      <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(871, '0_3_119');
      "><span class="id" type="tactic">transitivity</span> (<a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">[</span></a><a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">a</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">,</span></a> <a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">b</span><a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:'%5B'_x_','_x_'%5D'"><span class="id" type="notation">]</span></a>); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(872, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(873, '0_3_119');
      "><br>
      <span class="id" type="tactic">apply</span> <span class="id" type="var">H3</span> <span class="id" type="keyword">with</span> (<a class="idref" href="HoTT.hit.V.html#func_of_members"><span class="id" type="definition">func_of_members</span></a> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(874, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(875, '0_3_119');
      "><br>
      <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" type="abbreviation">pr2</span></a> (<span class="id" type="var">h</span> <span class="id" type="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(876, '0_3_119');
      "><br>
      <span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <span class="id" type="var">phi</span>) <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(877, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(878, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="replacement"><span class="id" type="lemma">replacement</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">r</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>),<br>
  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">y</span>, <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> ⇒ <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#r"><span class="id" type="variable">r</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.hit.V.html#y"><span class="id" type="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(879, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(880, '0_3_119');
      "><br>
  <span class="id" type="tactic">intro</span> <span class="id" type="var">r</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(881, '0_3_119');
      "><span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(882, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(883, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(884, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="var">r</span> <a class="idref" href="HoTT.Basics.Overture.html#:function_scope:x_'o'_x"><span class="id" type="notation">o</span></a> <span class="id" type="var">f</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(885, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(886, '0_3_119');
      "><br>
  - <span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(887, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(888, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(889, '0_3_119');
      "><span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(890, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">auto</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(891, '0_3_119');
      "><span class="id" type="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(892, '0_3_119');
      "><br>
  - <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(893, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">z</span> [<span class="id" type="var">h</span> <span class="id" type="var">p</span>]]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(894, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(895, '0_3_119');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(896, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(897, '0_3_119');
      "><span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(898, '0_3_119');
      "><span class="id" type="tactic">transitivity</span> (<span class="id" type="var">r</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(899, '0_3_119');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" type="definition">ap</span></a> <span class="id" type="var">r</span> <span class="id" type="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(900, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(901, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">Lemma</span> <a name="separation"><span class="id" type="lemma">separation</span></a> (<span class="id" type="var">C</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'-&gt;'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.HProp.html#hProp"><span class="id" type="record">hProp</span></a>) : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> : <a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.V"><span class="id" type="inductive">V</span></a>,<br>
  <a class="idref" href="HoTT.hit.Truncations.html#hexists"><span class="id" type="definition">hexists</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">w</span> ⇒ <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>, <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#w"><span class="id" type="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'&lt;-&gt;'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="HoTT.hit.V.html#AssumingUA.:set_scope:x_'%E2%88%88'_x"><span class="id" type="notation">∈</span></a> <a class="idref" href="HoTT.hit.V.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="HoTT.hit.V.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="HoTT.hit.V.html#x"><span class="id" type="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#:type_scope:x_'*'_x"><span class="id" type="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(902, '0_3_119');
      "><br>
<span class="id" type="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(903, '0_3_119');
      "><br>
  <span class="id" type="tactic">refine</span> (<a class="idref" href="HoTT.hit.V.html#V_rect_hprop"><span class="id" type="definition">V_rect_hprop</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(904, '0_3_119');
      "><br>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">f</span> <span class="id" type="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(905, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(906, '0_3_119');
      "><span class="id" type="tactic">∃</span> (<a class="idref" href="HoTT.hit.V.html#CumulativeHierarchy.set"><span class="id" type="constructor">set</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">{</span></a><span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">:</span></a> <span class="id" type="var">A</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="var">C</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>)<a class="idref" href="Coq.Init.Specif.html#:type_scope:'%7B'_x_':'_x_'&amp;'_x_'%7D'"><span class="id" type="notation">}</span></a> ⇒ <span class="id" type="var">f</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" type="abbreviation">pr1</span></a> <a class="idref" href="HoTT.hit.V.html#z"><span class="id" type="variable">z</span></a>))). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(907, '0_3_119');
      "><span class="id" type="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(908, '0_3_119');
      "><br>
  - <span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc_rect_nondep"><span class="id" type="definition">Trunc_rect_nondep</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(909, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [[<span class="id" type="var">a</span> <span class="id" type="var">h</span>] <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(910, '0_3_119');
      "><span class="id" type="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(911, '0_3_119');
      "><span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.hit.Truncations.html#Trunc.tr"><span class="id" type="constructor">tr</span></a>; <span class="id" type="tactic">∃</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">assumption</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(912, '0_3_119');
      "><span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">C</span> <span class="id" type="var">p</span> <span class="id" type="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(913, '0_3_119');
      "><br>
  - <span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(914, '0_3_119');
      "><span class="id" type="tactic">generalize</span> <span class="id" type="var">H1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(915, '0_3_119');
      "><span class="id" type="tactic">apply</span> (<a class="idref" href="HoTT.hit.Truncations.html#Trunc_functor"><span class="id" type="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#:trunc_scope:'-1'"><span class="id" type="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(916, '0_3_119');
      "><br>
    <span class="id" type="tactic">intros</span> [<span class="id" type="var">a</span> <span class="id" type="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(917, '0_3_119');
      "><span class="id" type="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" type="definition">transport</span></a> <span class="id" type="var">C</span> <span class="id" type="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#:path_scope:x_'%5E'"><span class="id" type="notation">^</span></a> <span class="id" type="var">H2</span><a class="idref" href="HoTT.Basics.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(918, '0_3_119');
      "><span class="id" type="tactic">exact</span> <span class="id" type="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(919, '0_3_119');
      "><br>
<span class="id" type="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(920, '0_3_119');
      "><br>
<br>
<span class="id" type="keyword">End</span> <a class="idref" href="HoTT.hit.V.html#AssumingUA"><span class="id" type="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(921, '0_3_119');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
