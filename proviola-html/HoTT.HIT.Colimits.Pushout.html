<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "1 subgoal, subgoal 1 (ID 1)	  	  ============================	  graph		(dependent evars:)		";
            responses[i]=data;
          

            i = 30;
            data = "1 subgoal, subgoal 1 (ID 1)	  	  ============================	  graph		(dependent evars:)		";
            responses[i]=data;
          

            i = 31;
            data = "2 subgoals, subgoal 1 (ID 2)	  	  ============================	  Type		subgoal 2 (ID 3) is:	 ?Goal -> ?Goal -> Type	(dependent evars: ?X2 open,)		";
            responses[i]=data;
          

            i = 32;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 2)	  	  ============================	  Type		(dependent evars: ?X2 open,)		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 3)		subgoal 1 (ID 3) is:	 Unit + Bool -> Unit + Bool -> Type	(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 33;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 3)	  	  ============================	  Unit + Bool -> Unit + Bool -> Type		(dependent evars: ?X2 using ,)		4 focused subgoals	(unfocused: 0), subgoal 1 (ID 15)	  	  i, j : Unit	  ============================	  Type		subgoal 2 (ID 16) is:	 Type	subgoal 3 (ID 23) is:	 Type	subgoal 4 (ID 24) is:	 Type	(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 34;
            data = "3 focused subgoals	(unfocused: 0), subgoal 1 (ID 16)	  	  i : Unit	  j : Bool	  ============================	  Type		subgoal 2 (ID 23) is:	 Type	subgoal 3 (ID 24) is:	 Type	(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 35;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 23)	  	  i : Bool	  j : Unit	  ============================	  Type		subgoal 2 (ID 24) is:	 Type	(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 36;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 24)	  	  i, j : Bool	  ============================	  Type		(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 37;
            data = "No more subgoals.	(dependent evars: ?X2 using ,)		";
            responses[i]=data;
          

            i = 38;
            data = "<infomsg>PO_graph is defined</infomsg>	";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "<infomsg>A is assumed</infomsg>	<infomsg>B is assumed</infomsg>	<infomsg>C is assumed</infomsg>	";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "1 subgoal, subgoal 1 (ID 4)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  diagram PO_graph		(dependent evars:)		";
            responses[i]=data;
          

            i = 46;
            data = "1 subgoal, subgoal 1 (ID 4)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  diagram PO_graph		(dependent evars:)		";
            responses[i]=data;
          

            i = 47;
            data = "2 subgoals, subgoal 1 (ID 6)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  PO_graph -> Type		subgoal 2 (ID 7) is:	 forall i j : PO_graph, PO_graph i j -> ?Goal i -> ?Goal j	(dependent evars: ?X5 using , ?X6 open,)		";
            responses[i]=data;
          

            i = 48;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 6)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  PO_graph -> Type		(dependent evars: ?X5 using , ?X6 open,)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 13)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  ============================	  Type		subgoal 2 (ID 14) is:	 Type	(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 open, ?X14 open,)		";
            responses[i]=data;
          

            i = 49;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 14)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Bool	  ============================	  Type		(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 open,)		";
            responses[i]=data;
          

            i = 50;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 7)		subgoal 1 (ID 7) is:	 forall i j : PO_graph,	 PO_graph i j ->	 (fun X : PO_graph =>	  match X with	  | inl _ => A	  | inr true => B	  | inr false => C	  end) i ->	 (fun X : PO_graph =>	  match X with	  | inl _ => A	  | inr true => B	  | inr false => C	  end) j	(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		";
            responses[i]=data;
          

            i = 51;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 7)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  forall i j : PO_graph,	  PO_graph i j ->	  (fun X : PO_graph =>	   match X with	   | inl _ => A	   | inr true => B	   | inr false => C	   end) i ->	  (fun X : PO_graph =>	   match X with	   | inl _ => A	   | inr true => B	   | inr false => C	   end) j		(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 41)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  j : Bool	  u : PO_graph (inl i) (inr j)	  ============================	  A -> if j then B else C		(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		";
            responses[i]=data;
          

            i = 52;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 56)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  u : PO_graph (inl i) (inr true)	  ============================	  A -> B		subgoal 2 (ID 57) is:	 A -> C	(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		";
            responses[i]=data;
          

            i = 53;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 57)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  u : PO_graph (inl i) (inr false)	  ============================	  A -> C		(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		";
            responses[i]=data;
          

            i = 54;
            data = "No more subgoals.	(dependent evars: ?X5 using , ?X6 using ?X8 ?X5 , ?X8 using ?X10 ?X9 , ?X9 using ?X11 , ?X10 using ?X12 , ?X11 using ?X13 , ?X12 using ?X14 , ?X13 using , ?X14 using ,)		";
            responses[i]=data;
          

            i = 55;
            data = "<infomsg>span is defined</infomsg>	";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal, subgoal 1 (ID 32)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  cocone (span f g) Z		(dependent evars:)		";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoal, subgoal 1 (ID 32)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  cocone (span f g) Z		(dependent evars:)		";
            responses[i]=data;
          

            i = 58;
            data = "2 subgoals, subgoal 1 (ID 34)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : PO_graph, (span f g) i -> Z		subgoal 2 (ID 35) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	 ?q j (((span f g) _f g0) x) = ?q i x	(dependent evars: ?X34 open,)		";
            responses[i]=data;
          

            i = 59;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 34)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : PO_graph, (span f g) i -> Z		(dependent evars: ?X34 open,)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 41)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  Unit -> A -> Z		subgoal 2 (ID 42) is:	 forall b : Bool, (if b then B else C) -> Z	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 open, ?X42 open,)		";
            responses[i]=data;
          

            i = 60;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 44)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  A -> Z		subgoal 2 (ID 42) is:	 forall b : Bool, (if b then B else C) -> Z	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 open, ?X43 using ?X44 , ?X44 open,)		";
            responses[i]=data;
          

            i = 61;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 42)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall b : Bool, (if b then B else C) -> Z		(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 open, ?X43 using ?X44 , ?X44 using ,)		";
            responses[i]=data;
          

            i = 62;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 57)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  B -> Z		subgoal 2 (ID 58) is:	 C -> Z	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 open, ?X58 open,)		";
            responses[i]=data;
          

            i = 63;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 58)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  C -> Z		(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 open,)		";
            responses[i]=data;
          

            i = 64;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 35)		subgoal 1 (ID 35) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	 (fun i0 : PO_graph =>	  match i0 as s return ((span f g) s -> Z) with	  | inl _ => inr' o g	  | inr b =>	      if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr'	  end) j (((span f g) _f g0) x) =	 (fun i0 : PO_graph =>	  match i0 as s return ((span f g) s -> Z) with	  | inl _ => inr' o g	  | inr b =>	      if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr'	  end) i x	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		";
            responses[i]=data;
          

            i = 65;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 35)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	  (fun i0 : PO_graph =>	   match i0 as s return ((span f g) s -> Z) with	   | inl _ => inr' o g	   | inr b =>	       if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr'	   end) j (((span f g) _f g0) x) =	  (fun i0 : PO_graph =>	   match i0 as s return ((span f g) s -> Z) with	   | inl _ => inr' o g	   | inr b =>	       if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr'	   end) i x		(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 86)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  b : Bool	  ============================	  forall x : A,	  (if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr')	    ((if b as b0 return (Unit -> A -> if b0 then B else C)	      then unit_name f	      else unit_name g) tt x) = inr' (g x)		(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		";
            responses[i]=data;
          

            i = 66;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 90)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  forall x : A, inl' (f x) = inr' (g x)		subgoal 2 (ID 91) is:	 forall x : A, inr' (g x) = inr' (g x)	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		";
            responses[i]=data;
          

            i = 67;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 91)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  forall x : A, inr' (g x) = inr' (g x)		(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		";
            responses[i]=data;
          

            i = 68;
            data = "No more subgoals.	(dependent evars: ?X34 using ?X36 , ?X36 using ?X38 ?X37 , ?X37 using ?X39 , ?X38 using ?X40 , ?X39 using ?X41 , ?X40 using ?X42 , ?X41 using ?X43 , ?X42 using ?X54 , ?X43 using ?X44 , ?X44 using , ?X54 using ?X56 ?X55 , ?X55 using ?X57 , ?X56 using ?X58 , ?X57 using , ?X58 using ,)		";
            responses[i]=data;
          

            i = 69;
            data = "<infomsg>Build_span_cocone is defined</infomsg>	";
            responses[i]=data;
          

            i = 70;
            data = "<infomsg>pol' is defined</infomsg>	";
            responses[i]=data;
          

            i = 71;
            data = "<infomsg>por' is defined</infomsg>	";
            responses[i]=data;
          

            i = 72;
            data = "<infomsg>popp' is defined</infomsg>	";
            responses[i]=data;
          

            i = 73;
            data = "<infomsg>is_PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 74;
            data = "<infomsg>PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 75;
            data = "<infomsg>f is assumed</infomsg>	<infomsg>g is assumed</infomsg>	";
            responses[i]=data;
          

            i = 76;
            data = "<infomsg>pol is defined</infomsg>	";
            responses[i]=data;
          

            i = 77;
            data = "<infomsg>por is defined</infomsg>	";
            responses[i]=data;
          

            i = 78;
            data = "<infomsg>popp is defined</infomsg>	";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          

            i = 87;
            data = "1 subgoal, subgoal 1 (ID 135)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall w : PO f g, P w		(dependent evars:)		";
            responses[i]=data;
          

            i = 88;
            data = "1 subgoal, subgoal 1 (ID 135)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall w : PO f g, P w		(dependent evars:)		";
            responses[i]=data;
          

            i = 89;
            data = "2 subgoals, subgoal 1 (ID 138)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : PO_graph) (x : (span f g) i), P (colim i x)		subgoal 2 (ID 139) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	 transport P (colimp i j g0 x) (?Goal j (((span f g) _f g0) x)) = ?Goal i x	(dependent evars: ?X136 using , ?X137 using , ?X138 open,)		";
            responses[i]=data;
          

            i = 90;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 138)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : PO_graph) (x : (span f g) i), P (colim i x)		(dependent evars: ?X136 using , ?X137 using , ?X138 open,)		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 145)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (u : Unit) (x : A), P (colim (inl u) x)		subgoal 2 (ID 146) is:	 forall (b : Bool) (x : if b then B else C), P (colim (inr b) x)	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 open, ?X146 open,)		";
            responses[i]=data;
          

            i = 91;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 150)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  P (colim (inl tt) x)		subgoal 2 (ID 146) is:	 forall (b : Bool) (x : if b then B else C), P (colim (inr b) x)	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 open, ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 open,)		";
            responses[i]=data;
          

            i = 92;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 146)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (b : Bool) (x : if b then B else C), P (colim (inr b) x)		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 open, ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using ,)		";
            responses[i]=data;
          

            i = 93;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 165)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : B, P (colim (inr true) x)		subgoal 2 (ID 166) is:	 forall x : C, P (colim (inr false) x)	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 open, ?X166 open,)		";
            responses[i]=data;
          

            i = 94;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 166)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : C, P (colim (inr false) x)		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 open,)		";
            responses[i]=data;
          

            i = 95;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 139)		subgoal 1 (ID 139) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	 transport P (colimp i j g0 x)	   ((fun i0 : PO_graph =>	     match i0 as s return (forall x0 : (span f g) s, P (colim s x0)) with	     | inl u =>	         match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	         | tt =>	             fun x0 : A =>	             transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	         end	     | inr b =>	         if b as b0	          return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	         then l'	         else r'	     end) j (((span f g) _f g0) x)) =	 (fun i0 : PO_graph =>	  match i0 as s return (forall x0 : (span f g) s, P (colim s x0)) with	  | inl u =>	      match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	      | tt =>	          fun x0 : A =>	          transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	      end	  | inr b =>	      if b as b0	       return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	      then l'	      else r'	  end) i x	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 96;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 139)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	  transport P (colimp i j g0 x)	    ((fun i0 : PO_graph =>	      match i0 as s return (forall x0 : (span f g) s, P (colim s x0)) with	      | inl u =>	          match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	          | tt =>	              fun x0 : A =>	              transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	          end	      | inr b =>	          if b as b0	           return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	          then l'	          else r'	      end) j (((span f g) _f g0) x)) =	  (fun i0 : PO_graph =>	   match i0 as s return (forall x0 : (span f g) s, P (colim s x0)) with	   | inl u =>	       match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	       | tt =>	           fun x0 : A =>	           transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	       end	   | inr b =>	       if b as b0	        return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	       then l'	       else r'	   end) i x		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 194)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  u : Unit	  b : Bool	  ============================	  forall x : A,	  transport P (colimp (inl u) (inr b) tt x)	    ((if b as b0	       return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	      then l'	      else r')	       ((if b as b0 return (Unit -> A -> if b0 then B else C)	         then unit_name f	         else unit_name g) tt x)) =	  match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	  | tt =>	      fun x0 : A =>	      transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	  end x		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 97;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 203)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))		subgoal 2 (ID 204) is:	 forall x : A,	 transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	 transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 98;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 204)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 99;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 207)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 100;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 208)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  transport P (colimp (inl tt) (inr false) tt a) (r' (g a)) =	  transport P (colimp (inl tt) (inr true) tt a) (l' (f a))		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 101;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 210)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P (colimp (inl tt) (inr false) tt a)^	    (transport P (colimp (inl tt) (inr true) tt a) (l' (f a)))		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using ,)		";
            responses[i]=data;
          

            i = 102;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P	    (colimp (inl tt) (inr true) tt a @ (colimp (inl tt) (inr false) tt a)^)	    (l' (f a))		(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using , ?X211 using , ?X212 using ?X252 , ?X252 using ,)		";
            responses[i]=data;
          

            i = 103;
            data = "No more subgoals.	(dependent evars: ?X136 using , ?X137 using , ?X138 using ?X140 ?X136 , ?X140 using ?X142 ?X141 , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using ?X145 , ?X144 using ?X146 , ?X145 using ?X147 , ?X146 using ?X160 , ?X147 using ?X148 , ?X148 using ?X149 , ?X149 using ?X150 , ?X150 using , ?X160 using ?X162 ?X161 , ?X161 using ?X163 , ?X162 using ?X164 , ?X163 using ?X165 , ?X164 using ?X166 , ?X165 using , ?X166 using , ?X211 using , ?X212 using ?X252 , ?X252 using ,)		";
            responses[i]=data;
          

            i = 104;
            data = "<infomsg>PO_ind is defined</infomsg>	";
            responses[i]=data;
          

            i = 105;
            data = "1 subgoal, subgoal 1 (ID 154)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A, apD (PO_ind P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 106;
            data = "1 subgoal, subgoal 1 (ID 154)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A, apD (PO_ind P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 107;
            data = "1 subgoal, subgoal 1 (ID 155)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 108;
            data = "2 focused subgoals	(shelved: 1), subgoal 1 (ID 195)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = ?Goal		subgoal 2 (ID 196) is:	 ?Goal = pp' x	(dependent evars: ?X156 using , ?X157 open,)		";
            responses[i]=data;
          

            i = 109;
            data = "1 subgoal, subgoal 1 (ID 196)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 110;
            data = "2 subgoals, subgoal 1 (ID 211)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1		subgoal 2 (ID 212) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 111;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 211)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1		(dependent evars: ?X156 using , ?X157 using ,)		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 213)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : (span f g) s, P (colim s x0)) with	        | inl u =>	            match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	            | tt =>	                fun x0 : A =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	            then l'	            else r'	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) (x0 : (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : A =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : if b0 then B else C,	                        P (colim (inr b0) x1))	                    then l'	                    else r'	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                 then l'	                 else r'	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) (x0 : (span f g) (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : if b0 then B else C,	                            P (colim (inr b0) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : if b0 then B else C,	                             P (colim (inr b0) x1))	                         then l'	                         else r') (((span f g) _f u0) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then l'	                             else r')	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then l'	                                else r')	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) (x0 : (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : if b1 then B else C,	                            P (colim (inr b1) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                  then l'	                  else r') x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : if b0 then B else C,	                          P (colim (inr b0) x1))	                      then l'	                      else r') x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : if b1 then B else C,	                             P (colim (inr b1) x1))	                         then l'	                         else r') (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : if b1 then B else C,	                          P (colim (inr b1) x1))	                      then l'	                      else r') x0)	                with	                end	            end	        end)) (colimp (inl tt) (inr true) tt x) = 1		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 212)		subgoal 1 (ID 212) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	(dependent evars: ?X156 using , ?X157 using ,)		1 subgoal, subgoal 1 (ID 212)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  X : apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		1 subgoal, subgoal 1 (ID 220)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  X : apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^) 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoal, subgoal 1 (ID 221)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^) 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 114;
            data = "1 subgoal, subgoal 1 (ID 222)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @ 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 115;
            data = "1 subgoal, subgoal 1 (ID 226)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoal, subgoal 1 (ID 232)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (PO_ind P l' r' pp' (colim (inl tt) x))	    (PO_ind P l' r' pp' (colim (inr false) (g x)))	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x))^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoal, subgoal 1 (ID 235)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : (span f g) s, P (colim s x0)) with	        | inl u =>	            match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	            | tt =>	                fun x0 : A =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	            then l'	            else r'	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) (x0 : (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : A =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : if b0 then B else C,	                        P (colim (inr b0) x1))	                    then l'	                    else r'	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                 then l'	                 else r'	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) (x0 : (span f g) (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : if b0 then B else C,	                            P (colim (inr b0) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : if b0 then B else C,	                             P (colim (inr b0) x1))	                         then l'	                         else r') (((span f g) _f u0) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then l'	                             else r')	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then l'	                                else r')	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) (x0 : (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : if b1 then B else C,	                            P (colim (inr b1) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                  then l'	                  else r') x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : if b0 then B else C,	                          P (colim (inr b0) x1))	                      then l'	                      else r') x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : if b1 then B else C,	                             P (colim (inr b1) x1))	                         then l'	                         else r') (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : if b1 then B else C,	                          P (colim (inr b1) x1))	                      then l'	                      else r') x0)	                with	                end	            end	        end) (colim (inl tt) x))	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : (span f g) s, P (colim s x0)) with	        | inl u =>	            match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	            | tt =>	                fun x0 : A =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	            then l'	            else r'	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) (x0 : (span f g) s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : A =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : if b0 then B else C,	                        P (colim (inr b0) x1))	                    then l'	                    else r'	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                 then l'	                 else r'	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) (x0 : (span f g) (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : if b0 then B else C,	                            P (colim (inr b0) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : A =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : (span f g) (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : if b0 then B else C,	                             P (colim (inr b0) x1))	                         then l'	                         else r') (((span f g) _f u0) x0)) =	                     match	                       u as u1 return (forall x1 : A, P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : A =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then l'	                             else r')	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then l'	                                else r')	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) (x0 : (span f g) (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : (span f g) s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : if b1 then B else C,	                            P (colim (inr b1) x1))	                        then l'	                        else r'	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : if b0 then B else C, P (colim (inr b0) x1))	                  then l'	                  else r') x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return (forall x1 : A, P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : if b0 then B else C,	                          P (colim (inr b0) x1))	                      then l'	                      else r') x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : (span f g) (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : if b1 then B else C,	                             P (colim (inr b1) x1))	                         then l'	                         else r') (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : if b1 then B else C,	                          P (colim (inr b1) x1))	                      then l'	                      else r') x0)	                with	                end	            end	        end) (colim (inr false) (g x)))	    (apD	       (colimit_ind P	          (fun i : PO_graph =>	           match	             i as s return (forall x0 : (span f g) s, P (colim s x0))	           with	           | inl u =>	               match	                 u as u0 return (forall x0 : A, P (colim (inl u0) x0))	               with	               | tt =>	                   fun x0 : A =>	                   transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	               end	           | inr b =>	               if b as b0	                return	                  (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	               then l'	               else r'	           end)	          (fun i : PO_graph =>	           match	             i as s	             return	               (forall (j : PO_graph) (g0 : PO_graph s j) (x0 : (span f g) s),	                transport P (colimp s j g0 x0)	                  (match	                     j as s0	                     return (forall x1 : (span f g) s0, P (colim s0 x1))	                   with	                   | inl u =>	                       match	                         u as u0	                         return (forall x1 : A, P (colim (inl u0) x1))	                       with	                       | tt =>	                           fun x1 : A =>	                           transport P (colimp (inl tt) (inr true) tt x1)	                             (l' (f x1))	                       end	                   | inr b =>	                       if b as b0	                        return	                          (forall x1 : if b0 then B else C,	                           P (colim (inr b0) x1))	                       then l'	                       else r'	                   end (((span f g) _f g0) x0)) =	                match	                  s as s0 return (forall x1 : (span f g) s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : A =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : if b0 then B else C,	                        P (colim (inr b0) x1))	                    then l'	                    else r'	                end x0)	           with	           | inl u =>	               fun j : PO_graph =>	               match	                 j as s	                 return	                   (forall (g0 : PO_graph (inl u) s)	                      (x0 : (span f g) (inl u)),	                    transport P (colimp (inl u) s g0 x0)	                      (match	                         s as s0	                         return (forall x1 : (span f g) s0, P (colim s0 x1))	                       with	                       | inl u0 =>	                           match	                             u0 as u1	                             return (forall x1 : A, P (colim (inl u1) x1))	                           with	                           | tt =>	                               fun x1 : A =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b =>	                           if b as b0	                            return	                              (forall x1 : if b0 then B else C,	                               P (colim (inr b0) x1))	                           then l'	                           else r'	                       end (((span f g) _f g0) x0)) =	                    match	                      u as u0 return (forall x1 : A, P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : A =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end x0)	               with	               | inl u0 =>	                   fun g0 : PO_graph (inl u) (inl u0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : (span f g) (inl u),	                        transport P (colimp (inl u) (inl u0) e x0)	                          (match	                             u0 as u1	                             return (forall x1 : A, P (colim (inl u1) x1))	                           with	                           | tt =>	                               fun x1 : A =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (((span f g) _f e) x0)) =	                        match	                          u as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   end	               | inr b =>	                   fun g0 : PO_graph (inl u) (inr b) =>	                   match	                     g0 as u0	                     return	                       (forall x0 : (span f g) (inl u),	                        transport P (colimp (inl u) (inr b) u0 x0)	                          ((if b as b0	                             return	                               (forall x1 : if b0 then B else C,	                                P (colim (inr b0) x1))	                            then l'	                            else r') (((span f g) _f u0) x0)) =	                        match	                          u as u1	                          return (forall x1 : A, P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : A =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   | tt =>	                       match	                         u as u0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl u0) (inr b) tt x0)	                              ((if b as b0	                                 return	                                   (forall x1 : if b0 then B else C,	                                    P (colim (inr b0) x1))	                                then l'	                                else r')	                                 ((if b as b0	                                    return (Unit -> A -> if b0 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            match	                              u0 as u1	                              return (forall x1 : A, P (colim (inl u1) x1))	                            with	                            | tt =>	                                fun x1 : A =>	                                transport P	                                  (colimp (inl tt) (inr true) tt x1)	                                  (l' (f x1))	                            end x0)	                       with	                       | tt =>	                           if b as b0	                            return	                              (forall x0 : A,	                               transport P (colimp (inl tt) (inr b0) tt x0)	                                 ((if b0 as b1	                                    return	                                      (forall x1 : if b1 then B else C,	                                       P (colim (inr b1) x1))	                                   then l'	                                   else r')	                                    ((if b0 as b1	                                       return	                                         (Unit -> A -> if b1 then B else C)	                                      then unit_name f	                                      else unit_name g) tt x0)) =	                               transport P (colimp (inl tt) (inr true) tt x0)	                                 (l' (f x0)))	                           then fun x0 : A => 1	                           else	                            fun a : A =>	                            moveR_transport_p P	                              (colimp (inl tt) (inr false) tt a) 	                              (r' (g a))	                              (transport P (colimp (inl tt) (inr true) tt a)	                                 (l' (f a)))	                              ((pp' a)^ @	                               transport_pp P	                                 (colimp (inl tt) (inr true) tt a)	                                 (colimp (inl tt) (inr false) tt a)^	                                 (l' (f a)))	                       end	                   end	               end	           | inr b =>	               fun j : PO_graph =>	               match	                 j as s	                 return	                   (forall (g0 : PO_graph (inr b) s)	                      (x0 : (span f g) (inr b)),	                    transport P (colimp (inr b) s g0 x0)	                      (match	                         s as s0	                         return (forall x1 : (span f g) s0, P (colim s0 x1))	                       with	                       | inl u =>	                           match	                             u as u0	                             return (forall x1 : A, P (colim (inl u0) x1))	                           with	                           | tt =>	                               fun x1 : A =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b0 =>	                           if b0 as b1	                            return	                              (forall x1 : if b1 then B else C,	                               P (colim (inr b1) x1))	                           then l'	                           else r'	                       end (((span f g) _f g0) x0)) =	                    (if b as b0	                      return	                        (forall x1 : if b0 then B else C,	                         P (colim (inr b0) x1))	                     then l'	                     else r') x0)	               with	               | inl u =>	                   fun g0 : PO_graph (inr b) (inl u) =>	                   match	                     g0 as e	                     return	                       (forall x0 : (span f g) (inr b),	                        transport P (colimp (inr b) (inl u) e x0)	                          (match	                             u as u0	                             return (forall x1 : A, P (colim (inl u0) x1))	                           with	                           | tt =>	                               fun x1 : A =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (((span f g) _f e) x0)) =	                        (if b as b0	                          return	                            (forall x1 : if b0 then B else C,	                             P (colim (inr b0) x1))	                         then l'	                         else r') x0)	                   with	                   end	               | inr b0 =>	                   fun g0 : PO_graph (inr b) (inr b0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : (span f g) (inr b),	                        transport P (colimp (inr b) (inr b0) e x0)	                          ((if b0 as b1	                             return	                               (forall x1 : if b1 then B else C,	                                P (colim (inr b1) x1))	                            then l'	                            else r') (((span f g) _f e) x0)) =	                        (if b as b1	                          return	                            (forall x1 : if b1 then B else C,	                             P (colim (inr b1) x1))	                         then l'	                         else r') x0)	                   with	                   end	               end	           end)) (colimp (inl tt) (inr false) tt x))^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoal, subgoal 1 (ID 249)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       ((pp' x)^ @	        transport_pp P (colimp (inl tt) (inr true) tt x)	          (colimp (inl tt) (inr false) tt x)^ (l' (f x))))^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoal, subgoal 1 (ID 253)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : r' (g x) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : transport P	        (colimp (inl tt) (inr true) tt x @	         (colimp (inl tt) (inr false) tt x)^) (l' (f x)) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       q)^ = pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 120;
            data = "1 subgoal, subgoal 1 (ID 255)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : r' (g x) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : transport P	        (colimp (inl tt) (inr true) tt x @	         (colimp (inl tt) (inr false) tt x)^) (l' (f x)) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveL_transport_p P (colimp (inl tt) (inr false) tt x)	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	       (r' (g x)) q^) = pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 121;
            data = "1 subgoal, subgoal 1 (ID 258)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : r' (g x) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : transport P	        (colimp (inl tt) (inr true) tt x @	         (colimp (inl tt) (inr false) tt x)^) (l' (f x)) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @ q^ = pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 122;
            data = "1 subgoal, subgoal 1 (ID 262)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : transport P	        (colimp (inl tt) (inr true) tt x @	         (colimp (inl tt) (inr false) tt x)^) (l' (f x)) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((pp' x)^ @	   transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ = 	  pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 123;
            data = "1 subgoal, subgoal 1 (ID 267)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	    : transport P	        (colimp (inl tt) (inr true) tt x @	         (colimp (inl tt) (inr false) tt x)^) (l' (f x)) =	      transport P (colimp (inl tt) (inr false) tt x)^	        (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((transport_pp P (colimp (inl tt) (inr true) tt x)	      (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ @ 	   ((pp' x)^)^) = pp' x		(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 124;
            data = "No more subgoals.	(dependent evars: ?X156 using , ?X157 using ,)		";
            responses[i]=data;
          

            i = 125;
            data = "<infomsg>PO_ind_beta_pp is defined</infomsg>	";
            responses[i]=data;
          

            i = 126;
            data = "<infomsg>PO_rec is defined</infomsg>	";
            responses[i]=data;
          

            i = 127;
            data = "1 subgoal, subgoal 1 (ID 210)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  ============================	  forall x : A, ap (PO_rec P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 128;
            data = "1 subgoal, subgoal 1 (ID 210)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  ============================	  forall x : A, ap (PO_rec P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 129;
            data = "1 subgoal, subgoal 1 (ID 211)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 130;
            data = "1 subgoal, subgoal 1 (ID 222)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) =	      qq (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 131;
            data = "1 subgoal, subgoal 1 (ID 233)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) =	      qq (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) =	       qq (Build_span_cocone l' r' pp') (inl tt) (inr false) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 132;
            data = "1 subgoal, subgoal 1 (ID 247)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp')	    (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^) =	  pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 133;
            data = "1 subgoal, subgoal 1 (ID 273)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr true) tt x) @	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x		(dependent evars:)		";
            responses[i]=data;
          

            i = 134;
            data = "1 subgoal, subgoal 1 (ID 295)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr true) tt x) @	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x @ 1		(dependent evars:)		";
            responses[i]=data;
          

            i = 135;
            data = "1 subgoal, subgoal 1 (ID 317)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 1		(dependent evars:)		";
            responses[i]=data;
          

            i = 136;
            data = "1 subgoal, subgoal 1 (ID 340)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ =	  (ap (colimit_rec P (Build_span_cocone l' r' pp'))	     (colimp (inl tt) (inr false) tt x))^		(dependent evars:)		";
            responses[i]=data;
          

            i = 137;
            data = "No more subgoals.	(dependent evars:)		";
            responses[i]=data;
          

            i = 138;
            data = "<infomsg>PO_rec_beta_pp is defined</infomsg>	";
            responses[i]=data;
          

            i = 139;
            data = "";
            responses[i]=data;
          

            i = 140;
            data = "";
            responses[i]=data;
          

            i = 141;
            data = "";
            responses[i]=data;
          

            i = 142;
            data = "";
            responses[i]=data;
          

            i = 143;
            data = "1 subgoal, subgoal 1 (ID 216)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  IsEquiv por		(dependent evars:)		";
            responses[i]=data;
          

            i = 144;
            data = "1 subgoal, subgoal 1 (ID 216)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  IsEquiv por		(dependent evars:)		";
            responses[i]=data;
          

            i = 145;
            data = "3 subgoals, subgoal 1 (ID 234)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO f g -> C		subgoal 2 (ID 235) is:	 Sect ?Goal por	subgoal 3 (ID 236) is:	 Sect por ?Goal	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 open,)		";
            responses[i]=data;
          

            i = 146;
            data = "5 subgoals, subgoal 1 (ID 244)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  B -> C		subgoal 2 (ID 245) is:	 C -> C	subgoal 3 (ID 246) is:	 ?Goal1 o f == ?Goal2 o g	subgoal 4 (ID 235) is:	 Sect (PO_rec C ?Goal1 ?Goal2 ?Goal3) por	subgoal 5 (ID 236) is:	 Sect por (PO_rec C ?Goal1 ?Goal2 ?Goal3)	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X243 using , ?X244 open, ?X245 open, ?X246 open,)		";
            responses[i]=data;
          

            i = 147;
            data = "4 subgoals, subgoal 1 (ID 245)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  C -> C		subgoal 2 (ID 246) is:	 g o f^-1 o f == ?Goal1 o g	subgoal 3 (ID 235) is:	 Sect (PO_rec C (g o f^-1) ?Goal1 ?Goal2) por	subgoal 4 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) ?Goal1 ?Goal2)	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X243 using , ?X244 using , ?X245 open, ?X246 open,)		";
            responses[i]=data;
          

            i = 148;
            data = "3 subgoals, subgoal 1 (ID 246)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  g o f^-1 o f == idmap o g		subgoal 2 (ID 235) is:	 Sect (PO_rec C (g o f^-1) idmap ?Goal1) por	subgoal 3 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap ?Goal1)	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X243 using , ?X244 using , ?X245 using , ?X246 open,)		";
            responses[i]=data;
          

            i = 149;
            data = "3 subgoals, subgoal 1 (ID 260)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  x : A	  ============================	  g (f^-1 (f x)) = g x		subgoal 2 (ID 235) is:	 Sect (PO_rec C (g o f^-1) idmap (fun x : A => ?Goal1)) por	subgoal 3 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ?Goal1))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 open,)		";
            responses[i]=data;
          

            i = 150;
            data = "3 subgoals, subgoal 1 (ID 263)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  x : A	  ============================	  f^-1 (f x) = x		subgoal 2 (ID 235) is:	 Sect (PO_rec C (g o f^-1) idmap (fun x : A => ap g ?Goal1)) por	subgoal 3 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g ?Goal1))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 open,)		";
            responses[i]=data;
          

            i = 151;
            data = "2 subgoals, subgoal 1 (ID 235)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  Sect (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x))) por		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using ,)		";
            responses[i]=data;
          

            i = 152;
            data = "4 subgoals, subgoal 1 (ID 276)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall b : B, por (g (f^-1 b)) = pol b		subgoal 2 (ID 277) is:	 forall c : C, por c = por c	subgoal 3 (ID 278) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) (?Goal0 (f a)) = ?Goal1 (g a)	subgoal 4 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 open, ?X277 open,)		";
            responses[i]=data;
          

            i = 153;
            data = "4 subgoals, subgoal 1 (ID 279)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  por (g (f^-1 b)) = pol b		subgoal 2 (ID 277) is:	 forall c : C, por c = por c	subgoal 3 (ID 278) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => ?Goal2) (f a)) = ?Goal0 (g a)	subgoal 4 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 open, ?X279 open,)		";
            responses[i]=data;
          

            i = 154;
            data = "4 subgoals, subgoal 1 (ID 296)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  pol (f (f^-1 b)) = pol b		subgoal 2 (ID 277) is:	 forall c : C, por c = por c	subgoal 3 (ID 278) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (f^-1 b))^ @ ?Goal2) (f a)) = 	 ?Goal0 (g a)	subgoal 4 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 open, ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 open,)		";
            responses[i]=data;
          

            i = 155;
            data = "4 subgoals, subgoal 1 (ID 299)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  f (f^-1 b) = b		subgoal 2 (ID 277) is:	 forall c : C, por c = por c	subgoal 3 (ID 278) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol ?Goal2) (f a)) =	 ?Goal0 (g a)	subgoal 4 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 open, ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 open,)		";
            responses[i]=data;
          

            i = 156;
            data = "3 subgoals, subgoal 1 (ID 277)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall c : C, por c = por c		subgoal 2 (ID 278) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (f^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	 ?Goal0 (g a)	subgoal 3 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 open, ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using ,)		";
            responses[i]=data;
          

            i = 157;
            data = "2 subgoals, subgoal 1 (ID 278)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall a : A,	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (f^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((fun b : B => (popp (f^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	  (fun c : C => 1) (g a)		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 158;
            data = "2 subgoals, subgoal 1 (ID 305)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (f^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a))) = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 159;
            data = "2 subgoals, subgoal 1 (ID 322)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap	      (fun x : PO f g =>	       por	         (PO_rec C (fun x0 : B => g (f^-1 x0)) idmap	            (fun x0 : A => ap g (eissect f x0)) x)) 	      (popp a))^ @ ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @	  popp a = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 160;
            data = "2 subgoals, subgoal 1 (ID 329)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por	      (ap	         (PO_rec C (fun x : B => g (f^-1 x)) idmap	            (fun x : A => ap g (eissect f x))) (popp a)))^ @	   ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @ 	  popp a = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 161;
            data = "2 subgoals, subgoal 1 (ID 333)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (f^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @ 	  popp a = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 162;
            data = "2 subgoals, subgoal 1 (ID 336)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (f^-1 (f a)))^ @ ap pol (ap f (eissect f a)))) @ 	  popp a = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 163;
            data = "2 subgoals, subgoal 1 (ID 375)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g 1))^ @ ((popp (f^-1 (f a)))^ @ ap pol (ap f 1))) @	  popp (f^-1 (f a)) = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 164;
            data = "2 subgoals, subgoal 1 (ID 376)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (1 @ ((popp (f^-1 (f a)))^ @ 1)) @ popp (f^-1 (f a)) = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 165;
            data = "2 subgoals, subgoal 1 (ID 387)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (popp (f^-1 (f a)))^ @ popp (f^-1 (f a)) = 1		subgoal 2 (ID 236) is:	 Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))	(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 166;
            data = "1 subgoal, subgoal 1 (ID 236)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  Sect por (PO_rec C (g o f^-1) idmap (fun x : A => ap g (eissect f x)))		(dependent evars: ?X231 using , ?X232 using , ?X233 using , ?X234 using ?X246 ?X245 ?X244 , ?X244 using , ?X245 using , ?X246 using ?X259 , ?X259 using ?X260 , ?X260 using ?X263 , ?X263 using , ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 167;
            data = "No more subgoals.	(dependent evars: ?X273 using ?X276 , ?X274 using ?X277 , ?X276 using ?X279 , ?X277 using ?X302 , ?X279 using ?X288 , ?X288 using ?X289 , ?X289 using ?X290 , ?X290 using ?X291 , ?X291 using ?X292 , ?X292 using ?X293 , ?X293 using ?X294 , ?X294 using ?X295 , ?X295 using ?X296 , ?X296 using ?X299 , ?X299 using , ?X302 using ?X303 , ?X303 using ,)		";
            responses[i]=data;
          

            i = 168;
            data = "<infomsg>PO_of_equiv is defined</infomsg>	";
            responses[i]=data;
          

            i = 169;
            data = "";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "";
            responses[i]=data;
          

            i = 172;
            data = "";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "<infomsg>H is assumed</infomsg>	<infomsg>A is assumed</infomsg>	<infomsg>B is assumed</infomsg>	<infomsg>C is assumed</infomsg>	<infomsg>f is assumed</infomsg>	<infomsg>g is assumed</infomsg>	";
            responses[i]=data;
          

            i = 180;
            data = "1 subgoal, subgoal 1 (ID 8)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_PO f g (pushout f g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 181;
            data = "1 subgoal, subgoal 1 (ID 8)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_PO f g (pushout f g)		(dependent evars:)		";
            responses[i]=data;
          

            i = 182;
            data = "2 subgoals, subgoal 1 (ID 10)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  cocone (span f g) (pushout f g)		subgoal 2 (ID 11) is:	 is_universal ?C	(dependent evars: ?X10 open,)		";
            responses[i]=data;
          

            i = 183;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 10)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  cocone (span f g) (pushout f g)		(dependent evars: ?X10 open,)		3 focused subgoals	(unfocused: 1), subgoal 1 (ID 39)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  B -> pushout f g		subgoal 2 (ID 40) is:	 C -> pushout f g	subgoal 3 (ID 41) is:	 ?Goal0 o f == ?Goal1 o g	(dependent evars: ?X10 using ?X41 ?X40 ?X39 , ?X33 using , ?X34 using , ?X35 using , ?X36 using , ?X37 using , ?X38 using , ?X39 open, ?X40 open, ?X41 open,)		";
            responses[i]=data;
          

            i = 184;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 40)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  C -> pushout f g		subgoal 2 (ID 41) is:	 push o inl o f == ?Goal0 o g	(dependent evars: ?X10 using ?X41 ?X40 ?X39 , ?X33 using , ?X34 using , ?X35 using , ?X36 using , ?X37 using , ?X38 using , ?X39 using , ?X40 open, ?X41 open,)		";
            responses[i]=data;
          

            i = 185;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 41)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  push o inl o f == push o inr o g		(dependent evars: ?X10 using ?X41 ?X40 ?X39 , ?X33 using , ?X34 using , ?X35 using , ?X36 using , ?X37 using , ?X38 using , ?X39 using , ?X40 using , ?X41 open,)		";
            responses[i]=data;
          

            i = 186;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 11)		subgoal 1 (ID 11) is:	 is_universal (Build_span_cocone (push o inl) (push o inr) pp)	(dependent evars: ?X10 using ?X41 ?X40 ?X39 , ?X39 using , ?X40 using , ?X41 using ,)		";
            responses[i]=data;
          

            i = 187;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 11)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_universal (Build_span_cocone (push o inl) (push o inr) pp)		(dependent evars: ?X10 using ?X41 ?X40 ?X39 , ?X39 using , ?X40 using , ?X41 using ,)		3 focused subgoals	(unfocused: 0), subgoal 1 (ID 98)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  cocone (span f g) Y -> pushout f g -> Y		subgoal 2 (ID 99) is:	 Sect ?Goal	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 3 (ID 100) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp)) ?Goal	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 open,)		";
            responses[i]=data;
          

            i = 188;
            data = "1 focused subgoal	(unfocused: 2-0), subgoal 1 (ID 98)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  cocone (span f g) Y -> pushout f g -> Y		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 open,)		1 focused subgoal	(unfocused: 2-0), subgoal 1 (ID 101)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  pushout f g -> Y		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 open,)		";
            responses[i]=data;
          

            i = 189;
            data = "2 focused subgoals	(unfocused: 2-0), subgoal 1 (ID 126)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  B + C -> Y		subgoal 2 (ID 127) is:	 forall a : A, ?Goal1 (inl (f a)) = ?Goal1 (inr (g a))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X120 using , ?X121 using , ?X122 using , ?X123 using , ?X124 using , ?X125 using , ?X126 open, ?X127 open,)		";
            responses[i]=data;
          

            i = 190;
            data = "3 focused subgoals	(unfocused: 2-0), subgoal 1 (ID 143)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  B -> Y		subgoal 2 (ID 144) is:	 C -> Y	subgoal 3 (ID 127) is:	 forall a : A,	 sum_rect (fun _ : B + C => Y) ?Goal2 ?Goal3 (inl (f a)) =	 sum_rect (fun _ : B + C => Y) ?Goal2 ?Goal3 (inr (g a))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X120 using , ?X121 using , ?X122 using , ?X123 using , ?X124 using , ?X125 using , ?X126 using ?X142 ?X141 , ?X127 open, ?X141 using ?X143 , ?X142 using ?X144 , ?X143 open, ?X144 open,)		";
            responses[i]=data;
          

            i = 191;
            data = "2 focused subgoals	(unfocused: 2-0), subgoal 1 (ID 144)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  C -> Y		subgoal 2 (ID 127) is:	 forall a : A,	 sum_rect (fun _ : B + C => Y) (pol' Co) ?Goal2 (inl (f a)) =	 sum_rect (fun _ : B + C => Y) (pol' Co) ?Goal2 (inr (g a))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X120 using , ?X121 using , ?X122 using , ?X123 using , ?X124 using , ?X125 using , ?X126 using ?X142 ?X141 , ?X127 open, ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 open,)		";
            responses[i]=data;
          

            i = 192;
            data = "1 focused subgoal	(unfocused: 2-0), subgoal 1 (ID 127)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  forall a : A,	  sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co) (inl (f a)) =	  sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co) (inr (g a))		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X120 using , ?X121 using , ?X122 using , ?X123 using , ?X124 using , ?X125 using , ?X126 using ?X142 ?X141 , ?X127 open, ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using ,)		";
            responses[i]=data;
          

            i = 193;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 99)		subgoal 1 (ID 99) is:	 Sect	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	      (popp' Co))	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 2 (ID 100) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	      (popp' Co))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using ,)		";
            responses[i]=data;
          

            i = 194;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 99)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Sect	    (fun Co : cocone (span f g) Y =>	     pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	       (popp' Co))	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp))		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using ,)		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 168)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  ============================	  postcompose_cocone	    (Build_span_cocone (fun x : B => push (inl x))	       (fun x : C => push (inr x)) pp)	    (pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (pol' {| q := Co; qq := Co' |})	          (por' {| q := Co; qq := Co' |})) (popp' {| q := Co; qq := Co' |})) =	  {| q := Co; qq := Co' |}		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using ,)		";
            responses[i]=data;
          

            i = 195;
            data = "2 focused subgoals	(unfocused: 1-0), subgoal 1 (ID 190)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   pushout_rec Y	     (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	     (popp' {| q := Co; qq := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i		subgoal 2 (ID 191) is:	 forall (i j : Unit + Bool)	   (g0 : match i with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Empty	             end	         end j)	   (x : match i with	        | inl _ => A	        | inr true => B	        | inr false => C	        end),	 ap	   (pushout_rec Y	      (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	      (popp' {| q := Co; qq := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	           (g1 : match s with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Empty	                     end	                 end j0)	           (x0 : match s with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end),	         match	           j0 as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end	           (match	              s as s0	              return	                (forall j1 : Unit + Bool,	                 match s0 with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Empty	                     end	                 end j1 ->	                 match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end ->	                 match j1 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end)	            with	            | inl _ =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun u : Unit =>	                    (if j2 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u	                end	            | inr i0 =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Empty	                     end ->	                     (if i0 then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => if j2 then B else C) u	                end	            end j0 g1 x0) =	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end x0)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end) (x0 : A),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b =>	                 if b as b0 return ((if b0 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u0 : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u0	                | inr j1 =>	                    fun u0 : Unit =>	                    (if j1 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u0	                end g1 x0) = push (inr (g x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : A,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 push (inr (g x0)))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u0	              return	                (forall x0 : A,	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   ((if b as b0 return (Unit -> A -> if b0 then B else C)	                     then unit_name f	                     else unit_name g) u0 x0) = push (inr (g x0)))	            with	            | tt =>	                if b as b0	                 return	                   (forall x0 : A,	                    (if b0 as b1	                      return ((if b1 then B else C) -> pushout f g)	                     then fun x1 : B => push (inl x1)	                     else fun x1 : C => push (inr x1))	                      ((if b0 as b1 return (Unit -> A -> if b1 then B else C)	                        then unit_name f	                        else unit_name g) tt x0) = 	                    push (inr (g x0)))	                then pp	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Empty	                          end) (x0 : if b then B else C),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b0 =>	                 if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Empty	                     end ->	                     (if b then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j1 =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => if j1 then B else C) u	                end g1 x0) =	             (if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)) x0)	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                 (if b as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        end	    end j g0 x) @ ?Goal0 i x =	 ?Goal0 j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Empty	             end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun u : Unit =>	            (if j1 as b return (Unit -> A -> if b then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr i0 =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Empty	             end ->	             (if i0 then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => if j1 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 open,)		";
            responses[i]=data;
          

            i = 196;
            data = "1 focused subgoal	(unfocused: 1-1-0), subgoal 1 (ID 190)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   pushout_rec Y	     (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	     (popp' {| q := Co; qq := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 open,)		3 focused subgoals	(unfocused: 1-1-0), subgoal 1 (ID 211)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  Co (inr false) (g x) = Co (inl tt) x		subgoal 2 (ID 212) is:	 Co (inr true) x = Co (inr true) x	subgoal 3 (ID 213) is:	 Co (inr false) x = Co (inr false) x	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 open, ?X212 open, ?X213 open,)		";
            responses[i]=data;
          

            i = 197;
            data = "2 focused subgoals	(unfocused: 1-1-0), subgoal 1 (ID 212)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : B	  ============================	  Co (inr true) x = Co (inr true) x		subgoal 2 (ID 213) is:	 Co (inr false) x = Co (inr false) x	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 open, ?X213 open,)		";
            responses[i]=data;
          

            i = 198;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals, subgoal 1 (ID 191)		subgoal 1 (ID 191) is:	 forall (i j : Unit + Bool)	   (g0 : match i with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Empty	             end	         end j)	   (x : match i with	        | inl _ => A	        | inr true => B	        | inr false => C	        end),	 ap	   (pushout_rec Y	      (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	      (popp' {| q := Co; qq := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	           (g1 : match s with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Empty	                     end	                 end j0)	           (x0 : match s with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end),	         match	           j0 as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end	           (match	              s as s0	              return	                (forall j1 : Unit + Bool,	                 match s0 with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Empty	                     end	                 end j1 ->	                 match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end ->	                 match j1 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end)	            with	            | inl _ =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun u : Unit =>	                    (if j2 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u	                end	            | inr i0 =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Empty	                     end ->	                     (if i0 then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => if j2 then B else C) u	                end	            end j0 g1 x0) =	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end x0)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end) (x0 : A),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b =>	                 if b as b0 return ((if b0 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u0 : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u0	                | inr j1 =>	                    fun u0 : Unit =>	                    (if j1 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u0	                end g1 x0) = push (inr (g x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : A,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 push (inr (g x0)))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u0	              return	                (forall x0 : A,	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   ((if b as b0 return (Unit -> A -> if b0 then B else C)	                     then unit_name f	                     else unit_name g) u0 x0) = push (inr (g x0)))	            with	            | tt =>	                if b as b0	                 return	                   (forall x0 : A,	                    (if b0 as b1	                      return ((if b1 then B else C) -> pushout f g)	                     then fun x1 : B => push (inl x1)	                     else fun x1 : C => push (inr x1))	                      ((if b0 as b1 return (Unit -> A -> if b1 then B else C)	                        then unit_name f	                        else unit_name g) tt x0) = 	                    push (inr (g x0)))	                then pp	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Empty	                          end) (x0 : if b then B else C),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b0 =>	                 if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Empty	                     end ->	                     (if b then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j1 =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => if j1 then B else C) u	                end g1 x0) =	             (if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)) x0)	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                 (if b as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        end	    end j g0 x) @	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y	          (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y	              (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y	             (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => 1	      else fun x0 : C => 1	  end) i x =	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y	          (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y	              (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y	             (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => 1	      else fun x0 : C => 1	  end) j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Empty	             end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun u : Unit =>	            (if j1 as b return (Unit -> A -> if b then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr i0 =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Empty	             end ->	             (if i0 then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => if j1 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	subgoal 2 (ID 100) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	      (popp' Co))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 199;
            data = "1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 191)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall (i j : Unit + Bool)	    (g0 : match i with	          | inl _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Unit	              end	          | inr _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Empty	              end	          end j)	    (x : match i with	         | inl _ => A	         | inr true => B	         | inr false => C	         end),	  ap	    (pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	       (popp' {| q := Co; qq := Co' |}))	    (match	       i as s	       return	         (forall (j0 : Unit + Bool)	            (g1 : match s with	                  | inl _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Unit	                      end	                  | inr _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Empty	                      end	                  end j0)	            (x0 : match s with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end),	          match	            j0 as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end	            (match	               s as s0	               return	                 (forall j1 : Unit + Bool,	                  match s0 with	                  | inl _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Unit	                      end	                  | inr _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Empty	                      end	                  end j1 ->	                  match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end ->	                  match j1 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end)	             with	             | inl _ =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j2 =>	                     fun u : Unit =>	                     (if j2 as b return (Unit -> A -> if b then B else C)	                      then unit_name f	                      else unit_name g) u	                 end	             | inr i0 =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Empty	                      end ->	                      (if i0 then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if i0 then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j2 =>	                     fun (u : Empty) (_ : if i0 then B else C) =>	                     Empty_rect (fun _ : Empty => if j2 then B else C) u	                 end	             end j0 g1 x0) =	          match	            s as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end x0)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall (g1 : match s with	                           | inl _ => Empty	                           | inr _ => Unit	                           end) (x0 : A),	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b =>	                  if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u0 : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u0	                 | inr j1 =>	                     fun u0 : Unit =>	                     (if j1 as b return (Unit -> A -> if b then B else C)	                      then unit_name f	                      else unit_name g) u0	                 end g1 x0) = push (inr (g x0)))	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : A,	                  push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                  push (inr (g x0)))	             with	             end	         | inr b =>	             fun g1 : Unit =>	             match	               g1 as u0	               return	                 (forall x0 : A,	                  (if b as b0 return ((if b0 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    ((if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u0 x0) = push (inr (g x0)))	             with	             | tt =>	                 if b as b0	                  return	                    (forall x0 : A,	                     (if b0 as b1	                       return ((if b1 then B else C) -> pushout f g)	                      then fun x1 : B => push (inl x1)	                      else fun x1 : C => push (inr x1))	                       ((if b0 as b1	                          return (Unit -> A -> if b1 then B else C)	                         then unit_name f	                         else unit_name g) tt x0) = 	                     push (inr (g x0)))	                 then pp	                 else fun x0 : A => 1	             end	         end	     | inr b =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall	                (g1 : match s with	                      | inl _ => Empty	                      | inr _ => Empty	                      end) (x0 : if b then B else C),	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b0 =>	                  if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j1 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if j1 then B else C) u	                 end g1 x0) =	              (if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : if b then B else C,	                  push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                  (if b as b0 return ((if b0 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)) x0)	             with	             end	         | inr b0 =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : if b then B else C,	                  (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                  (if b as b1 return ((if b1 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)) x0)	             with	             end	         end	     end j g0 x) @	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         pushout_rec Y	           (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	           (popp' {| q := Co; qq := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl u =>	       match	         u as u0	         return	           ((fun x0 : A =>	             pushout_rec Y	               (sum_rect (fun _ : B + C => Y) (Co (inr true))	                  (Co (inr false))) (popp' {| q := Co; qq := Co' |})	               (push (inr (g x0)))) == Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end	   | inr b =>	       if b as b0	        return	          ((fun x0 : if b0 then B else C =>	            pushout_rec Y	              (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	              (popp' {| q := Co; qq := Co' |})	              ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b0))	       then fun x0 : B => 1	       else fun x0 : C => 1	   end) i x =	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         pushout_rec Y	           (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	           (popp' {| q := Co; qq := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl u =>	       match	         u as u0	         return	           ((fun x0 : A =>	             pushout_rec Y	               (sum_rect (fun _ : B + C => Y) (Co (inr true))	                  (Co (inr false))) (popp' {| q := Co; qq := Co' |})	               (push (inr (g x0)))) == Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end	   | inr b =>	       if b as b0	        return	          ((fun x0 : if b0 then B else C =>	            pushout_rec Y	              (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	              (popp' {| q := Co; qq := Co' |})	              ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b0))	       then fun x0 : B => 1	       else fun x0 : C => 1	   end) j	    (match	       i as s	       return	         (forall j0 : Unit + Bool,	          match s with	          | inl _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Unit	              end	          | inr _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Empty	              end	          end j0 ->	          match s with	          | inl _ => A	          | inr true => B	          | inr false => C	          end ->	          match j0 with	          | inl _ => A	          | inr true => B	          | inr false => C	          end)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ => Empty	              | inr _ => Unit	              end ->	              A ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	         | inr j1 =>	             fun u : Unit =>	             (if j1 as b return (Unit -> A -> if b then B else C)	              then unit_name f	              else unit_name g) u	         end	     | inr i0 =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ => Empty	              | inr _ => Empty	              end ->	              (if i0 then B else C) ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : if i0 then B else C) =>	             Empty_rect (fun _ : Empty => A) u	         | inr j1 =>	             fun (u : Empty) (_ : if i0 then B else C) =>	             Empty_rect (fun _ : Empty => if j1 then B else C) u	         end	     end j g0 x) @ Co' i j g0 x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 200;
            data = "2 focused subgoals	(unfocused: 0-1-0), subgoal 1 (ID 287)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr true) tt x		subgoal 2 (ID 288) is:	 1 @ Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr false) tt x	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 287)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr true) tt x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 201;
            data = "1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 312)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (Co (inr true)) (Co (inr false)))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 202;
            data = "1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 318)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  popp' {| q := Co; qq := Co' |} x @ Co' (inl tt) (inr false) tt x =	  Co' (inl tt) (inr true) tt x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 203;
            data = "1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 324)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  (qq {| q := Co; qq := Co' |} (inl tt) (inr true) tt x @	   (qq {| q := Co; qq := Co' |} (inl tt) (inr false) tt x)^) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 204;
            data = "1 focused subgoal	(unfocused: 0-1-0), subgoal 1 (ID 325)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, (span f g) i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) (x : (span f g) i),	        Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  (Co' (inl tt) (inr true) tt x @ (Co' (inl tt) (inr false) tt x)^) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 205;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 100)		subgoal 1 (ID 100) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	      (popp' Co))	(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 206;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 100)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Sect	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp))	    (fun Co : cocone (span f g) Y =>	     pushout_rec Y (sum_rect (fun _ : B + C => Y) (pol' Co) (por' Co))	       (popp' Co))		(dependent evars: ?X95 using , ?X96 using , ?X97 using , ?X98 using ?X101 ?X96 , ?X101 using ?X127 ?X126 , ?X126 using ?X142 ?X141 , ?X127 using , ?X141 using ?X143 , ?X142 using ?X144 , ?X143 using , ?X144 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 448)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  pushout_rec Y	    (sum_rect (fun _ : B + C => Y)	       (pol'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h))	       (por'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) = h		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 207;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 452)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  pushout_rec Y	    (sum_rect (fun _ : B + C => Y)	       (pol'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h))	       (por'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) == h		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using ,)		";
            responses[i]=data;
          

            i = 208;
            data = "2 focused subgoals	(unfocused: 0-0), subgoal 1 (ID 486)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall a : B + C,	  pushout_rec Y	    (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x))))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) (push a) = 	  h (push a)		subgoal 2 (ID 487) is:	 forall a : A,	 transport	   (fun w : pushout f g =>	    pushout_rec Y	      (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	         (fun x : C => h (push (inr x))))	      (popp'	         (postcompose_cocone	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pp) h)) w = 	    h w) (pp a) (?Goal (inl (f a))) = ?Goal (inr (g a))	(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 open,)		";
            responses[i]=data;
          

            i = 209;
            data = "1 focused subgoal	(unfocused: 1-0-0), subgoal 1 (ID 486)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall a : B + C,	  pushout_rec Y	    (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x))))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) (push a) = 	  h (push a)		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 open,)		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal, subgoal 1 (ID 487)		subgoal 1 (ID 487) is:	 forall a : A,	 transport	   (fun w : pushout f g =>	    pushout_rec Y	      (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	         (fun x : C => h (push (inr x))))	      (popp'	         (postcompose_cocone	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pp) h)) w = 	    h w) (pp a)	   ((fun a0 : B + C =>	     match	       a0 as s	       return	         (pushout_rec Y	            (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	               (fun x : C => h (push (inr x))))	            (popp'	               (postcompose_cocone	                  (Build_span_cocone (fun x : B => push (inl x))	                     (fun x : C => push (inr x)) pp) h)) 	            (push s) = h (push s))	     with	     | inl b => 1	     | inr c => 1	     end) (inl (f a))) =	 (fun a0 : B + C =>	  match	    a0 as s	    return	      (pushout_rec Y	         (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	            (fun x : C => h (push (inr x))))	         (popp'	            (postcompose_cocone	               (Build_span_cocone (fun x : B => push (inl x))	                  (fun x : C => push (inr x)) pp) h)) 	         (push s) = h (push s))	  with	  | inl b => 1	  | inr c => 1	  end) (inr (g a))	(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 210;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 487)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall a : A,	  transport	    (fun w : pushout f g =>	     pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	          (fun x : C => h (push (inr x))))	       (popp'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)) w = 	     h w) (pp a)	    ((fun a0 : B + C =>	      match	        a0 as s	        return	          (pushout_rec Y	             (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	                (fun x : C => h (push (inr x))))	             (popp'	                (postcompose_cocone	                   (Build_span_cocone (fun x : B => push (inl x))	                      (fun x : C => push (inr x)) pp) h)) 	             (push s) = h (push s))	      with	      | inl b => 1	      | inr c => 1	      end) (inl (f a))) =	  (fun a0 : B + C =>	   match	     a0 as s	     return	       (pushout_rec Y	          (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	             (fun x : C => h (push (inr x))))	          (popp'	             (postcompose_cocone	                (Build_span_cocone (fun x : B => push (inl x))	                   (fun x : C => push (inr x)) pp) h)) 	          (push s) = h (push s))	   with	   | inl b => 1	   | inr c => 1	   end) (inr (g a))		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 498)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  transport	    (fun w : pushout f g =>	     pushout_rec Y	       (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	          (fun x : C => h (push (inr x))))	       (popp'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)) w = 	     h w) (pp a) 1 = 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 211;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 505)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ((ap	      (pushout_rec Y	         (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	            (fun x : C => h (push (inr x))))	         (popp'	            (postcompose_cocone	               (Build_span_cocone (fun x : B => push (inl x))	                  (fun x : C => push (inr x)) pp) h))) 	      (pp a))^ @ 1) @ ap h (pp a) = 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 212;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 515)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  (ap	     (pushout_rec Y	        (sum_rect (fun _ : B + C => Y) (fun x : B => h (push (inl x)))	           (fun x : C => h (push (inr x))))	        (popp'	           (postcompose_cocone	              (Build_span_cocone (fun x : B => push (inl x))	                 (fun x : C => push (inr x)) pp) h))) 	     (pp a))^ @ ap h (pp a) = 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 213;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 524)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  (popp'	     (postcompose_cocone	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pp) h) a)^ @ 	  ap h (pp a) = 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 214;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 534)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) =	  popp'	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp) h) a @ 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 215;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 535)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) =	  (qq	     (postcompose_cocone	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pp) h) (inl tt) 	     (inr true) tt a @	   (qq	      (postcompose_cocone	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pp) h) (inl tt) 	      (inr false) tt a)^) @ 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 216;
            data = "1 focused subgoal	(unfocused: 0-0-0), subgoal 1 (ID 536)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) = (ap h (pp a) @ 1) @ 1		(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 217;
            data = "No more subgoals.	(dependent evars: ?X95 using , ?X96 using , ?X188 using ?X190 , ?X190 using ?X192 , ?X192 using ?X194 ?X193 , ?X193 using ?X195 , ?X194 using ?X196 , ?X195 using ?X197 , ?X196 using ?X202 , ?X197 using ?X198 , ?X198 using ?X199 , ?X199 using ?X200 , ?X200 using ?X201 , ?X201 using ?X211 , ?X202 using ?X204 ?X203 , ?X203 using ?X205 , ?X204 using ?X206 , ?X205 using ?X207 , ?X206 using ?X209 , ?X207 using ?X208 , ?X208 using ?X212 , ?X209 using ?X210 , ?X210 using ?X213 , ?X211 using , ?X212 using ?X218 , ?X213 using ?X219 , ?X218 using , ?X219 using , ?X484 using ?X486 , ?X486 using ?X488 , ?X488 using ?X490 ?X489 , ?X489 using ?X491 , ?X490 using ?X492 , ?X491 using ?X493 , ?X492 using ?X494 , ?X493 using ?X495 , ?X494 using ?X496 , ?X495 using , ?X496 using ,)		";
            responses[i]=data;
          

            i = 218;
            data = "<infomsg>is_PO_pushout is defined</infomsg>	";
            responses[i]=data;
          

            i = 219;
            data = "1 subgoal, subgoal 1 (ID 15)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  pushout f g <~> PO f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 220;
            data = "1 subgoal, subgoal 1 (ID 15)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  pushout f g <~> PO f g		(dependent evars:)		";
            responses[i]=data;
          

            i = 221;
            data = "4 subgoals, subgoal 1 (ID 28)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  graph		subgoal 2 (ID 29) is:	 diagram ?Goal	subgoal 3 (ID 32) is:	 is_colimit ?Goal0 (pushout f g)	subgoal 4 (ID 33) is:	 is_colimit ?Goal0 (PO f g)	(dependent evars: ?X28 open, ?X29 open, ?X30 using , ?X31 using ,)		";
            responses[i]=data;
          

            i = 222;
            data = "1 subgoal, subgoal 1 (ID 33)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_colimit (span f g) (PO f g)		(dependent evars: ?X28 using , ?X29 using , ?X31 using ,)		";
            responses[i]=data;
          

            i = 223;
            data = "No more subgoals.	(dependent evars: ?X28 using , ?X29 using ,)		";
            responses[i]=data;
          

            i = 224;
            data = "<infomsg>equiv_pushout_PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          

            i = 228;
            data = "";
            responses[i]=data;
          

            i = 229;
            data = "";
            responses[i]=data;
          

            i = 230;
            data = "";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.HIT.Colimits.Pushout</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a> <a class="idref" href="HoTT.HIT.Pushout.html#"><span class="id" title="library">HIT.Pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#"><span class="id" title="library">Colimits.Diagram</span></a> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab481"></a><h1 class="section">Pushout as a colimit</h1>
<div class="doc" scenenumber="4"> </div>

 In this file, we define <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a></span> the pushout of two maps as the colimit of a particuliar diagram, and then show that it is equivalent to <span class="inlinecode"><a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a></span> the primitive pushout defined as an HIT. 
<div class="doc" scenenumber="10"> </div>
<a name="lab482"></a><h2 class="section"><span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a></span></h2>
<div class="doc" scenenumber="15"> </div>

 The shape of a pushout diagram. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="PO_graph"><span class="id" title="definition">PO_graph</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#graph"><span class="id" title="record">graph</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Diagram.html#Build_graph"><span class="id" title="constructor">Build_graph</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>] [<span class="id" title="var">j</span>|<span class="id" title="var">j</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The pushout diagram of two maps is called a span. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      ">
<br>
  <span class="id" title="keyword">Definition</span> <a name="span"><span class="id" title="definition">span</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) : <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#diagram"><span class="id" title="record">diagram</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_graph"><span class="id" title="definition">PO_graph</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
    <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Diagram.html#Build_diagram"><span class="id" title="constructor">Build_diagram</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">i</span> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>] [<span class="id" title="var">j</span>|<span class="id" title="var">j</span>] <span class="id" title="var">u</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">j</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">g</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>}<br>
             (<span class="id" title="var">inl'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>) (<span class="id" title="var">inr'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
             (<span class="id" title="var">pp'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#inl'"><span class="id" title="variable">inl'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#inr'"><span class="id" title="variable">inr'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
    <span class="id" title="var">unshelve</span> <span class="id" title="tactic">econstructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> []; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(60, '0_3_11');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(61, '0_3_11');
      "><span class="id" title="tactic">exact</span> (<span class="id" title="var">inr'</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(62, '0_3_11');
      "><br>
      <span class="id" title="tactic">intros</span> []. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(63, '0_3_11');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">inl'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(64, '0_3_11');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">inr'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(65, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(66, '0_3_11');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(67, '0_3_11');
      "><br>
      <span class="id" title="tactic">exact</span> <span class="id" title="var">pp'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(68, '0_3_11');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(69, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(70, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="pol'"><span class="id" title="definition">pol'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#q"><span class="id" title="projection">q</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(71, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="por'"><span class="id" title="definition">por'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#q"><span class="id" title="projection">q</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(72, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="popp'"><span class="id" title="definition">popp'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por'"><span class="id" title="definition">por'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a><br>
    := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#qq"><span class="id" title="projection">qq</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a><br>
                <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Colimit.html#qq"><span class="id" title="projection">qq</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(73, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="is_PO"><span class="id" title="definition">is_PO</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#is_colimit"><span class="id" title="record">is_colimit</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(74, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="PO"><span class="id" title="definition">PO</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit"><span class="id" title="inductive">colimit</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(75, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(76, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="pol"><span class="id" title="definition">pol</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(77, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="por"><span class="id" title="definition">por</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(78, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="popp"><span class="id" title="definition">popp</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>)<br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a><br>
          <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(79, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The eliminators <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a></span>, <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a></span>, ... can be proven. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(87, '0_3_15');
      ">
  <span class="id" title="keyword">Definition</span> <a name="PO_ind"><span class="id" title="definition">PO_ind</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#b"><span class="id" title="variable">b</span></a>))<br>
             (<span class="id" title="var">r'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#c"><span class="id" title="variable">c</span></a>))<br>
             (<span class="id" title="var">pp'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>))<br>
    : <span class="id" title="keyword">∀</span> <span class="id" title="var">w</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#w"><span class="id" title="variable">w</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(88, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(89, '0_3_15');
      "><br>
    <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(90, '0_3_15');
      "><br>
    - <span class="id" title="tactic">intros</span> []; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(91, '0_3_15');
      "><br>
      <span class="id" title="tactic">intros</span> [] <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(92, '0_3_15');
      "><br>
      <span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">l'</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(93, '0_3_15');
      "><br>
      <span class="id" title="tactic">intros</span> []; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(94, '0_3_15');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">l'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(95, '0_3_15');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">r'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(96, '0_3_15');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(97, '0_3_15');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>, <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(98, '0_3_15');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(99, '0_3_15');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(100, '0_3_15');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(101, '0_3_15');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(102, '0_3_15');
      "><br>
      <span class="id" title="var">etransitivity</span>; [|<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_pp"><span class="id" title="definition">transport_pp</span></a>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(103, '0_3_15');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(104, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(105, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_ind_beta_pp"><span class="id" title="definition">PO_ind_beta_pp</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#b"><span class="id" title="variable">b</span></a>))<br>
             (<span class="id" title="var">r'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#c"><span class="id" title="variable">c</span></a>))<br>
             (<span class="id" title="var">pp'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span>, <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>))<br>
    : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(106, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(107, '0_3_15');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(108, '0_3_15');
      "><span class="id" title="var">etransitivity</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(109, '0_3_15');
      "><span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_pp"><span class="id" title="definition">apD_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(110, '0_3_15');
      "><br>
    <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <span class="id" title="var">P</span> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                (@<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1). {</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(111, '0_3_15');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(112, '0_3_15');
      "><br>
      <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
      | |- <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
        <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind_beta_colimp"><span class="id" title="axiom">colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>)<br>
      <span class="id" title="keyword">end</span>. }<br>
    <span class="id" title="tactic">rewrite</span> <span class="id" title="var">X</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(113, '0_3_15');
      "><span class="id" title="tactic">clear</span> <span class="id" title="var">X</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(114, '0_3_15');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(115, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(116, '0_3_15');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_V"><span class="id" title="definition">apD_V</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(117, '0_3_15');
      "><span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(118, '0_3_15');
      "><br>
    <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
    | |- <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a><br>
          <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
        <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind_beta_colimp"><span class="id" title="axiom">colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>); <span class="id" title="var">cbn</span><br>
    <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(119, '0_3_15');
      "><br>
    <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
    | |- ?<span class="id" title="var">pp</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">qq</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span><br>
      ⇒ <span class="id" title="tactic">set</span> (<span class="id" title="var">q</span> := <span class="id" title="var">qq</span>); <span class="id" title="tactic">set</span> (<span class="id" title="var">p</span> := <span class="id" title="var">pp</span>) <span class="id" title="keyword">in</span> ×<br>
    <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(120, '0_3_15');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p_V"><span class="id" title="definition">moveR_transport_p_V</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(121, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#moveR_moveL_transport_p"><span class="id" title="definition">moveR_moveL_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(122, '0_3_15');
      "><br>
    <span class="id" title="tactic">subst</span> <span class="id" title="var">q</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(123, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(124, '0_3_15');
      "><span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(125, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(126, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_rec"><span class="id" title="definition">PO_rec</span></a> (<span class="id" title="var">P</span>: <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">r'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>)<br>
             (<span class="id" title="var">pp'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec"><span class="id" title="definition">colimit_rec</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(127, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a> (<span class="id" title="var">P</span>: <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">r'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>)<br>
             (<span class="id" title="var">pp'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>)<br>
    : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(128, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(129, '0_3_15');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec_beta_colimp"><span class="id" title="definition">colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(131, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec_beta_colimp"><span class="id" title="definition">colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(132, '0_3_15');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(133, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(134, '0_3_15');
      "><span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(135, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">X</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#3900f7738576f20268441019de062370"><span class="id" title="notation">@@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(136, '0_3_15');
      "><span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a> <span class="id" title="var">X0</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(137, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(138, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(139, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
A nice property: the pushout of an equivalence is an equivalence. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(143, '0_3_19');
      ">
  <span class="id" title="keyword">Definition</span> <a name="PO_of_equiv"><span class="id" title="definition">PO_of_equiv</span></a> (<span class="id" title="var">Hf</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(144, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(145, '0_3_19');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(146, '0_3_19');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(147, '0_3_19');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">^-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(148, '0_3_19');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(149, '0_3_19');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(150, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(151, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(152, '0_3_19');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(153, '0_3_19');
      "><br>
    <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(154, '0_3_19');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(155, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(156, '0_3_19');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eisretr"><span class="id" title="projection">eisretr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(157, '0_3_19');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(158, '0_3_19');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(159, '0_3_19');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(160, '0_3_19');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(161, '0_3_19');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(162, '0_3_19');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#eisadj"><span class="id" title="projection">eisadj</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(163, '0_3_19');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(164, '0_3_19');
      "><span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(165, '0_3_19');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(166, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_Vp"><span class="id" title="definition">concat_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(167, '0_3_19');
      "><br>
    <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(168, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(169, '0_3_19');
      "><br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(170, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
<a name="lab483"></a><h2 class="section">Equivalence with <span class="inlinecode"><a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a></span>
</h2>
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(177, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Section</span> <a name="is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(178, '0_3_23');
      "><br>
  <span class="id" title="keyword">Import</span> <span class="id" title="var">HIT.Pushout</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(179, '0_3_23');
      "><br>
  <span class="id" title="keyword">Context</span> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#C"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(180, '0_3_23');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO"><span class="id" title="definition">is_PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> (<a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(181, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(182, '0_3_23');
      "><br>
    <span class="id" title="var">unshelve</span> <span class="id" title="tactic">econstructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(183, '0_3_23');
      "><br>
    - <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(184, '0_3_23');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(185, '0_3_23');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(186, '0_3_23');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.Pushout.html#pp"><span class="id" title="definition">pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(187, '0_3_23');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">Y</span>; <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(188, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">Co</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(189, '0_3_23');
      "><span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec"><span class="id" title="definition">pushout_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(190, '0_3_23');
      "><br>
        <span class="id" title="var">serapply</span> <a class="idref" href="Coq.Init.Datatypes.html#sum_rect"><span class="id" title="definition">sum_rect</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(191, '0_3_23');
      "><br>
        <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <span class="id" title="var">Co</span>). </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(192, '0_3_23');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por'"><span class="id" title="definition">por'</span></a> <span class="id" title="var">Co</span>). </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(193, '0_3_23');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(194, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intros</span> [<span class="id" title="var">Co</span> <span class="id" title="var">Co'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(195, '0_3_23');
      "><span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#path_cocone"><span class="id" title="definition">path_cocone</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(196, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(197, '0_3_23');
      "><br>
          <span class="id" title="tactic">apply</span> (<span class="id" title="var">Co'</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(198, '0_3_23');
      "><br>
          <span class="id" title="var">all</span>: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(199, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] [[]|[]] [] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(200, '0_3_23');
      "><br>
          2: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(201, '0_3_23');
      "><br>
          <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(202, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec_beta_pp"><span class="id" title="definition">pushout_rec_beta_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(203, '0_3_23');
      "><br>
          <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(204, '0_3_23');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(205, '0_3_23');
      "><span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(206, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(207, '0_3_23');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(208, '0_3_23');
      "><br>
        <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_ind"><span class="id" title="definition">pushout_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(209, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span>|<span class="id" title="var">c</span>]; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(210, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(211, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(212, '0_3_23');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(213, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec_beta_pp"><span class="id" title="definition">pushout_rec_beta_pp</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(214, '0_3_23');
      "><span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_Vp"><span class="id" title="definition">moveR_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(215, '0_3_23');
      "><br>
          <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(216, '0_3_23');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(217, '0_3_23');
      "><span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(218, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(219, '0_3_23');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="equiv_pushout_PO"><span class="id" title="definition">equiv_pushout_PO</span></a><br>
    : <a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(220, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(221, '0_3_23');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#colimit_unicity"><span class="id" title="lemma">colimit_unicity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(222, '0_3_23');
      "><br>
    3: <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(223, '0_3_23');
      "><br>
    <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#is_colimit_colimit"><span class="id" title="definition">is_colimit_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(224, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(225, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(226, '0_3_23');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
