<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "<infomsg>Interactive Module RPushout started</infomsg>	";
            responses[i]=data;
          

            i = 45;
            data = "<infomsg>RPushout is defined</infomsg>	";
            responses[i]=data;
          

            i = 46;
            data = "<infomsg>glue is declared</infomsg>	";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>RPushout_ind is defined</infomsg>	";
            responses[i]=data;
          

            i = 48;
            data = "<infomsg>RPushout_comp_glue is declared</infomsg>	";
            responses[i]=data;
          

            i = 49;
            data = "<infomsg>Module RPushout is defined</infomsg>	";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "<infomsg>RPushout_rec is defined</infomsg>	";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoal, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	  ap (RPushout_rec R P i j gl) (glue R a b r) = gl a b r		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal, subgoal 1 (ID 37)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	  ap (RPushout_rec R P i j gl) (glue R a b r) = gl a b r		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoal, subgoal 1 (ID 48)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	  transport_const (glue R a b r) (i a) @	  ap (RPushout_rec R P i j gl) (glue R a b r) =	  transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 58;
            data = "2 subgoals, subgoal 1 (ID 74)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	  transport_const (glue R a b r) (i a) @	  ap (RPushout_rec R P i j gl) (glue R a b r) =	  apD (RPushout_rec R P i j gl) (glue R a b r)		subgoal 2 (ID 75) is:	 apD (RPushout_rec R P i j gl) (glue R a b r) =	 transport_const (glue R a b r) (i a) @ gl a b r	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 59;
            data = "1 subgoal, subgoal 1 (ID 75)	  	  A : Type	  B : Type	  R : A -> B -> hProp	  P : Type	  i : A -> P	  j : B -> P	  gl : forall (a : A) (b : B), R a b -> i a = j b	  a : A	  b : B	  r : R a b	  ============================	  apD (RPushout_rec R P i j gl) (glue R a b r) =	  transport_const (glue R a b r) (i a) @ gl a b r		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 60;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 61;
            data = "<infomsg>RPushout_comp_nd_glue is defined</infomsg>	";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "<infomsg>bitotal is defined</infomsg>	";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "<infomsg>Interactive Module CumulativeHierarchy started</infomsg>	";
            responses[i]=data;
          

            i = 75;
            data = "<infomsg>V is defined</infomsg>	";
            responses[i]=data;
          

            i = 76;
            data = "<infomsg>setext is declared</infomsg>	";
            responses[i]=data;
          

            i = 77;
            data = "<infomsg>is0trunc_V is declared</infomsg>	";
            responses[i]=data;
          

            i = 78;
            data = "<infomsg>V_ind is defined</infomsg>	<infomsg>V_ind is recursively defined (decreasing on 5th argument)</infomsg>	";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "<infomsg>Module CumulativeHierarchy is defined</infomsg>	";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoal, subgoal 1 (ID 109)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	             (bitot_R : bitotal R) (h : RPushout R -> V)	             (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	  apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 85;
            data = "1 subgoal, subgoal 1 (ID 109)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	             (bitot_R : bitotal R) (h : RPushout R -> V)	             (H_h : forall x : RPushout R, P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o inL R) (H_h oD inL R)) =	             H_set B (h o inR R) (H_h oD inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	  apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 86;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 87;
            data = "<infomsg>V_comp_setext is defined</infomsg>	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoal, subgoal 1 (ID 165)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	  V -> P		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoal, subgoal 1 (ID 165)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	  V -> P		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 94;
            data = "1 subgoal, subgoal 1 (ID 193)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : RPushout R -> V) (H_h : RPushout R -> P),	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 95;
            data = "1 subgoal, subgoal 1 (ID 199)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 96;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 97;
            data = "<infomsg>V_rec is defined</infomsg>	";
            responses[i]=data;
          

            i = 98;
            data = "1 subgoal, subgoal 1 (ID 246)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	  ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 99;
            data = "1 subgoal, subgoal 1 (ID 246)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : RPushout R -> V) (H_h : RPushout R -> P),	             H_set A (h o inL R) (H_h o inL R) =	             H_set B (h o inR R) (H_h o inR R)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  ============================	  ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 100;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 101;
            data = "<infomsg>V_comp_nd_setext is defined</infomsg>	";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "<infomsg>equal_img is defined</infomsg>	";
            responses[i]=data;
          

            i = 110;
            data = "1 subgoal, subgoal 1 (ID 262)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 111;
            data = "1 subgoal, subgoal 1 (ID 262)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 112;
            data = "1 subgoal, subgoal 1 (ID 320)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoal, subgoal 1 (ID 324)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  h := RPushout_rec R V f g (fun (a : A) (b : B) => idmap) : RPushout R -> V	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 114;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>setext' is defined</infomsg>	";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoal, subgoal 1 (ID 274)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  V -> P		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoal, subgoal 1 (ID 274)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  V -> P		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoal, subgoal 1 (ID 278)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp),	  bitotal R ->	  forall (h : RPushout R -> V) (H_h : RPushout R -> P),	  H_set A (fun x : A => h (inL R x)) (fun x : A => H_h (inL R x)) =	  H_set B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoal, subgoal 1 (ID 284)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  H_set A (fun x : A => h (inL R x)) (fun x : A => H_h (inL R x)) =	  H_set B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 120;
            data = "2 subgoals, subgoal 1 (ID 285)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  equal_img (fun x : A => h (inL R x)) (fun x : B => h (inR R x))		subgoal 2 (ID 286) is:	 equal_img (fun x : A => H_h (inL R x)) (fun x : B => H_h (inR R x))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 121;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 285)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  equal_img (fun x : A => h (inL R x)) (fun x : B => h (inR R x))		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 288)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall a : A, hexists (fun b : B => h (inL R a) = h (inR R b))		subgoal 2 (ID 289) is:	 forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 122;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 288)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall a : A, hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 290)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 123;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 293)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists (fun b : B => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 124;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 296)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  {b : B & R a b} -> {b : B & h (inL R a) = h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 125;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 301)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B & h (inL R a) = h (inR R b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 126;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 303)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	  h (inL R a) = h (inR R b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 127;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 289)		subgoal 1 (ID 289) is:	 forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))	subgoal 2 (ID 286) is:	 equal_img (fun x : A => H_h (inL R x)) (fun x : B => H_h (inR R x))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 128;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 289)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall b : B, hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 312)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 129;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 315)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists (fun a : A => h (inL R a) = h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 130;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 318)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  {a : A & R a b} -> {a : A & h (inL R a) = h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 131;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 323)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A & h (inL R a0) = h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 132;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 325)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	  h (inL R a) = h (inR R b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 133;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 286)		subgoal 1 (ID 286) is:	 equal_img (fun x : A => H_h (inL R x)) (fun x : B => H_h (inR R x))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 134;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 286)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  equal_img (fun x : A => H_h (inL R x)) (fun x : B => H_h (inR R x))		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 335)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall a : A, hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		subgoal 2 (ID 336) is:	 forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 135;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 335)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall a : A, hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 337)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 136;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 340)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists (fun b : B => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 137;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 343)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  ============================	  {b : B & R a b} -> {b : B & H_h (inL R a) = H_h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 138;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 348)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B & H_h (inL R a) = H_h (inR R b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 139;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 350)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  a : A	  b : B	  r : R a b	  ============================	  H_h (inL R a) = H_h (inR R b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 140;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 336)		subgoal 1 (ID 336) is:	 forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 141;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 336)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  ============================	  forall b : B, hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 359)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 142;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 362)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists (fun a : A => H_h (inL R a) = H_h (inR R b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 143;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 365)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  ============================	  {a : A & R a b} -> {a : A & H_h (inL R a) = H_h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 144;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 370)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A & H_h (inL R a0) = H_h (inR R b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 145;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 372)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : RPushout R -> P	  b : B	  a : A	  r : R a b	  ============================	  H_h (inL R a) = H_h (inR R b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 146;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>V_rec' is defined</infomsg>	";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoal, subgoal 1 (ID 306)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall v : V, P v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoal, subgoal 1 (ID 306)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall v : V, P v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal, subgoal 1 (ID 309)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoal, subgoal 1 (ID 315)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoal, subgoal 1 (ID 328)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 157;
            data = "1 subgoal, subgoal 1 (ID 341)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoal, subgoal 1 (ID 348)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 159;
            data = "1 subgoal, subgoal 1 (ID 355)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 160;
            data = "2 subgoals, subgoal 1 (ID 359)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g		subgoal 2 (ID 361) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	 H_set B (fun x : B => h (inR R x)) (H_h oD inR R)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 161;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 359)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 363)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 364) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 162;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 363)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 365)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 163;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 368)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => R a b) -> hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 164;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 371)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  {b : B & R a b} -> {b : B & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 165;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 376)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B & f a = g b0}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 166;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 378)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  f a = g b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 167;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals, subgoal 1 (ID 364)		subgoal 1 (ID 364) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 361) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	 H_set B (fun x : B => h (inR R x)) (H_h oD inR R)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 168;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 364)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall b : B, hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 387)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 169;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 390)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => R a b) -> hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 170;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 393)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  {a : A & R a b} -> {a : A & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 171;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 398)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A & f a0 = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 172;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 400)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  f a = g b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 173;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 361)		subgoal 1 (ID 361) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	 H_set B (fun x : B => h (inR R x)) (H_h oD inR R)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 174;
            data = "1 subgoal, subgoal 1 (ID 361)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		2 subgoals, subgoal 1 (ID 474)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  transport P (setext' (h o inL R) (h o inR R) eq_img)	    (H_set A (h o inL R) (H_h oD inL R))		subgoal 2 (ID 475) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (fun x : B => h (inR R x)) (H_h oD inR R)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 175;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 474)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  transport P (setext' (h o inL R) (h o inR R) eq_img)	    (H_set A (h o inL R) (H_h oD inL R))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 501)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  setext R bitot_R h =	  setext' (fun x : A => h (inL R x)) (fun x : B => h (inR R x)) eq_img		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 176;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 475)		subgoal 1 (ID 475) is:	 transport P (setext' (h o inL R) (h o inR R) eq_img)	   (H_set A (h o inL R) (H_h oD inL R)) =	 H_set B (fun x : B => h (inR R x)) (H_h oD inR R)	(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 475)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext' (h o inL R) (h o inR R) eq_img)	    (H_set A (h o inL R) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 596)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  (forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	  (forall b : B,	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 177;
            data = "2 subgoals, subgoal 1 (ID 598)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		subgoal 2 (ID 599) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 178;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 598)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 600)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 179;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 604)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 180;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 605)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 181;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 608)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  {b : B & R a b} ->	  {b : B & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 182;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 613)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {b0 : B & hexists (fun p : f a = g b0 => transport P p (H_f a) = H_g b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 183;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 615)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 184;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 618)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 185;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 628)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 186;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 649)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (glue R a b Rab)) (H_f a) =	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 187;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 653)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	  transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 188;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 654)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	  transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 189;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 599)		subgoal 1 (ID 599) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 190;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 599)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 659)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 191;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 663)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 192;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 664)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 193;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 667)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  {a : A & R a b} ->	  {a : A & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 194;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 672)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {a0 : A & hexists (fun p : f a0 = g b => transport P p (H_f a0) = H_g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 195;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 674)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 196;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 677)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 197;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 687)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (glue R a b Rab)) (H_f a) = H_g b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 198;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 708)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (glue R a b Rab)) (H_f a) =	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 199;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 712)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	  transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 200;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 713)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  f := (h o inL R : A -> V) : A -> V	  g := (h o inR R : B -> V) : B -> V	  H_f := (H_h oD inL R : forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD inR R : forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : RPushout R => P (h x)) (glue R a b Rab) (H_h (inL R a)) =	  transport P (ap h (glue R a b Rab)) (H_f a)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 201;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 202;
            data = "<infomsg>V_ind' is defined</infomsg>	";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "1 subgoal, subgoal 1 (ID 311)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall v : V, P v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 208;
            data = "1 subgoal, subgoal 1 (ID 311)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall v : V, P v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 209;
            data = "1 subgoal, subgoal 1 (ID 345)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : RPushout R -> V) (H_h : forall x : RPushout R, P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 210;
            data = "1 subgoal, subgoal 1 (ID 351)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : RPushout R -> V	  H_h : forall x : RPushout R, P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (inL R x)) (H_h oD inL R)) =	  H_set B (fun x : B => h (inR R x)) (H_h oD inR R)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 211;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 212;
            data = "<infomsg>V_ind_hprop is defined</infomsg>	";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "<infomsg>ua is declared</infomsg>	";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "1 subgoal, subgoal 1 (ID 313)	  	  ua : Univalence	  x : V	  ============================	  V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 223;
            data = "1 subgoal, subgoal 1 (ID 313)	  	  ua : Univalence	  x : V	  ============================	  V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 224;
            data = "2 subgoals, subgoal 1 (ID 316)	  	  ua : Univalence	  x : V	  ============================	  forall A : Type, (A -> V) -> (A -> hProp) -> hProp		subgoal 2 (ID 317) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g -> ?Goal A f H_f = ?Goal B g H_g	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 225;
            data = "2 subgoals, subgoal 1 (ID 322)	  	  ua : Univalence	  x : V	  A : Type	  f : A -> V	  ============================	  hProp		subgoal 2 (ID 317) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?Goal0@{A:=A0; f:=f0})	   A f H_f =	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) => ?Goal0@{A:=A0; f:=f0})	   B g H_g	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 226;
            data = "1 subgoal, subgoal 1 (ID 317)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) A f H_f =	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) B g H_g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 227;
            data = "1 subgoal, subgoal 1 (ID 325)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 228;
            data = "1 subgoal, subgoal 1 (ID 336)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 229;
            data = "2 subgoals, subgoal 1 (ID 342)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		subgoal 2 (ID 343) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 230;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 342)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 344)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	  Trunc (-1) {a : B & g a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 231;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 350)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	  {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 232;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 355)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  Trunc (-1) {a0 : B & g a0 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 233;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 358)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  hexists (fun b : B => f a = g b) -> Trunc (-1) {a0 : B & g a0 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 234;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 361)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  {b : B & f a = g b} -> {a0 : B & g a0 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 235;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 366)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  {a0 : B & g a0 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 236;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 368)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  g b = x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 237;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 343)		subgoal 1 (ID 343) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 238;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 343)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 391)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	  Trunc (-1) {a : A & f a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 239;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 397)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	  {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 240;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 402)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  Trunc (-1) {a : A & f a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 241;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 405)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  hexists (fun a : A => f a = g b) -> Trunc (-1) {a : A & f a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 242;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 408)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  {a : A & f a = g b} -> {a : A & f a = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 243;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 413)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 244;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 415)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  f a = x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 245;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 246;
            data = "<infomsg>mem is defined</infomsg>	";
            responses[i]=data;
          

            i = 247;
            data = "";
            responses[i]=data;
          

            i = 248;
            data = "";
            responses[i]=data;
          

            i = 249;
            data = "";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "";
            responses[i]=data;
          

            i = 256;
            data = "<infomsg>subset is defined</infomsg>	";
            responses[i]=data;
          

            i = 257;
            data = "";
            responses[i]=data;
          

            i = 258;
            data = "";
            responses[i]=data;
          

            i = 259;
            data = "";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "";
            responses[i]=data;
          

            i = 265;
            data = "1 subgoal, subgoal 1 (ID 424)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 266;
            data = "1 subgoal, subgoal 1 (ID 424)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 267;
            data = "2 subgoals, subgoal 1 (ID 663)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  IsHSet hProp		subgoal 2 (ID 664) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 268;
            data = "1 subgoal, subgoal 1 (ID 664)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	  equal_img f0 g ->	  forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	  equal_img H_f0 H_g ->	  BuildhProp	    ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	     (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	  BuildhProp	    ((forall a : A, hexists (fun b : B => H_f a (g b))) *	     (forall b : B, hexists (fun a : A => H_f a (g b))))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 269;
            data = "1 subgoal, subgoal 1 (ID 719)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  BuildhProp	    ((forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	     (forall b : B, Trunc (-1) {a : A & H_f a (g b)})) =	  BuildhProp	    ((forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	     (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 270;
            data = "2 subgoals, subgoal 1 (ID 725)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})		subgoal 2 (ID 726) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 271;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 725)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 733)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}		subgoal 2 (ID 734) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 272;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 733)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 735)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 273;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 741)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  {b : B & H_f a (g b)} -> Trunc (-1) {b : B' & H_f a (g' b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 274;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 746)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 275;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 749)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  hexists (fun b0 : B' => g b = g' b0) ->	  Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 276;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 750)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  merely {b0 : B' & g b = g' b0} -> Trunc (-1) {b0 : B' & H_f a (g' b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 277;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 755)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  {b0 : B' & g b = g' b0} -> {b0 : B' & H_f a (g' b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 278;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 760)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  {b0 : B' & H_f a (g' b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 279;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 762)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  H_f a (g' b')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 280;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 734)		subgoal 1 (ID 734) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	subgoal 2 (ID 726) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 281;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 734)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall b : B', Trunc (-1) {a : A & H_f a (g' b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 766)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 282;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 776)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  {a : B & g a = g' b'} -> Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 283;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 781)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 284;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 782)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g b)} -> Trunc (-1) {a : A & H_f a (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 285;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 785)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  {a : A & H_f a (g b)} -> {a : A & H_f a (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 286;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 790)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  {a0 : A & H_f a0 (g' b')}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 287;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 792)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  H_f a (g' b')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 288;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 726)		subgoal 1 (ID 726) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 289;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 726)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)})		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 802)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Trunc (-1) {b : B & H_f a (g b)}		subgoal 2 (ID 803) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 290;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 802)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Trunc (-1) {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 804)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  Trunc (-1) {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 291;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 810)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  {b : B' & H_f a (g' b)} -> Trunc (-1) {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 292;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 815)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  Trunc (-1) {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 293;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 818)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  hexists (fun a0 : B => g a0 = g' b') -> Trunc (-1) {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 294;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 821)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  {a0 : B & g a0 = g' b'} -> {b : B & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 295;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 826)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  {b0 : B & H_f a (g b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 296;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 828)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  H_f a (g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 297;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 803)		subgoal 1 (ID 803) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 298;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 803)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall b : B, Trunc (-1) {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 835)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  Trunc (-1) {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 299;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 845)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  {b0 : B' & g b = g' b0} -> Trunc (-1) {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 300;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 850)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 301;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 851)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')} -> Trunc (-1) {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 302;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 854)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  {a : A & H_f a (g' b')} -> {a : A & H_f a (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 303;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 859)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  {a0 : A & H_f a0 (g b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 304;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 861)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  H_f a (g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 305;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 306;
            data = "<infomsg>bisim_aux is defined</infomsg>	";
            responses[i]=data;
          

            i = 307;
            data = "1 subgoal, subgoal 1 (ID 425)	  	  ua : Univalence	  ============================	  V -> V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 308;
            data = "1 subgoal, subgoal 1 (ID 425)	  	  ua : Univalence	  ============================	  V -> V -> hProp		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 309;
            data = "1 subgoal, subgoal 1 (ID 479)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V -> hProp) (H_g : B -> V -> hProp),	  equal_img H_f H_g -> bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 310;
            data = "1 subgoal, subgoal 1 (ID 487)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f = bisim_aux B g H_g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 311;
            data = "1 subgoal, subgoal 1 (ID 502)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f == bisim_aux B g H_g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 312;
            data = "1 subgoal, subgoal 1 (ID 617)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, bisim_aux A f H_f (f0 a) = bisim_aux B g H_g (f0 a)) ->	  bisim_aux A f H_f (set f0) = bisim_aux B g H_g (set f0)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 313;
            data = "1 subgoal, subgoal 1 (ID 622)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  bisim_aux A f H_f (set h) = bisim_aux B g H_g (set h)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 314;
            data = "2 subgoals, subgoal 1 (ID 630)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)})		subgoal 2 (ID 633) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 315;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 630)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)})		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 640)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Trunc (-1) {b : C & H_g a (h b)}		subgoal 2 (ID 641) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 316;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 640)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Trunc (-1) {b : C & H_g a (h b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 642)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 317;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 652)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  {a : A & H_f a = H_g b} -> Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 318;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 657)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 319;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 658)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_f a (h b0)} -> Trunc (-1) {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 320;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 661)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  {b0 : C & H_f a (h b0)} -> {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 321;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 666)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  {b0 : C & H_g b (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 322;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 668)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  H_g b (h c)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 323;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 641)		subgoal 1 (ID 641) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	subgoal 2 (ID 633) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 324;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 641)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall b : C, Trunc (-1) {a : B & H_g a (h b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 677)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  Trunc (-1) {a : B & H_g a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 325;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 683)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  {a : A & H_f a (h c)} -> Trunc (-1) {a : B & H_g a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 326;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 688)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  Trunc (-1) {a0 : B & H_g a0 (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 327;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 691)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  hexists (fun b : B => H_f a = H_g b) -> Trunc (-1) {a0 : B & H_g a0 (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 328;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 694)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  {b : B & H_f a = H_g b} -> {a0 : B & H_g a0 (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 329;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 699)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  {a0 : B & H_g a0 (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 330;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 701)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  H_g b (h c)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 331;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 633)		subgoal 1 (ID 633) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 332;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 633)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)})		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 716)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Trunc (-1) {b : C & H_f a (h b)}		subgoal 2 (ID 717) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 333;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 716)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Trunc (-1) {b : C & H_f a (h b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 718)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  Trunc (-1) {b : C & H_f a (h b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 334;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 728)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  {b : B & H_f a = H_g b} -> Trunc (-1) {b : C & H_f a (h b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 335;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 733)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_f a (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 336;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 734)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)} -> Trunc (-1) {b0 : C & H_f a (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 337;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 737)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  {b0 : C & H_g b (h b0)} -> {b0 : C & H_f a (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 338;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 742)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  {b0 : C & H_f a (h b0)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 339;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 744)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  H_f a (h c)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 340;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 717)		subgoal 1 (ID 717) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 341;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 717)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall b : C, Trunc (-1) {a : A & H_f a (h b)}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 756)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  Trunc (-1) {a : A & H_f a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 342;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 762)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  {a : B & H_g a (h c)} -> Trunc (-1) {a : A & H_f a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 343;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 767)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  Trunc (-1) {a : A & H_f a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 344;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 770)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  hexists (fun a : A => H_f a = H_g b) -> Trunc (-1) {a : A & H_f a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 345;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 773)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  {a : A & H_f a = H_g b} -> {a : A & H_f a (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 346;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 778)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  {a0 : A & H_f a0 (h c)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 347;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 780)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  H_f a (h c)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 348;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 349;
            data = "<infomsg>bisimulation is defined</infomsg>	";
            responses[i]=data;
          

            i = 350;
            data = "";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "1 subgoal, subgoal 1 (ID 427)	  	  ua : Univalence	  ============================	  Reflexive (fun x x0 : V => x ~~ x0)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 353;
            data = "1 subgoal, subgoal 1 (ID 442)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, f a ~~ f a) -> set f ~~ set f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 354;
            data = "1 subgoal, subgoal 1 (ID 452)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  (forall a : A,	   Trunc (-1)	     {b : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x))) @	        path_forall	          (bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x)))	          (bisim_aux B (fun x : B => h (inR R x))	             (fun x : B => H_h (inR R x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0 (fun x : A0 => h (inL R x))	                (fun x : A0 => H_h (inL R x)) v =	              bisim_aux B (fun x : B => h (inR R x))	                (fun x : B => H_h (inR R x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (fun x : A0 => h (inL R x))	                       (fun x : A0 => H_h (inL R x)) 	                       (h0 a0) =	                     bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) 	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                X0 in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b1 : C =>	                                  trunctype_type	                                    (H_h	                                       (inL R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) 	                                       (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 => trunctype_type (R a0 b0))	                                      s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B =>	                                    H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) = 	                                    H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                            X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                  (proj1_sig, proj2_sig) as s	                                   return	                                     ((fun b0 : B =>	                                       trunctype_type	                                         (R (let ... X0 in proj1_sig) b0))	                                        s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                X0 in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : C =>	                                  trunctype_type	                                    (H_h	                                       (inR R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) 	                                       (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B => trunctype_type (R a0 b0))	                                      s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) =	                                    H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : B =>	                                 trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                            X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                  (proj1_sig, proj2_sig) as s	                                   return	                                     ((fun a0 : A0 =>	                                       trunctype_type	                                         (R a0 (let ... X0 in proj1_sig)))	                                        s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (fun x : A0 => h (inL R x))	                   (fun x : A0 => H_h (inL R x)) v)	                (bisim_aux B (fun x : B => h (inR R x))	                   (fun x : B => H_h (inR R x)) v)))) 	       (f a) (f b)}) *	  (forall b : A,	   Trunc (-1)	     {a : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x))) @	        path_forall	          (bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x)))	          (bisim_aux B (fun x : B => h (inR R x))	             (fun x : B => H_h (inR R x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0 (fun x : A0 => h (inL R x))	                (fun x : A0 => H_h (inL R x)) v =	              bisim_aux B (fun x : B => h (inR R x))	                (fun x : B => H_h (inR R x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0 (fun x : A0 => h (inL R x))	                       (fun x : A0 => H_h (inL R x)) 	                       (h0 a0) =	                     bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) 	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b1)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                X0 in	                              proj2_sig)	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b1 : C =>	                                  trunctype_type	                                    (H_h	                                       (inL R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) 	                                       (h0 b1))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 => trunctype_type (R a0 b0))	                                      s.1) := X0 in	                              proj2_sig)))) (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig)) =	                              H_h (inR R b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B =>	                                    H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) = 	                                    H_h (inR R b0)) s.1) := X1 in	                             proj2_sig) (h0 c))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                            X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {b0 : B &	                                 R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                               (let (proj1_sig, _) := X1 in proj1_sig)	                               (let	                                  (proj1_sig, proj2_sig) as s	                                   return	                                     ((fun b0 : B =>	                                       trunctype_type	                                         (R (let ... X0 in proj1_sig) b0))	                                        s.1) := X1 in	                                proj2_sig))))	                         (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))	                                 (h0 b0)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                X0 in	                              proj2_sig)^	                             (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : C =>	                                  trunctype_type	                                    (H_h	                                       (inR R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) 	                                       (h0 b0))) s.1) := X1 in	                           proj2_sig)))	                       ((let (fst, _) := X in fst)	                          (let (proj1_sig, _) := X0 in proj1_sig)))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (let (proj1_sig, _) := X0 in proj1_sig;	                        ap H_h	                          (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B => trunctype_type (R a0 b0))	                                      s.1) := X0 in	                              proj2_sig)))) (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h (inL R a0) =	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) =	                                    H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                             proj2_sig)^ (h0 c))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : B =>	                                 trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                            X0 in	                          proj2_sig)))	                      (Trunc_functor (-1)	                         (fun	                            X1 : {a0 : A0 &	                                 R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                          =>	                          (let (proj1_sig, _) := X1 in proj1_sig;	                          ap H_h	                            (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                               (let (proj1_sig, _) := X0 in proj1_sig)	                               (let	                                  (proj1_sig, proj2_sig) as s	                                   return	                                     ((fun a0 : A0 =>	                                       trunctype_type	                                         (R a0 (let ... X0 in proj1_sig)))	                                        s.1) := X1 in	                                proj2_sig))))	                         (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                   ((let (_, snd) := X in snd) c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0 (fun x : A0 => h (inL R x))	                   (fun x : A0 => H_h (inL R x)) v)	                (bisim_aux B (fun x : B => h (inR R x))	                   (fun x : B => H_h (inR R x)) v)))) 	       (f a) (f b)})		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 355;
            data = "2 subgoals, subgoal 1 (ID 454)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Trunc (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x))) @	       path_forall	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x)))	         (bisim_aux B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0 (fun x : A0 => h (inL R x))	               (fun x : A0 => H_h (inL R x)) v =	             bisim_aux B (fun x : B => h (inR R x))	               (fun x : B => H_h (inR R x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (fun x : A0 => h (inL R x))	                      (fun x : A0 => H_h (inL R x)) 	                      (h0 a0) =	                    bisim_aux B (fun x : B => h (inR R x))	                      (fun x : B => H_h (inR R x)) 	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b1)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b1 : C =>	                                 trunctype_type	                                   (H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b1))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                             H_h (inR R b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) = 	                                   H_h (inR R b0)) s.1) := X1 in	                            proj2_sig) (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B &	                                R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                              (let (proj1_sig, _) := X1 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      trunctype_type	                                        (R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig) b0)) s.1) := X1 in	                               proj2_sig))))	                        (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)^	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : C =>	                                 trunctype_type	                                   (H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b0))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h (inL R a0) =	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                      =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) =	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig))) s.1) := X1 in	                            proj2_sig)^ (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : B =>	                                trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {a0 : A0 &	                                R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                              (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A0 =>	                                      trunctype_type	                                        (R a0	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig))) s.1) := X1 in	                               proj2_sig))))	                        (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (fun x : A0 => h (inL R x))	                  (fun x : A0 => H_h (inL R x)) v)	               (bisim_aux B (fun x : B => h (inR R x))	                  (fun x : B => H_h (inR R x)) v)))) 	      (f a) (f b)}		subgoal 2 (ID 455) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (fun x : A0 => h (inL R x))	           (fun x : A0 => H_h (inL R x))) @	      path_forall	        (bisim_aux A0 (fun x : A0 => h (inL R x))	           (fun x : A0 => H_h (inL R x)))	        (bisim_aux B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0 (fun x : A0 => h (inL R x))	              (fun x : A0 => H_h (inL R x)) v =	            bisim_aux B (fun x : B => h (inR R x))	              (fun x : B => H_h (inR R x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (fun x : A0 => h (inL R x))	                     (fun x : A0 => H_h (inL R x)) 	                     (h0 a0) =	                   bisim_aux B (fun x : B => h (inR R x))	                     (fun x : B => H_h (inR R x)) 	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                              X0 in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun b1 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     trunctype_type	                                       (R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig) b0)) s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                              X0 in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : B =>	                               trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     trunctype_type	                                       (R a0	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (fun x : A0 => h (inL R x))	                 (fun x : A0 => H_h (inL R x)) v)	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)) v)))) 	     (f a) (f b)}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 356;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 454)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Trunc (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x))) @	       path_forall	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x)))	         (bisim_aux B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0 (fun x : A0 => h (inL R x))	               (fun x : A0 => H_h (inL R x)) v =	             bisim_aux B (fun x : B => h (inR R x))	               (fun x : B => H_h (inR R x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (fun x : A0 => h (inL R x))	                      (fun x : A0 => H_h (inL R x)) 	                      (h0 a0) =	                    bisim_aux B (fun x : B => h (inR R x))	                      (fun x : B => H_h (inR R x)) 	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b1)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b1 : C =>	                                 trunctype_type	                                   (H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b1))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                             H_h (inR R b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) = 	                                   H_h (inR R b0)) s.1) := X1 in	                            proj2_sig) (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B &	                                R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                              (let (proj1_sig, _) := X1 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      trunctype_type	                                        (R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig) b0)) s.1) := X1 in	                               proj2_sig))))	                        (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)^	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : C =>	                                 trunctype_type	                                   (H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b0))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h (inL R a0) =	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                      =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) =	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig))) s.1) := X1 in	                            proj2_sig)^ (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : B =>	                                trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {a0 : A0 &	                                R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                              (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A0 =>	                                      trunctype_type	                                        (R a0	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig))) s.1) := X1 in	                               proj2_sig))))	                        (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (fun x : A0 => h (inL R x))	                  (fun x : A0 => H_h (inL R x)) v)	               (bisim_aux B (fun x : B => h (inR R x))	                  (fun x : B => H_h (inR R x)) v)))) 	      (f a) (f b)}		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 357;
            data = "1 subgoal, subgoal 1 (ID 455)		subgoal 1 (ID 455) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0 (fun x : A0 => h (inL R x))	           (fun x : A0 => H_h (inL R x))) @	      path_forall	        (bisim_aux A0 (fun x : A0 => h (inL R x))	           (fun x : A0 => H_h (inL R x)))	        (bisim_aux B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0 (fun x : A0 => h (inL R x))	              (fun x : A0 => H_h (inL R x)) v =	            bisim_aux B (fun x : B => h (inR R x))	              (fun x : B => H_h (inR R x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0 (fun x : A0 => h (inL R x))	                     (fun x : A0 => H_h (inL R x)) 	                     (h0 a0) =	                   bisim_aux B (fun x : B => h (inR R x))	                     (fun x : B => H_h (inR R x)) 	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b1)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                              X0 in	                            proj2_sig)	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun b1 : C =>	                                trunctype_type	                                  (H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                            proj2_sig)))) (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                            H_h (inR R b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B =>	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)) s.1) := X1 in	                           proj2_sig) (h0 c))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : A0 =>	                               trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                          X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {b0 : B &	                               R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                             (let (proj1_sig, _) := X1 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b0 : B =>	                                     trunctype_type	                                       (R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig) b0)) s.1) := X1 in	                              proj2_sig))))	                       (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                               (h0 b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                              X0 in	                            proj2_sig)^	                           (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun b0 : C =>	                                trunctype_type	                                  (H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0))) s.1) := X1 in	                         proj2_sig)))	                     ((let (fst, _) := X in fst)	                        (let (proj1_sig, _) := X0 in proj1_sig)))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (let (proj1_sig, _) := X0 in proj1_sig;	                      ap H_h	                        (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B => trunctype_type (R a0 b0))	                                    s.1) := X0 in	                            proj2_sig)))) (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (inL R a0) =	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                     =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig)))	                                   s.1) := X1 in	                           proj2_sig)^ (h0 c))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun a0 : B =>	                               trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                          X0 in	                        proj2_sig)))	                    (Trunc_functor (-1)	                       (fun	                          X1 : {a0 : A0 &	                               R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        ap H_h	                          (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                             (let (proj1_sig, _) := X0 in proj1_sig)	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A0 =>	                                     trunctype_type	                                       (R a0	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                              proj2_sig))))	                       (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                 ((let (_, snd) := X in snd) c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0 (fun x : A0 => h (inL R x))	                 (fun x : A0 => H_h (inL R x)) v)	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)) v)))) 	     (f a) (f b)}	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 455)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall b : A,	  Trunc (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x))) @	       path_forall	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x)))	         (bisim_aux B (fun x : B => h (inR R x)) (fun x : B => H_h (inR R x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0 (fun x : A0 => h (inL R x))	               (fun x : A0 => H_h (inL R x)) v =	             bisim_aux B (fun x : B => h (inR R x))	               (fun x : B => H_h (inR R x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (fun x : A0 => h (inL R x))	                      (fun x : A0 => H_h (inL R x)) 	                      (h0 a0) =	                    bisim_aux B (fun x : B => h (inR R x))	                      (fun x : B => H_h (inR R x)) 	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b1)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b1 : C =>	                                 trunctype_type	                                   (H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b1))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                             H_h (inR R b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B =>	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) = 	                                   H_h (inR R b0)) s.1) := X1 in	                            proj2_sig) (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B &	                                R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                              (let (proj1_sig, _) := X1 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B =>	                                      trunctype_type	                                        (R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig) b0)) s.1) := X1 in	                               proj2_sig))))	                        (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)^	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : C =>	                                 trunctype_type	                                   (H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b0))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h (inL R a0) =	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                      =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) =	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig))) s.1) := X1 in	                            proj2_sig)^ (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : B =>	                                trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {a0 : A0 &	                                R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                              (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A0 =>	                                      trunctype_type	                                        (R a0	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig))) s.1) := X1 in	                               proj2_sig))))	                        (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (fun x : A0 => h (inL R x))	                  (fun x : A0 => H_h (inL R x)) v)	               (bisim_aux B (fun x : B => h (inR R x))	                  (fun x : B => H_h (inR R x)) v)))) 	      (f a) (f b)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 358;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		<infomsg>reflexive_bisimulation is defined</infomsg>	";
            responses[i]=data;
          

            i = 359;
            data = "1 subgoal, subgoal 1 (ID 429)	  	  ua : Univalence	  ============================	  forall u v : V, u = v <~> u ~~ v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 360;
            data = "1 subgoal, subgoal 1 (ID 429)	  	  ua : Univalence	  ============================	  forall u v : V, u = v <~> u ~~ v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 361;
            data = "1 subgoal, subgoal 1 (ID 431)	  	  ua : Univalence	  u, v : V	  ============================	  u = v <~> u ~~ v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 362;
            data = "2 subgoals, subgoal 1 (ID 468)	  	  ua : Univalence	  u, v : V	  ============================	  u = v -> u ~~ v		subgoal 2 (ID 469) is:	 u ~~ v -> u = v	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 363;
            data = "1 subgoal, subgoal 1 (ID 469)	  	  ua : Univalence	  u, v : V	  ============================	  u ~~ v -> u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 364;
            data = "1 subgoal, subgoal 1 (ID 474)	  	  ua : Univalence	  u, v : V	  ============================	  forall u0 v0 : V, u0 ~~ v0 -> u0 = v0		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 365;
            data = "1 subgoal, subgoal 1 (ID 662)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  ============================	  forall v0 : V, set f ~~ v0 -> set f = v0		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 366;
            data = "1 subgoal, subgoal 1 (ID 825)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  ============================	  set f ~~ set g -> set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 367;
            data = "1 subgoal, subgoal 1 (ID 837)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 368;
            data = "1 subgoal, subgoal 1 (ID 840)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  ============================	  equal_img f g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 369;
            data = "2 subgoals, subgoal 1 (ID 842)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 843) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 370;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 842)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 844)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  a : A	  ============================	  hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 371;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 845)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  a : A	  ============================	  Trunc (-1)	    {b : B &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R) (h : RPushout R -> V)	         (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x))) @	       path_forall	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x)))	         (bisim_aux B0 (fun x : B0 => h (inR R x))	            (fun x : B0 => H_h (inR R x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0 (fun x : A0 => h (inL R x))	               (fun x : A0 => H_h (inL R x)) v0 =	             bisim_aux B0 (fun x : B0 => h (inR R x))	               (fun x : B0 => H_h (inR R x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (fun x : A0 => h (inL R x))	                      (fun x : A0 => H_h (inL R x)) 	                      (h0 a0) =	                    bisim_aux B0 (fun x : B0 => h (inR R x))	                      (fun x : B0 => H_h (inR R x)) 	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b1)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b1 : C =>	                                 trunctype_type	                                   (H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b1))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                             H_h (inR R b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B0 =>	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) = 	                                   H_h (inR R b0)) s.1) := X1 in	                            proj2_sig) (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B0 &	                                R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                              (let (proj1_sig, _) := X1 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B0 =>	                                      trunctype_type	                                        (R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig) b0)) s.1) := X1 in	                               proj2_sig))))	                        (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c)))	               (fun	                  X : (forall a0 : B0,	                       Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)^	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : C =>	                                 trunctype_type	                                   (H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b0))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h (inL R a0) =	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                      =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) =	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig))) s.1) := X1 in	                            proj2_sig)^ (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : B0 =>	                                trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {a0 : A0 &	                                R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                              (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A0 =>	                                      trunctype_type	                                        (R a0	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig))) s.1) := X1 in	                               proj2_sig))))	                        (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (fun x : A0 => h (inL R x))	                  (fun x : A0 => H_h (inL R x)) v0)	               (bisim_aux B0 (fun x : B0 => h (inR R x))	                  (fun x : B0 => H_h (inR R x)) v0)))) 	      (f a) (g b)} -> hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 372;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 848)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  a : A	  ============================	  {b : B &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0 (fun x : A0 => h (inL R x))	          (fun x : A0 => H_h (inL R x))) @	     path_forall	       (bisim_aux A0 (fun x : A0 => h (inL R x))	          (fun x : A0 => H_h (inL R x)))	       (bisim_aux B0 (fun x : B0 => h (inR R x))	          (fun x : B0 => H_h (inR R x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x)) v0 =	           bisim_aux B0 (fun x : B0 => h (inR R x))	             (fun x : B0 => H_h (inR R x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0 (fun x : A0 => h (inL R x))	                    (fun x : A0 => H_h (inL R x)) 	                    (h0 a0) =	                  bisim_aux B0 (fun x : B0 => h (inR R x))	                    (fun x : B0 => H_h (inR R x)) 	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                              (h0 b1)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                             X0 in	                           proj2_sig)	                          (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                        proj2_sig)))	                    ((let (fst, _) := X in fst)	                       (let (proj1_sig, _) := X0 in proj1_sig)))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (let (proj1_sig, _) := X0 in proj1_sig;	                     ap H_h	                       (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                           proj2_sig)))) (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                           H_h (inR R b0)} =>	                    (let (proj1_sig, _) := X1 in proj1_sig;	                    transport trunctype_type	                      (ap10	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B0 =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                          proj2_sig) (h0 c))	                      (let	                         (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                         X0 in	                       proj2_sig)))	                   (Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B0 &	                              R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                            (let (proj1_sig, _) := X1 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 =>	                                    trunctype_type	                                      (R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig) b0)) s.1) := X1 in	                             proj2_sig))))	                      (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                ((let (_, snd) := X in snd) c)))	             (fun	                X : (forall a0 : B0,	                     Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                              (h0 b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                             X0 in	                           proj2_sig)^	                          (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                        proj2_sig)))	                    ((let (fst, _) := X in fst)	                       (let (proj1_sig, _) := X0 in proj1_sig)))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (let (proj1_sig, _) := X0 in proj1_sig;	                     ap H_h	                       (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                           proj2_sig)))) (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (inL R a0) =	                           H_h	                             (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                    =>	                    (let (proj1_sig, _) := X1 in proj1_sig;	                    transport trunctype_type	                      (ap10	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                          proj2_sig)^ (h0 c))	                      (let	                         (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B0 =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                         X0 in	                       proj2_sig)))	                   (Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                            (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                             proj2_sig))))	                      (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                ((let (_, snd) := X in snd) c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0 (fun x : A0 => h (inL R x))	                (fun x : A0 => H_h (inL R x)) v0)	             (bisim_aux B0 (fun x : B0 => h (inR R x))	                (fun x : B0 => H_h (inR R x)) v0)))) 	    (f a) (g b)} -> {b : B & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 373;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 853)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  a : A	  b : B	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A (fun x : A => h (inL R x))	              (fun x : A => H_h (inL R x))) @	         path_forall	           (bisim_aux A (fun x : A => h (inL R x))	              (fun x : A => H_h (inL R x)))	           (bisim_aux B (fun x : B => h (inR R x))	              (fun x : B => H_h (inR R x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)) v =	               bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A (fun x : A => h (inL R x))	                        (fun x : A => H_h (inL R x)) 	                        (h0 a) =	                      bisim_aux B (fun x : B => h (inR R x))	                        (fun x : B => H_h (inR R x)) 	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1) {b : C & H_h (inL R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : A & H_h (inL R a) (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun X0 : {a : A & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a : A =>	                                      H_h (inL R a) = H_h (inR R b)) s.1) :=	                                 X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a : A => trunctype_type (R a b))	                                       s.1) := X0 in	                               proj2_sig)))) (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : A & H_h (inL R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b : B =>	                                     H_h	                                       (inL R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : A =>	                                  trunctype_type (H_h (inL R a) (h0 c))) s.1) :=	                             X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig) b}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b : B =>	                                        trunctype_type	                                          (R	                                             (let (proj1_sig, _) := X0 in	                                              proj1_sig) b)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1) {b : C & H_h (inR R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : B & H_h (inR R a) (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun X0 : {b : B & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b : B =>	                                      H_h (inL R a) = H_h (inR R b)) s.1) :=	                                 X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b : B => trunctype_type (R a b))	                                       s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : B & H_h (inR R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h (inL R a) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a : A =>	                                     H_h (inL R a) =	                                     H_h	                                       (inR R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : B =>	                                  trunctype_type (H_h (inR R a) (h0 c))) s.1) :=	                             X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a : A &	                                  R a (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a : A =>	                                        trunctype_type	                                          (R a	                                             (let (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v)	                 (bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)))) 	        (f a) (g b)	  ============================	  {b0 : B & f a = g b0}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 374;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 843)		subgoal 1 (ID 843) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 375;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 843)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  ============================	  forall b : B, hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 856)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  b : B	  ============================	  hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 376;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 857)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  b : B	  ============================	  Trunc (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R) (h : RPushout R -> V)	         (H_h : RPushout R -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x))) @	       path_forall	         (bisim_aux A0 (fun x : A0 => h (inL R x))	            (fun x : A0 => H_h (inL R x)))	         (bisim_aux B0 (fun x : B0 => h (inR R x))	            (fun x : B0 => H_h (inR R x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0 (fun x : A0 => h (inL R x))	               (fun x : A0 => H_h (inL R x)) v0 =	             bisim_aux B0 (fun x : B0 => h (inR R x))	               (fun x : B0 => H_h (inR R x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0 (fun x : A0 => h (inL R x))	                      (fun x : A0 => H_h (inL R x)) 	                      (h0 a0) =	                    bisim_aux B0 (fun x : B0 => h (inR R x))	                      (fun x : B0 => H_h (inR R x)) 	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (inL R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b1)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b1 : C =>	                                 trunctype_type	                                   (H_h	                                      (inL R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b1))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                             H_h (inR R b0)} =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : B0 =>	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) = 	                                   H_h (inR R b0)) s.1) := X1 in	                            proj2_sig) (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : A0 =>	                                trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {b0 : B0 &	                                R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                              (let (proj1_sig, _) := X1 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : B0 =>	                                      trunctype_type	                                        (R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig) b0)) s.1) := X1 in	                               proj2_sig))))	                        (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c)))	               (fun	                  X : (forall a0 : B0,	                       Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (inR R	                                   (let (proj1_sig, _) := X0 in proj1_sig))	                                (h0 b0)} =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       transport trunctype_type	                         (ap10	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 =>	                                    H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                               X0 in	                             proj2_sig)^	                            (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : C =>	                                 trunctype_type	                                   (H_h	                                      (inR R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig)) 	                                      (h0 b0))) s.1) := X1 in	                          proj2_sig)))	                      ((let (fst, _) := X in fst)	                         (let (proj1_sig, _) := X0 in proj1_sig)))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (let (proj1_sig, _) := X0 in proj1_sig;	                       ap H_h	                         (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 => trunctype_type (R a0 b0))	                                     s.1) := X0 in	                             proj2_sig)))) (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h (inL R a0) =	                             H_h	                               (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                      =>	                      (let (proj1_sig, _) := X1 in proj1_sig;	                      transport trunctype_type	                        (ap10	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun a0 : A0 =>	                                   H_h (inL R a0) =	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig))) s.1) := X1 in	                            proj2_sig)^ (h0 c))	                        (let	                           (proj1_sig, proj2_sig) as s	                            return	                              ((fun a0 : B0 =>	                                trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                           X0 in	                         proj2_sig)))	                     (Trunc_functor (-1)	                        (fun	                           X1 : {a0 : A0 &	                                R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                         =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                              (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a0 : A0 =>	                                      trunctype_type	                                        (R a0	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig))) s.1) := X1 in	                               proj2_sig))))	                        (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                  ((let (_, snd) := X in snd) c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0 (fun x : A0 => h (inL R x))	                  (fun x : A0 => H_h (inL R x)) v0)	               (bisim_aux B0 (fun x : B0 => h (inR R x))	                  (fun x : B0 => H_h (inR R x)) v0)))) 	      (f a) (g b)} -> hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 377;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 860)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  b : B	  ============================	  {a : A &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0 (fun x : A0 => h (inL R x))	          (fun x : A0 => H_h (inL R x))) @	     path_forall	       (bisim_aux A0 (fun x : A0 => h (inL R x))	          (fun x : A0 => H_h (inL R x)))	       (bisim_aux B0 (fun x : B0 => h (inR R x))	          (fun x : B0 => H_h (inR R x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0 (fun x : A0 => h (inL R x))	             (fun x : A0 => H_h (inL R x)) v0 =	           bisim_aux B0 (fun x : B0 => h (inR R x))	             (fun x : B0 => H_h (inR R x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0 (fun x : A0 => h (inL R x))	                    (fun x : A0 => H_h (inL R x)) 	                    (h0 a0) =	                  bisim_aux B0 (fun x : B0 => h (inR R x))	                    (fun x : B0 => H_h (inR R x)) 	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1) {a0 : A0 & H_h (inL R a0) (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun X0 : {a0 : A0 & H_h (inL R a0) = H_h (inR R b0)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (inL R (let (proj1_sig, _) := X0 in proj1_sig))	                              (h0 b1)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                             X0 in	                           proj2_sig)	                          (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun b1 : C =>	                               trunctype_type	                                 (H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b1))) s.1) := X1 in	                        proj2_sig)))	                    ((let (fst, _) := X in fst)	                       (let (proj1_sig, _) := X0 in proj1_sig)))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (let (proj1_sig, _) := X0 in proj1_sig;	                     ap H_h	                       (glue R (let (proj1_sig, _) := X0 in proj1_sig) b0	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a0 : A0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                           proj2_sig)))) (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun X0 : {a0 : A0 & H_h (inL R a0) (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (inL R (let (proj1_sig, _) := X0 in proj1_sig)) =	                           H_h (inR R b0)} =>	                    (let (proj1_sig, _) := X1 in proj1_sig;	                    transport trunctype_type	                      (ap10	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun b0 : B0 =>	                                 H_h	                                   (inL R	                                      (let (proj1_sig, _) := X0 in proj1_sig)) =	                                 H_h (inR R b0)) s.1) := X1 in	                          proj2_sig) (h0 c))	                      (let	                         (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : A0 =>	                              trunctype_type (H_h (inL R a0) (h0 c))) s.1) :=	                         X0 in	                       proj2_sig)))	                   (Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B0 &	                              R (let (proj1_sig, _) := X0 in proj1_sig) b0}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                            (let (proj1_sig, _) := X1 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun b0 : B0 =>	                                    trunctype_type	                                      (R	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig) b0)) s.1) := X1 in	                             proj2_sig))))	                      (fst bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                ((let (_, snd) := X in snd) c)))	             (fun	                X : (forall a0 : B0,	                     Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1) {a0 : B0 & H_h (inR R a0) (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun X0 : {b0 : B0 & H_h (inL R a0) = H_h (inR R b0)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (inR R (let (proj1_sig, _) := X0 in proj1_sig))	                              (h0 b0)} =>	                     (let (proj1_sig, _) := X1 in proj1_sig;	                     transport trunctype_type	                       (ap10	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 =>	                                  H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                             X0 in	                           proj2_sig)^	                          (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                       (let	                          (proj1_sig, proj2_sig) as s	                           return	                             ((fun b0 : C =>	                               trunctype_type	                                 (H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))	                                    (h0 b0))) s.1) := X1 in	                        proj2_sig)))	                    ((let (fst, _) := X in fst)	                       (let (proj1_sig, _) := X0 in proj1_sig)))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (let (proj1_sig, _) := X0 in proj1_sig;	                     ap H_h	                       (glue R a0 (let (proj1_sig, _) := X0 in proj1_sig)	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun b0 : B0 => trunctype_type (R a0 b0))	                                   s.1) := X0 in	                           proj2_sig)))) (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun X0 : {a0 : B0 & H_h (inR R a0) (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (inL R a0) =	                           H_h	                             (inR R (let (proj1_sig, _) := X0 in proj1_sig))}	                    =>	                    (let (proj1_sig, _) := X1 in proj1_sig;	                    transport trunctype_type	                      (ap10	                         (let	                            (proj1_sig, proj2_sig) as s	                             return	                               ((fun a0 : A0 =>	                                 H_h (inL R a0) =	                                 H_h	                                   (inR R	                                      (let (proj1_sig, _) := X0 in proj1_sig)))	                                  s.1) := X1 in	                          proj2_sig)^ (h0 c))	                      (let	                         (proj1_sig, proj2_sig) as s	                          return	                            ((fun a0 : B0 =>	                              trunctype_type (H_h (inR R a0) (h0 c))) s.1) :=	                         X0 in	                       proj2_sig)))	                   (Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              R a0 (let (proj1_sig, _) := X0 in proj1_sig)}	                       =>	                       (let (proj1_sig, _) := X1 in proj1_sig;	                       ap H_h	                         (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                            (let (proj1_sig, _) := X0 in proj1_sig)	                            (let	                               (proj1_sig, proj2_sig) as s	                                return	                                  ((fun a0 : A0 =>	                                    trunctype_type	                                      (R a0	                                         (let (proj1_sig, _) := X0 in	                                          proj1_sig))) s.1) := X1 in	                             proj2_sig))))	                      (snd bitot_R (let (proj1_sig, _) := X0 in proj1_sig))))	                ((let (_, snd) := X in snd) c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0 (fun x : A0 => h (inL R x))	                (fun x : A0 => H_h (inL R x)) v0)	             (bisim_aux B0 (fun x : B0 => h (inR R x))	                (fun x : B0 => H_h (inR R x)) v0)))) 	    (f a) (g b)} -> {a : A & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 378;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 865)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R) (h : RPushout R -> V)	              (H_h : RPushout R -> V -> hProp) =>	            transport_const (setext R bitot_R h)	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x))) @	            path_forall	              (bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)))	              (bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v =	                  bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A (fun x : A => h (inL R x))	                           (fun x : A => H_h (inL R x)) 	                           (h0 a0) =	                         bisim_aux B (fun x : B => h (inR R x))	                           (fun x : B => H_h (inR R x)) 	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1) {b0 : C & H_h (inL R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : A & H_h (inL R a0) (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun X0 : {a0 : A & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (inL R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b1)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b1 : C =>	                                      trunctype_type	                                        (H_h	                                           (inL R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b1))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                 b0	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun a0 : A =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : A & H_h (inL R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (inL R	                                       (let (proj1_sig, _) := X0 in proj1_sig)) =	                                  H_h (inR R b0)} =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b0 : B =>	                                        H_h (inL R (let ... X0 in proj1_sig)) =	                                        H_h (inR R b0)) s.1) := X1 in	                                 proj2_sig) (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : A =>	                                     trunctype_type (H_h (inL R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {b0 : B &	                                     R	                                       (let (proj1_sig, _) := X0 in proj1_sig)	                                       b0} =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun b0 : B =>	                                           trunctype_type	                                             (R (... proj1_sig) b0)) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (fst bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1) {b0 : C & H_h (inR R a0) (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1) {a0 : B & H_h (inR R a0) (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun X0 : {b0 : B & H_h (inL R a0) = H_h (inR R b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (inR R	                                        (let (proj1_sig, _) := X0 in	                                         proj1_sig)) 	                                     (h0 b0)} =>	                            (let (proj1_sig, _) := X1 in proj1_sig;	                            transport trunctype_type	                              (ap10	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         H_h (inL R a0) = H_h (inR R b0)) s.1) :=	                                    X0 in	                                  proj2_sig)^	                                 (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b0 : C =>	                                      trunctype_type	                                        (H_h	                                           (inR R	                                              (let (proj1_sig, _) := X0 in	                                               proj1_sig)) 	                                           (h0 b0))) s.1) := X1 in	                               proj2_sig)))	                           ((let (fst, _) := X in fst)	                              (let (proj1_sig, _) := X0 in proj1_sig)))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (let (proj1_sig, _) := X0 in proj1_sig;	                            ap H_h	                              (glue R a0	                                 (let (proj1_sig, _) := X0 in proj1_sig)	                                 (let	                                    (proj1_sig, proj2_sig) as s	                                     return	                                       ((fun b0 : B =>	                                         trunctype_type (R a0 b0)) s.1) :=	                                    X0 in	                                  proj2_sig)))) (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun X0 : {a0 : B & H_h (inR R a0) (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h (inL R a0) =	                                  H_h	                                    (inR R	                                       (let (proj1_sig, _) := X0 in proj1_sig))}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           transport trunctype_type	                             (ap10	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a0 : A =>	                                        H_h (inL R a0) =	                                        H_h (inR R (let ... X0 in proj1_sig)))	                                         s.1) := X1 in	                                 proj2_sig)^ (h0 c))	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a0 : B =>	                                     trunctype_type (H_h (inR R a0) (h0 c)))	                                      s.1) := X0 in	                              proj2_sig)))	                          (Trunc_functor (-1)	                             (fun	                                X1 : {a0 : A &	                                     R a0	                                       (let (proj1_sig, _) := X0 in proj1_sig)}	                              =>	                              (let (proj1_sig, _) := X1 in proj1_sig;	                              ap H_h	                                (glue R	                                   (let (proj1_sig, _) := X1 in proj1_sig)	                                   (let (proj1_sig, _) := X0 in proj1_sig)	                                   (let	                                      (proj1_sig, proj2_sig) as s	                                       return	                                         ((fun a0 : A =>	                                           trunctype_type	                                             (R a0 (... proj1_sig))) s.1) :=	                                      X1 in	                                    proj2_sig))))	                             (snd bitot_R	                                (let (proj1_sig, _) := X0 in proj1_sig))))	                       ((let (_, snd) := X in snd) c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A (fun x : A => h (inL R x))	                       (fun x : A => H_h (inL R x)) v)	                    (bisim_aux B (fun x : B => h (inR R x))	                       (fun x : B => H_h (inR R x)) v)))) 	           (f a) (g b)}	  b : B	  a : A	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : RPushout R -> V) (H_h : RPushout R -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A (fun x : A => h (inL R x))	              (fun x : A => H_h (inL R x))) @	         path_forall	           (bisim_aux A (fun x : A => h (inL R x))	              (fun x : A => H_h (inL R x)))	           (bisim_aux B (fun x : B => h (inR R x))	              (fun x : B => H_h (inR R x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A (fun x : A => h (inL R x))	                 (fun x : A => H_h (inL R x)) v =	               bisim_aux B (fun x : B => h (inR R x))	                 (fun x : B => H_h (inR R x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A (fun x : A => h (inL R x))	                        (fun x : A => H_h (inL R x)) 	                        (h0 a) =	                      bisim_aux B (fun x : B => h (inR R x))	                        (fun x : B => H_h (inR R x)) 	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1) {b : C & H_h (inL R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : A & H_h (inL R a) (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun X0 : {a : A & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (inL R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b0)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a : A =>	                                      H_h (inL R a) = H_h (inR R b)) s.1) :=	                                 X0 in	                               proj2_sig)	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b0 : C =>	                                   trunctype_type	                                     (H_h	                                        (inL R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b0))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R (let (proj1_sig, _) := X0 in proj1_sig) b	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun a : A => trunctype_type (R a b))	                                       s.1) := X0 in	                               proj2_sig)))) (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : A & H_h (inL R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (inL R	                                    (let (proj1_sig, _) := X0 in proj1_sig)) =	                               H_h (inR R b)} =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun b : B =>	                                     H_h	                                       (inL R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig)) = 	                                     H_h (inR R b)) s.1) := X1 in	                              proj2_sig) (h0 c))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : A =>	                                  trunctype_type (H_h (inL R a) (h0 c))) s.1) :=	                             X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {b : B &	                                  R (let (proj1_sig, _) := X0 in proj1_sig) b}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X0 in proj1_sig)	                                (let (proj1_sig, _) := X1 in proj1_sig)	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun b : B =>	                                        trunctype_type	                                          (R	                                             (let (proj1_sig, _) := X0 in	                                              proj1_sig) b)) s.1) := X1 in	                                 proj2_sig))))	                          (fst bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1) {b : C & H_h (inR R a) (h0 b)}) *	                        (forall b : C,	                         Trunc (-1) {a : B & H_h (inR R a) (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun X0 : {b : B & H_h (inL R a) = H_h (inR R b)} =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (inR R	                                     (let (proj1_sig, _) := X0 in proj1_sig))	                                  (h0 b)} =>	                         (let (proj1_sig, _) := X1 in proj1_sig;	                         transport trunctype_type	                           (ap10	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b : B =>	                                      H_h (inL R a) = H_h (inR R b)) s.1) :=	                                 X0 in	                               proj2_sig)^	                              (h0 (let (proj1_sig, _) := X1 in proj1_sig)))	                           (let	                              (proj1_sig, proj2_sig) as s	                               return	                                 ((fun b : C =>	                                   trunctype_type	                                     (H_h	                                        (inR R	                                           (let (proj1_sig, _) := X0 in	                                            proj1_sig)) 	                                        (h0 b))) s.1) := X1 in	                            proj2_sig)))	                        ((let (fst, _) := X in fst)	                           (let (proj1_sig, _) := X0 in proj1_sig)))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (let (proj1_sig, _) := X0 in proj1_sig;	                         ap H_h	                           (glue R a (let (proj1_sig, _) := X0 in proj1_sig)	                              (let	                                 (proj1_sig, proj2_sig) as s	                                  return	                                    ((fun b : B => trunctype_type (R a b))	                                       s.1) := X0 in	                               proj2_sig)))) (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun X0 : {a : B & H_h (inR R a) (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h (inL R a) =	                               H_h	                                 (inR R	                                    (let (proj1_sig, _) := X0 in proj1_sig))}	                        =>	                        (let (proj1_sig, _) := X1 in proj1_sig;	                        transport trunctype_type	                          (ap10	                             (let	                                (proj1_sig, proj2_sig) as s	                                 return	                                   ((fun a : A =>	                                     H_h (inL R a) =	                                     H_h	                                       (inR R	                                          (let (proj1_sig, _) := X0 in	                                           proj1_sig))) s.1) := X1 in	                              proj2_sig)^ (h0 c))	                          (let	                             (proj1_sig, proj2_sig) as s	                              return	                                ((fun a : B =>	                                  trunctype_type (H_h (inR R a) (h0 c))) s.1) :=	                             X0 in	                           proj2_sig)))	                       (Trunc_functor (-1)	                          (fun	                             X1 : {a : A &	                                  R a (let (proj1_sig, _) := X0 in proj1_sig)}	                           =>	                           (let (proj1_sig, _) := X1 in proj1_sig;	                           ap H_h	                             (glue R (let (proj1_sig, _) := X1 in proj1_sig)	                                (let (proj1_sig, _) := X0 in proj1_sig)	                                (let	                                   (proj1_sig, proj2_sig) as s	                                    return	                                      ((fun a : A =>	                                        trunctype_type	                                          (R a	                                             (let (proj1_sig, _) := X0 in	                                              proj1_sig))) s.1) := X1 in	                                 proj2_sig))))	                          (snd bitot_R	                             (let (proj1_sig, _) := X0 in proj1_sig))))	                    ((let (_, snd) := X in snd) c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A (fun x : A => h (inL R x))	                    (fun x : A => H_h (inL R x)) v)	                 (bisim_aux B (fun x : B => h (inR R x))	                    (fun x : B => H_h (inR R x)) v)))) 	        (f a) (g b)	  ============================	  {a0 : A & f a0 = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 379;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 380;
            data = "<infomsg>bisimulation_equiv_id is defined</infomsg>	";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "<infomsg>ker_bisim is defined</infomsg>	";
            responses[i]=data;
          

            i = 391;
            data = "1 subgoal, subgoal 1 (ID 436)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 392;
            data = "1 subgoal, subgoal 1 (ID 436)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall x y : A, f x = f y <~> ker_bisim f x y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 393;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 394;
            data = "<infomsg>ker_bisim_is_ker is defined</infomsg>	";
            responses[i]=data;
          

            i = 395;
            data = "";
            responses[i]=data;
          

            i = 396;
            data = "";
            responses[i]=data;
          

            i = 397;
            data = "";
            responses[i]=data;
          

            i = 398;
            data = "";
            responses[i]=data;
          

            i = 399;
            data = "";
            responses[i]=data;
          

            i = 400;
            data = "<infomsg>u is declared</infomsg>	<infomsg>Au is declared</infomsg>	<infomsg>Au' is declared</infomsg>	<infomsg>h is declared</infomsg>	<infomsg>h' is declared</infomsg>	<infomsg>mu is declared</infomsg>	<infomsg>mono is declared</infomsg>	<infomsg>mu' is declared</infomsg>	<infomsg>mono' is declared</infomsg>	<infomsg>p is declared</infomsg>	<infomsg>p' is declared</infomsg>	";
            responses[i]=data;
          

            i = 401;
            data = "1 subgoal, subgoal 1 (ID 449)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  (forall a : Au, {a' : Au' & mu' a' = mu a}) *	  (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 402;
            data = "1 subgoal, subgoal 1 (ID 449)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  (forall a : Au, {a' : Au' & mu' a' = mu a}) *	  (forall a' : Au', {a : Au & mu a = mu' a'})		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 403;
            data = "2 subgoals, subgoal 1 (ID 451)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a : Au, {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 452) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 404;
            data = "2 subgoals, subgoal 1 (ID 453)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a : Au	  ============================	  {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 452) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 405;
            data = "1 subgoal, subgoal 1 (ID 452)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a' : Au', {a : Au & mu a = mu' a'}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 406;
            data = "1 subgoal, subgoal 1 (ID 473)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a' : Au'	  ============================	  {a : Au & mu a = mu' a'}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 407;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 408;
            data = "<infomsg>eq_img_untrunc is defined</infomsg>	";
            responses[i]=data;
          

            i = 409;
            data = "<infomsg>e is defined</infomsg>	";
            responses[i]=data;
          

            i = 410;
            data = "<infomsg>inv_e is defined</infomsg>	";
            responses[i]=data;
          

            i = 411;
            data = "1 subgoal, subgoal 1 (ID 460)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	  Sect inv_e e		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 412;
            data = "1 subgoal, subgoal 1 (ID 460)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	  Sect inv_e e		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 413;
            data = "1 subgoal, subgoal 1 (ID 462)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  e (inv_e a') = a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 414;
            data = "1 subgoal, subgoal 1 (ID 465)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu' a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 415;
            data = "2 subgoals, subgoal 1 (ID 488)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu (inv_e a')		subgoal 2 (ID 489) is:	 mu (inv_e a') = mu' a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 416;
            data = "1 subgoal, subgoal 1 (ID 489)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu (inv_e a') = mu' a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 417;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 418;
            data = "<infomsg>hom1 is defined</infomsg>	";
            responses[i]=data;
          

            i = 419;
            data = "1 subgoal, subgoal 1 (ID 463)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	  Sect e inv_e		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 420;
            data = "1 subgoal, subgoal 1 (ID 463)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  ============================	  Sect e inv_e		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 421;
            data = "1 subgoal, subgoal 1 (ID 465)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	  inv_e (e a) = a		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 422;
            data = "1 subgoal, subgoal 1 (ID 468)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	  mu (inv_e (e a)) = mu a		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 423;
            data = "2 subgoals, subgoal 1 (ID 492)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	  mu (inv_e (e a)) = mu' (e a)		subgoal 2 (ID 493) is:	 mu' (e a) = mu a	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 424;
            data = "1 subgoal, subgoal 1 (ID 493)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  a : Au	  ============================	  mu' (e a) = mu a		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 425;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 426;
            data = "<infomsg>hom2 is defined</infomsg>	";
            responses[i]=data;
          

            i = 427;
            data = "1 subgoal, subgoal 1 (ID 465)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	  Au' = Au		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 428;
            data = "1 subgoal, subgoal 1 (ID 465)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	  Au' = Au		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 429;
            data = "1 subgoal, subgoal 1 (ID 469)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  ============================	  Au' <~> Au		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 430;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 431;
            data = "<infomsg>path is defined</infomsg>	";
            responses[i]=data;
          

            i = 432;
            data = "1 subgoal, subgoal 1 (ID 473)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoal, subgoal 1 (ID 473)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 434;
            data = "1 subgoal, subgoal 1 (ID 496)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu == mu'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoal, subgoal 1 (ID 498)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' = mu' a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 436;
            data = "2 subgoals, subgoal 1 (ID 539)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' =	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))		subgoal 2 (ID 540) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 437;
            data = "1 subgoal, subgoal 1 (ID 540)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu' a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 438;
            data = "2 subgoals, subgoal 1 (ID 578)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu (transport idmap (path^)^ a')		subgoal 2 (ID 579) is:	 mu (transport idmap (path^)^ a') = mu' a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 439;
            data = "1 subgoal, subgoal 1 (ID 579)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu' a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 440;
            data = "2 subgoals, subgoal 1 (ID 609)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')		subgoal 2 (ID 610) is:	 mu (inv_e a') = mu' a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 441;
            data = "1 subgoal, subgoal 1 (ID 609)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 442;
            data = "1 subgoal, subgoal 1 (ID 620)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = inv_e a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 443;
            data = "2 subgoals, subgoal 1 (ID 649)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = transport idmap path a'		subgoal 2 (ID 650) is:	 transport idmap path a' = inv_e a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 444;
            data = "1 subgoal, subgoal 1 (ID 650)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  a' : Au'	  ============================	  transport idmap path a' = inv_e a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 445;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 446;
            data = "<infomsg>mu_eq_mu' is defined</infomsg>	";
            responses[i]=data;
          

            i = 447;
            data = "1 subgoal, subgoal 1 (ID 496)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 448;
            data = "1 subgoal, subgoal 1 (ID 496)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  (Au; (mu; (h, mono, p))) = (Au'; (mu'; (h', mono', p')))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 449;
            data = "1 subgoal, subgoal 1 (ID 499)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  {p0 : Au = Au' &	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    p0 (mu; (h, mono, p)) = (mu'; (h', mono', p'))}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 450;
            data = "1 subgoal, subgoal 1 (ID 504)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 451;
            data = "2 subgoals, subgoal 1 (ID 552)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) =	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p))		subgoal 2 (ID 553) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 452;
            data = "1 subgoal, subgoal 1 (ID 553)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p)) = (mu'; (h', mono', p'))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 453;
            data = "1 subgoal, subgoal 1 (ID 1080)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	       : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	       : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	       : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 454;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 455;
            data = "<infomsg>monic_set_present_uniqueness is defined</infomsg>	";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "";
            responses[i]=data;
          

            i = 461;
            data = "1 subgoal, subgoal 1 (ID 443)	  	  ua : Univalence	  ============================	  forall u : V,	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 462;
            data = "1 subgoal, subgoal 1 (ID 443)	  	  ua : Univalence	  ============================	  forall u : V,	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 463;
            data = "2 subgoals, subgoal 1 (ID 444)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		subgoal 2 (ID 445) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 464;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 444)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 449)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 465;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 518)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  {Au0 : Type &	  {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (set f = set m)}}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 466;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 522)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  IsHSet Au * IsEmbedding mu * (set f = set mu)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 467;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 524)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  IsHSet Au * IsEmbedding mu		subgoal 2 (ID 525) is:	 set f = set mu	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 468;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 525)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  set f = set mu		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 469;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 532)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)		subgoal 2 (ID 533) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 470;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 532)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 534)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  hexists (fun b : Au => f a = mu b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 471;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 539)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  f a = mu (eu a)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 472;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 533)		subgoal 1 (ID 533) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	subgoal 2 (ID 445) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 473;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 533)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall b : Au, hexists (fun a : A => f a = mu b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 544)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  hexists (fun a : A => f a = mu a')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 474;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 545)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  TrM.RSU.IsConnected (-1) (hfiber eu a') ->	  hexists (fun a : A => f a = mu a')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 475;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 594)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1) (hfiber eu a')	  ============================	  hfiber eu a' -> {a : A & f a = mu a'}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 476;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 599)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  {a0 : A & f a0 = mu a'}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 477;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 601)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 478;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 623)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu (eu a)		subgoal 2 (ID 624) is:	 mu (eu a) = mu a'	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 479;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 624)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1) (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  mu (eu a) = mu a'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 480;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 445)		subgoal 1 (ID 445) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 481;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 445)	  	  ua : Univalence	  ============================	  forall v : V,	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 633)	  	  ua : Univalence	  v : V	  ============================	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 482;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 634)	  	  ua : Univalence	  v : V	  ============================	  forall	  x y : {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}},	  x = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 483;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 651)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  ============================	  forall	  y : {Au0 : Type &	      {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (v = set m)}},	  (Au; (mu; (hset, mono, p))) = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 484;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 668)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  Au' : Type	  mu' : Au' -> V	  hset' : IsHSet Au'	  mono' : IsEmbedding mu'	  p' : v = set mu'	  ============================	  (Au; (mu; (hset, mono, p))) = (Au'; (mu'; (hset', mono', p')))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 485;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 486;
            data = "<infomsg>monic_set_present is defined</infomsg>	";
            responses[i]=data;
          

            i = 487;
            data = "<infomsg>type_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 488;
            data = "";
            responses[i]=data;
          

            i = 489;
            data = "<infomsg>func_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 490;
            data = "<infomsg>is_hset_typeofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 491;
            data = "<infomsg>IsEmbedding_funcofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 492;
            data = "<infomsg>is_valid_presentation is defined</infomsg>	";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "";
            responses[i]=data;
          

            i = 497;
            data = "";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "1 subgoal, subgoal 1 (ID 479)	  	  ua : Univalence	  ============================	  forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 501;
            data = "1 subgoal, subgoal 1 (ID 479)	  	  ua : Univalence	  ============================	  forall x y : V, x ⊆ y * y ⊆ x <-> x = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 502;
            data = "1 subgoal, subgoal 1 (ID 740)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall (a : A) (y : V), f a ⊆ y * y ⊆ f a <-> f a = y) ->	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 503;
            data = "1 subgoal, subgoal 1 (ID 744)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 504;
            data = "1 subgoal, subgoal 1 (ID 996)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, set f ⊆ f0 a * f0 a ⊆ set f <-> set f = f0 a) ->	  set f ⊆ set f0 * set f0 ⊆ set f <-> set f = set f0		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 505;
            data = "1 subgoal, subgoal 1 (ID 1000)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f <-> set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 506;
            data = "2 subgoals, subgoal 1 (ID 1002)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g		subgoal 2 (ID 1003) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 507;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 1002)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 1008)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 508;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 1011)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  equal_img f g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 509;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 1013)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 1014) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 510;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1013)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1015)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 511;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1031)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  {a0 : B & g a0 = f a} -> hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 512;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1036)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  hexists (fun b0 : B => f a = g b0)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 513;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1039)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  {b0 : B & f a = g b0}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 514;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 1041)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  f a = g b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 515;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 1014)		subgoal 1 (ID 1014) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 1003) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 516;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 1014)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall b : B, hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 1045)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 517;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 1046)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  g b ∈ set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 518;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 1003)		subgoal 1 (ID 1003) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 519;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 1003)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f = set g -> set f ⊆ set g * set g ⊆ set f		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 1055)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g		subgoal 2 (ID 1056) is:	 set g ⊆ set f	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 520;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 1055)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 1059)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set f	  ============================	  z ∈ set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 521;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 1056)		subgoal 1 (ID 1056) is:	 set g ⊆ set f	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 522;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 1056)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set g ⊆ set f		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 1065)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set g	  ============================	  z ∈ set f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 523;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 524;
            data = "<infomsg>extensionality is defined</infomsg>	";
            responses[i]=data;
          

            i = 525;
            data = "1 subgoal, subgoal 1 (ID 484)	  	  ua : Univalence	  C : V -> hProp	  ============================	  (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 526;
            data = "1 subgoal, subgoal 1 (ID 484)	  	  ua : Univalence	  C : V -> hProp	  ============================	  (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 527;
            data = "1 subgoal, subgoal 1 (ID 485)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall v : V, C v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 528;
            data = "1 subgoal, subgoal 1 (ID 508)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall (A : Type) (f : A -> V), (forall a : A, C (f a)) -> C (set f)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 529;
            data = "1 subgoal, subgoal 1 (ID 511)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  C (set f)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 530;
            data = "1 subgoal, subgoal 1 (ID 512)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  forall x : V, x ∈ set f -> C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 531;
            data = "1 subgoal, subgoal 1 (ID 514)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 532;
            data = "1 subgoal, subgoal 1 (ID 520)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  {a : A & f a = x} -> C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 533;
            data = "1 subgoal, subgoal 1 (ID 525)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  a : A	  p : f a = x	  ============================	  C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 534;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 535;
            data = "<infomsg>mem_induction is defined</infomsg>	";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "";
            responses[i]=data;
          

            i = 543;
            data = "";
            responses[i]=data;
          

            i = 544;
            data = "1 subgoal, subgoal 1 (ID 486)	  	  ua : Univalence	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 545;
            data = "2 subgoals, subgoal 1 (ID 489)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)		subgoal 2 (ID 490) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 546;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 489)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 491)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (complement (fun x x0 : V => x ∈ x0) v v)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 547;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 492)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (~ v ∈ v)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 548;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 490)		subgoal 1 (ID 490) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 490)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)		(dependent evars: (printing disabled) )		1 subgoal, subgoal 1 (ID 543)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  forall v : V, (forall x : V, x ∈ v -> ~ x ∈ x) -> ~ v ∈ v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 549;
            data = "1 subgoal, subgoal 1 (ID 545)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  ============================	  ~ v ∈ v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 550;
            data = "1 subgoal, subgoal 1 (ID 547)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  Hv : v ∈ v	  ============================	  Empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 551;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 552;
            data = "<infomsg>irreflexive_mem is defined</infomsg>	";
            responses[i]=data;
          

            i = 553;
            data = "1 subgoal, subgoal 1 (ID 499)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	  set f = set g -> equal_img f g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 554;
            data = "1 subgoal, subgoal 1 (ID 499)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	  set f = set g -> equal_img f g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 555;
            data = "1 subgoal, subgoal 1 (ID 500)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  equal_img f g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 556;
            data = "2 subgoals, subgoal 1 (ID 502)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 503) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 557;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 502)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 504)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 558;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 506)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g		subgoal 2 (ID 508) is:	 hexists (fun b : B => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 559;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 506)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 516)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set f		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 560;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals, subgoal 1 (ID 508)		subgoal 1 (ID 508) is:	 hexists (fun b : B => f a = g b)	subgoal 2 (ID 503) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 508)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  hexists (fun b : B => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 526)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  {a0 : B & g a0 = f a} -> {b : B & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 561;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 531)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  b : B	  p' : g b = f a	  ============================	  {b0 : B & f a = g b0}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 562;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 503)		subgoal 1 (ID 503) is:	 forall b : B, hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 563;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 503)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall b : B, hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 537)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 564;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 539)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f		subgoal 2 (ID 541) is:	 hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 565;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 539)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 552)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 566;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal, subgoal 1 (ID 541)		subgoal 1 (ID 541) is:	 hexists (fun a : A => f a = g b)	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 541)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  hexists (fun a : A => f a = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 562)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  {a : A & f a = g b} -> {a : A & f a = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 567;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 567)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 568;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 569;
            data = "<infomsg>path_V_eqimg is defined</infomsg>	";
            responses[i]=data;
          

            i = 570;
            data = "";
            responses[i]=data;
          

            i = 571;
            data = "";
            responses[i]=data;
          

            i = 572;
            data = "";
            responses[i]=data;
          

            i = 573;
            data = "";
            responses[i]=data;
          

            i = 574;
            data = "";
            responses[i]=data;
          

            i = 575;
            data = "";
            responses[i]=data;
          

            i = 576;
            data = "";
            responses[i]=data;
          

            i = 577;
            data = "";
            responses[i]=data;
          

            i = 578;
            data = "";
            responses[i]=data;
          

            i = 579;
            data = "<infomsg>V_empty is defined</infomsg>	";
            responses[i]=data;
          

            i = 580;
            data = "";
            responses[i]=data;
          

            i = 581;
            data = "";
            responses[i]=data;
          

            i = 582;
            data = "";
            responses[i]=data;
          

            i = 583;
            data = "";
            responses[i]=data;
          

            i = 584;
            data = "<infomsg>V_singleton is defined</infomsg>	";
            responses[i]=data;
          

            i = 585;
            data = "";
            responses[i]=data;
          

            i = 586;
            data = "1 subgoal, subgoal 1 (ID 509)	  	  ua : Univalence	  u, v : V	  ============================	  IsEquiv (ap V_singleton)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 587;
            data = "1 subgoal, subgoal 1 (ID 513)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 588;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 513)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 822)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 589;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 827)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  equal_img (Unit_ind u) (Unit_ind v) -> u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 590;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 833)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 591;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 888)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  {b : Unit & Unit_ind u tt = Unit_ind v b} -> u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 592;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 893)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  t : Unit	  p : Unit_ind u tt = Unit_ind v t	  ============================	  u = v		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 593;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		No more subgoals.	(dependent evars: (printing disabled) )		<infomsg>isequiv_ap_V_singleton is defined</infomsg>	";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "";
            responses[i]=data;
          

            i = 596;
            data = "";
            responses[i]=data;
          

            i = 597;
            data = "";
            responses[i]=data;
          

            i = 598;
            data = "<infomsg>V_pair is defined</infomsg>	";
            responses[i]=data;
          

            i = 599;
            data = "1 subgoal, subgoal 1 (ID 518)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	  (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 600;
            data = "1 subgoal, subgoal 1 (ID 518)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	  (u = u') * (v = v') -> V_pair u v = V_pair u' v'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 601;
            data = "1 subgoal, subgoal 1 (ID 523)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  V_pair u v = V_pair u' v'		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 602;
            data = "1 subgoal, subgoal 1 (ID 526)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  equal_img (fun b : Bool => if b then u else v)	    (fun b : Bool => if b then u' else v')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 603;
            data = "2 subgoals, subgoal 1 (ID 528)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		subgoal 2 (ID 529) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 604;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 528)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1), subgoal 1 (ID 530)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => u = (if b then u' else v'))		subgoal 2 (ID 531) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 605;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 536)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  u = u'		subgoal 2 (ID 531) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 606;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 531)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => v = (if b then u' else v'))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 607;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 529)		subgoal 1 (ID 529) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 608;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 529)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall b : Bool,	  hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0), subgoal 1 (ID 542)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = u')		subgoal 2 (ID 543) is:	 hexists (fun a : Bool => (if a then u else v) = v')	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 609;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 543)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = v')		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 610;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 611;
            data = "<infomsg>path_pair is defined</infomsg>	";
            responses[i]=data;
          

            i = 612;
            data = "1 subgoal, subgoal 1 (ID 525)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 613;
            data = "1 subgoal, subgoal 1 (ID 525)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w <-> (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 614;
            data = "2 subgoals, subgoal 1 (ID 527)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)		subgoal 2 (ID 528) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 615;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 527)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 529)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  ============================	  (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 616;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 539)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 617;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 708)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  {b : Unit & u = Unit_ind w b} -> (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 618;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 719)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 619;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 903)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  {b : Unit & v = Unit_ind w b} -> (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 620;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 914)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  p' : v = Unit_ind w tt	  ============================	  (u = w) * (v = w)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 621;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 528)		subgoal 1 (ID 528) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 622;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 528)	  	  ua : Univalence	  u, v, w : V	  ============================	  (u = w) * (v = w) -> V_pair u v = V_singleton w		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 922)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  V_pair u v = V_singleton w		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 623;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 927)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall a : Bool,	  hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)		subgoal 2 (ID 928) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 624;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 934)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  a : Bool	  ============================	  (if a then u else v) = Unit_ind w tt		subgoal 2 (ID 928) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 625;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 928)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall b : Unit,	  hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 626;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 945)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  t : Unit	  ============================	  u = Unit_ind w t		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 627;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 628;
            data = "<infomsg>pair_eq_singleton is defined</infomsg>	";
            responses[i]=data;
          

            i = 629;
            data = "";
            responses[i]=data;
          

            i = 630;
            data = "";
            responses[i]=data;
          

            i = 631;
            data = "";
            responses[i]=data;
          

            i = 632;
            data = "";
            responses[i]=data;
          

            i = 633;
            data = "<infomsg>V_pair_ord is defined</infomsg>	";
            responses[i]=data;
          

            i = 634;
            data = "";
            responses[i]=data;
          

            i = 635;
            data = "1 subgoal, subgoal 1 (ID 533)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 636;
            data = "1 subgoal, subgoal 1 (ID 533)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] <-> (a = c) * (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 637;
            data = "2 subgoals, subgoal 1 (ID 535)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)		subgoal 2 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 638;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 535)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 537)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  (a = c) * (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 639;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 539)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c		subgoal 2 (ID 541) is:	 (a = c) * (b = d)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 640;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 539)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 542)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]		subgoal 2 (ID 544) is:	 a = c	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 641;
            data = "1 focused subgoal	(unfocused: 1-1-1), subgoal 1 (ID 542)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1-1), subgoal 1 (ID 552)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [a, b]		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 642;
            data = "1 focused subgoal	(unfocused: 1-1-1), subgoal 1 (ID 554)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  Trunc (-1)	    {a0 : Bool & (if a0 then V_singleton a else V_pair a b) = V_singleton a}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 643;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals, subgoal 1 (ID 544)		subgoal 1 (ID 544) is:	 a = c	subgoal 2 (ID 541) is:	 (a = c) * (b = d)	subgoal 3 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 544)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  a = c		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 620)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_singleton a} ->	  a = c		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 644;
            data = "2 focused subgoals	(unfocused: 1-1), subgoal 1 (ID 634)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	  a = c		subgoal 2 (ID 635) is:	 a = c	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 645;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 635)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_pair c d = V_singleton a	  ============================	  a = c		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 646;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 541)		subgoal 1 (ID 541) is:	 (a = c) * (b = d)	subgoal 2 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 647;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 541)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  (a = c) * (b = d)		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 668)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  a = c		subgoal 2 (ID 669) is:	 b = d	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 648;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 669)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = d		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 649;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 672)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  hor (b = c) (b = d)		subgoal 2 (ID 674) is:	 b = d	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 650;
            data = "1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 672)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 675)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]		subgoal 2 (ID 677) is:	 hor (b = c) (b = d)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 651;
            data = "1 focused subgoal	(unfocused: 1-1-0-1), subgoal 1 (ID 675)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1-0-1), subgoal 1 (ID 685)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [a, b]		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 652;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals, subgoal 1 (ID 677)		subgoal 1 (ID 677) is:	 hor (b = c) (b = d)	subgoal 2 (ID 674) is:	 b = d	subgoal 3 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 677)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 699)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_pair a b} ->	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 653;
            data = "2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 713)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  hor (b = c) (b = d)		subgoal 2 (ID 714) is:	 hor (b = c) (b = d)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 654;
            data = "1 focused subgoal	(unfocused: 1-1-0-1), subgoal 1 (ID 713)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1-0-1), subgoal 1 (ID 719)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 655;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals, subgoal 1 (ID 714)		subgoal 1 (ID 714) is:	 hor (b = c) (b = d)	subgoal 2 (ID 674) is:	 b = d	subgoal 3 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 656;
            data = "1 focused subgoal	(unfocused: 0-1-0-1), subgoal 1 (ID 714)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  ============================	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1-0-1), subgoal 1 (ID 741)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  hor (b = c) (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 657;
            data = "1 focused subgoal	(unfocused: 0-1-0-1), subgoal 1 (ID 745)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  {a0 : Bool & (if a0 then c else d) = b} -> (b = c) + (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 658;
            data = "2 focused subgoals	(unfocused: 0-1-0-1), subgoal 1 (ID 759)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	  (b = c) + (b = d)		subgoal 2 (ID 760) is:	 (b = c) + (b = d)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 659;
            data = "1 focused subgoal	(unfocused: 0-1-0-1), subgoal 1 (ID 760)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : d = b	  ============================	  (b = c) + (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 660;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals, subgoal 1 (ID 674)		subgoal 1 (ID 674) is:	 b = d	subgoal 2 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 674)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	  b = d		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 835)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  ============================	  (b = c) + (b = d) -> b = d		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 661;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 842)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  b = d		subgoal 2 (ID 843) is:	 b = d	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 662;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 842)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  b = d		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 663;
            data = "2 focused subgoals	(unfocused: 0-1), subgoal 1 (ID 845)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)		subgoal 2 (ID 847) is:	 b = d	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 664;
            data = "1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 845)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 853)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  (V_singleton a = V_singleton b) * (V_pair a b = V_singleton b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 665;
            data = "2 focused subgoals	(unfocused: 1-0-1), subgoal 1 (ID 855)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  V_singleton a = V_singleton b		subgoal 2 (ID 856) is:	 V_pair a b = V_singleton b	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 666;
            data = "1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 856)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  V_pair a b = V_singleton b		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 667;
            data = "1 focused subgoal	(unfocused: 1-0-1), subgoal 1 (ID 872)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  ============================	  (a = b) * (b = b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 668;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals, subgoal 1 (ID 847)		subgoal 1 (ID 847) is:	 b = d	subgoal 2 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 669;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 847)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  ============================	  b = d		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 670;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 887)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : hor (b = c) (b = d)	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  H'' : V_pair c d = V_singleton b	  ============================	  b = d		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 536)		subgoal 1 (ID 536) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 671;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 536)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  (a = c) * (b = d) -> [a, b] = [c, d]		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 934)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  [a, b] = [c, d]		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 672;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 939)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (V_singleton a = V_singleton c) * (V_pair a b = V_pair c d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 673;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 941)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_singleton a = V_singleton c		subgoal 2 (ID 942) is:	 V_pair a b = V_pair c d	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 674;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 942)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_pair a b = V_pair c d		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 675;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 950)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (a = c) * (b = d)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 676;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 677;
            data = "<infomsg>path_pair_ord is defined</infomsg>	";
            responses[i]=data;
          

            i = 678;
            data = "";
            responses[i]=data;
          

            i = 679;
            data = "";
            responses[i]=data;
          

            i = 680;
            data = "";
            responses[i]=data;
          

            i = 681;
            data = "";
            responses[i]=data;
          

            i = 682;
            data = "<infomsg>V_cart_prod is defined</infomsg>	";
            responses[i]=data;
          

            i = 683;
            data = "";
            responses[i]=data;
          

            i = 684;
            data = "";
            responses[i]=data;
          

            i = 685;
            data = "";
            responses[i]=data;
          

            i = 686;
            data = "";
            responses[i]=data;
          

            i = 687;
            data = "";
            responses[i]=data;
          

            i = 688;
            data = "Toplevel input, characters 48-61:	> Definition V_is_func (a : V) (b : V) (f : V) := f ⊆ (a * b)	>                                                 ^^^^^^^^^^^	Error:	In environment	ua : Univalence	a : V	b : V	f : V	The term \"f ⊆ (a * b)\" has type \"hProp\" while it is expected to have type	 \"V\".	";
            responses[i]=data;
          

            i = 689;
            data = "";
            responses[i]=data;
          

            i = 690;
            data = "";
            responses[i]=data;
          

            i = 691;
            data = "";
            responses[i]=data;
          

            i = 692;
            data = "";
            responses[i]=data;
          

            i = 693;
            data = "<infomsg>V_func is defined</infomsg>	";
            responses[i]=data;
          

            i = 694;
            data = "";
            responses[i]=data;
          

            i = 695;
            data = "";
            responses[i]=data;
          

            i = 696;
            data = "";
            responses[i]=data;
          

            i = 697;
            data = "";
            responses[i]=data;
          

            i = 698;
            data = "<infomsg>V_union is defined</infomsg>	";
            responses[i]=data;
          

            i = 699;
            data = "";
            responses[i]=data;
          

            i = 700;
            data = "";
            responses[i]=data;
          

            i = 701;
            data = "";
            responses[i]=data;
          

            i = 702;
            data = "";
            responses[i]=data;
          

            i = 703;
            data = "1 subgoal, subgoal 1 (ID 550)	  	  ua : Univalence	  ============================	  V -> V		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 704;
            data = "1 subgoal, subgoal 1 (ID 550)	  	  ua : Univalence	  ============================	  V -> V		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 705;
            data = "2 subgoals, subgoal 1 (ID 553)	  	  ua : Univalence	  ============================	  forall A : Type, (A -> V) -> (A -> V) -> V		subgoal 2 (ID 554) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g -> ?Goal A f H_f = ?Goal B g H_g	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 706;
            data = "2 subgoals, subgoal 1 (ID 558)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  V		subgoal 2 (ID 554) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?Goal0@{A:=A0; f:=f0}) A f H_f =	 (fun (A0 : Type) (f0 _ : A0 -> V) => ?Goal0@{A:=A0; f:=f0}) B g H_g	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 707;
            data = "1 subgoal, subgoal 1 (ID 554)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V) (H_g : B -> V),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) A f H_f =	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) B g H_g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 708;
            data = "1 subgoal, subgoal 1 (ID 572)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set (fun x : A + Unit => match x with	                           | inl a => f a	                           | inr tt => set f	                           end) =	  set (fun x : B + Unit => match x with	                           | inl a => g a	                           | inr tt => set g	                           end)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 709;
            data = "1 subgoal, subgoal 1 (ID 575)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  equal_img	    (fun x : A + Unit => match x with	                         | inl a => f a	                         | inr tt => set f	                         end)	    (fun x : B + Unit => match x with	                         | inl a => g a	                         | inr tt => set g	                         end)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 710;
            data = "2 subgoals, subgoal 1 (ID 577)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		subgoal 2 (ID 578) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 711;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 577)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 579)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A + Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 712;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 585)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		subgoal 2 (ID 586) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 713;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 585)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 589)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists (fun b : B => f a = g b) ->	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 714;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 592)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  {b : B & f a = g b} ->	  {b : B + Unit & f a = match b with	                        | inl a0 => g a0	                        | inr tt => set g	                        end}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 715;
            data = "1 focused subgoal	(unfocused: 1-1), subgoal 1 (ID 597)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  b : B	  p : f a = g b	  ============================	  {b0 : B + Unit &	  f a = match b0 with	        | inl a0 => g a0	        | inr tt => set g	        end}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 716;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals, subgoal 1 (ID 586)		subgoal 1 (ID 586) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	subgoal 2 (ID 578) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 717;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 586)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match u with	     | tt => set f	     end = match b with	           | inl a => g a	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 608)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  match u with	  | tt => set f	  end = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 718;
            data = "1 focused subgoal	(unfocused: 0-1), subgoal 1 (ID 611)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 719;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 578)		subgoal 1 (ID 578) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 720;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 578)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall b : B + Unit,	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 615)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B + Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 721;
            data = "2 focused subgoals	(unfocused: 0), subgoal 1 (ID 621)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)		subgoal 2 (ID 622) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 722;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 621)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 625)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists (fun a : A => f a = g b) ->	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 723;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 628)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  {a : A & f a = g b} ->	  {a : A + Unit & match a with	                  | inl a0 => f a0	                  | inr tt => set f	                  end = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 724;
            data = "1 focused subgoal	(unfocused: 1-0), subgoal 1 (ID 633)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  a : A	  p : f a = g b	  ============================	  {a0 : A + Unit &	  match a0 with	  | inl a1 => f a1	  | inr tt => set f	  end = g b}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 725;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal, subgoal 1 (ID 622)		subgoal 1 (ID 622) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 726;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 622)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match u with	           | tt => set g	           end)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 644)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  set f = match u with	          | tt => set g	          end		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 727;
            data = "1 focused subgoal	(unfocused: 0-0), subgoal 1 (ID 647)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 728;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 729;
            data = "<infomsg>V_succ is defined</infomsg>	";
            responses[i]=data;
          

            i = 730;
            data = "";
            responses[i]=data;
          

            i = 731;
            data = "";
            responses[i]=data;
          

            i = 732;
            data = "";
            responses[i]=data;
          

            i = 733;
            data = "";
            responses[i]=data;
          

            i = 734;
            data = "<infomsg>V_omega is defined</infomsg>	";
            responses[i]=data;
          

            i = 735;
            data = "";
            responses[i]=data;
          

            i = 736;
            data = "";
            responses[i]=data;
          

            i = 737;
            data = "";
            responses[i]=data;
          

            i = 738;
            data = "";
            responses[i]=data;
          

            i = 739;
            data = "";
            responses[i]=data;
          

            i = 740;
            data = "";
            responses[i]=data;
          

            i = 741;
            data = "";
            responses[i]=data;
          

            i = 742;
            data = "1 subgoal, subgoal 1 (ID 555)	  	  ua : Univalence	  ============================	  forall x : V, ~ x ∈ V_empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 743;
            data = "1 subgoal, subgoal 1 (ID 555)	  	  ua : Univalence	  ============================	  forall x : V, ~ x ∈ V_empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 744;
            data = "1 subgoal, subgoal 1 (ID 558)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  Empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 745;
            data = "1 subgoal, subgoal 1 (ID 564)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  {a : Empty & Empty_ind (fun _ : Empty => V) a = x} -> Empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 746;
            data = "1 subgoal, subgoal 1 (ID 570)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ff : Empty	  ============================	  Empty		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 747;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 748;
            data = "<infomsg>not_mem_Vempty is defined</infomsg>	";
            responses[i]=data;
          

            i = 749;
            data = "1 subgoal, subgoal 1 (ID 562)	  	  ua : Univalence	  ============================	  forall u v : V,	  hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 750;
            data = "1 subgoal, subgoal 1 (ID 562)	  	  ua : Univalence	  ============================	  forall u v : V,	  hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 751;
            data = "1 subgoal, subgoal 1 (ID 564)	  	  ua : Univalence	  u, v : V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> hor (x = u) (x = v))		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 752;
            data = "1 subgoal, subgoal 1 (ID 567)	  	  ua : Univalence	  u, v : V	  ============================	  {w : V & forall x : V, x ∈ w <-> hor (x = u) (x = v)}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 753;
            data = "1 subgoal, subgoal 1 (ID 569)	  	  ua : Univalence	  u, v : V	  ============================	  forall x : V, x ∈ V_pair u v <-> hor (x = u) (x = v)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 754;
            data = "2 subgoals, subgoal 1 (ID 576)	  	  ua : Univalence	  u, v, x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		subgoal 2 (ID 579) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 755;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 576)	  	  ua : Univalence	  u, v, x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		(dependent evars: (printing disabled) )		<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 579)		subgoal 1 (ID 579) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 756;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 579)	  	  ua : Univalence	  u, v, x : V	  ============================	  (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}		(dependent evars: (printing disabled) )		No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 757;
            data = "<infomsg>pairing is defined</infomsg>	";
            responses[i]=data;
          

            i = 758;
            data = "1 subgoal, subgoal 1 (ID 564)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 759;
            data = "1 subgoal, subgoal 1 (ID 564)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 760;
            data = "2 subgoals, subgoal 1 (ID 566)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega		subgoal 2 (ID 567) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 761;
            data = "1 subgoal, subgoal 1 (ID 567)	  	  ua : Univalence	  ============================	  forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 762;
            data = "1 subgoal, subgoal 1 (ID 573)	  	  ua : Univalence	  x : V	  ============================	  x ∈ V_omega -> V_succ x ∈ V_omega		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 763;
            data = "1 subgoal, subgoal 1 (ID 576)	  	  ua : Univalence	  x : V	  ============================	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = x} ->	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = V_succ x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 764;
            data = "1 subgoal, subgoal 1 (ID 581)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  {a : nat &	  (fix I (n0 : nat) : V :=	     match n0 with	     | 0 => V_empty	     | n1.+1 => V_succ (I n1)	     end) a = V_succ x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 765;
            data = "1 subgoal, subgoal 1 (ID 583)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  V_succ	    ((fix I (n0 : nat) : V :=	        match n0 with	        | 0 => V_empty	        | n1.+1 => V_succ (I n1)	        end) n) = V_succ x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 766;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 767;
            data = "<infomsg>infinity is defined</infomsg>	";
            responses[i]=data;
          

            i = 768;
            data = "Toplevel input, characters 82-89:	> Lemma union : forall v, hexists (fun w => forall x, x ∈ w <-> hexists (fun u => x ∈ u * u ∈ v)).	>                                                                                 ^^^^^	Error:	In environment	ua : Univalence	v : ?T	w : V	x : V	u : V	The term \"x ∈ u\" has type \"hProp\" while it is expected to have type \"V\".	";
            responses[i]=data;
          

            i = 769;
            data = "	";
            responses[i]=data;
          

            i = 770;
            data = "Toplevel input, characters 3-11:	>   intro v.	>   ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 771;
            data = "Toplevel input, characters 12-41:	> apply tr; exists (V_union v).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 772;
            data = "Toplevel input, characters 3-18:	>   intro x; split.	>   ^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 773;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-12:	>   - intro H.	>     ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 774;
            data = "Toplevel input, characters 14-25:	> simpl in H.	> ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 775;
            data = "Toplevel input, characters 13-52:	> generalize H; apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 776;
            data = "Toplevel input, characters 5-36:	>     intros [[u' x'] p]; simpl in p.	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 777;
            data = "Toplevel input, characters 5-40:	>     exists (func_of_members u'); split.	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 778;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-92:	>     + refine (transport (fun z => x ∈ z) (is_valid_presentation (func_of_members u'))^ _).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 779;
            data = "Toplevel input, characters 7-13:	>       simpl.	>       ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 780;
            data = "Toplevel input, characters 14-34:	> apply tr; exists x'.	> ^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 781;
            data = "Toplevel input, characters 22-30:	> exact p.	> ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 782;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-90:	>     + refine (transport (fun z => func_of_members u' ∈ z) (is_valid_presentation v)^ _).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 783;
            data = "Toplevel input, characters 7-13:	>       simpl.	>       ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 784;
            data = "Toplevel input, characters 14-47:	> apply tr; exists u'; reflexivity.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 785;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-20:	>   - apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 786;
            data = "Toplevel input, characters 22-42:	> intros [u (Hx, Hu)].	> ^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 787;
            data = "Toplevel input, characters 5-76:	>     generalize (transport (fun z => u ∈ z) (is_valid_presentation v) Hu).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 788;
            data = "Toplevel input, characters 5-21:	>     apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 789;
            data = "Toplevel input, characters 22-37:	> intros [u' pu].	> ^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 790;
            data = "Toplevel input, characters 5-130:	>     generalize (transport (fun z => x ∈ z) (is_valid_presentation (func_of_members u')) (transport (fun z => x ∈ z) pu^ Hx)).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 791;
            data = "Toplevel input, characters 5-21:	>     apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 792;
            data = "Toplevel input, characters 22-37:	> intros [x' px].	> ^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 793;
            data = "Toplevel input, characters 5-14:	>     apply tr.	>     ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 794;
            data = "Toplevel input, characters 15-31:	> exists (u'; x').	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 795;
            data = "Toplevel input, characters 18-27:	> exact px.	> ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 796;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 797;
            data = "Toplevel input, characters 69-78:	> Lemma function : forall u v, hexists (fun w => forall x, x ∈ w <-> V_is_func u v x).	>                                                                    ^^^^^^^^^	Error: The reference V_is_func was not found in the current environment.	";
            responses[i]=data;
          

            i = 798;
            data = "	";
            responses[i]=data;
          

            i = 799;
            data = "Toplevel input, characters 3-14:	>   intros u v.	>   ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 800;
            data = "Toplevel input, characters 15-45:	> apply tr; exists (V_func u v).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 801;
            data = "Toplevel input, characters 3-85:	>   assert (memb_u : u = set (@func_of_members u)) by exact (is_valid_presentation u).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 802;
            data = "Toplevel input, characters 3-85:	>   assert (memb_v : v = set (@func_of_members v)) by exact (is_valid_presentation v).	>   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 803;
            data = "Toplevel input, characters 3-20:	>   intro phi; split.	>   ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 804;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-12:	>   - intro H.	>     ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 805;
            data = "Toplevel input, characters 14-20:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 806;
            data = "Toplevel input, characters 8-14:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 807;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 808;
            data = "Toplevel input, characters 20-31:	> simpl in *.	> ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 809;
            data = "Toplevel input, characters 0-13:	> generalize H.	> ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 810;
            data = "Toplevel input, characters 15-31:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 811;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 812;
            data = "Toplevel input, characters 0-52:	> generalize (transport (fun x => z ∈ x) p_phi^ Hz).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 813;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 814;
            data = "Toplevel input, characters 7-20:	>       intros [a p].	>       ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 815;
            data = "Toplevel input, characters 0-16:	> exists (a, h a).	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 816;
            data = "Toplevel input, characters 18-29:	> assumption.	> ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 817;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros x Hx.	>       ^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 818;
            data = "Toplevel input, characters 20-72:	> generalize (transport (fun y => x ∈ y) memb_u Hx).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 819;
            data = "Toplevel input, characters 7-23:	>       apply Trunc_rec.	>       ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 820;
            data = "Toplevel input, characters 24-37:	> intros [a p].	> ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 821;
            data = "Toplevel input, characters 0-39:	> generalize H; apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 822;
            data = "Toplevel input, characters 7-24:	>       intros [h p_phi].	>       ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 823;
            data = "Toplevel input, characters 0-31:	> exists (func_of_members (h a)).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 824;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 825;
            data = "Toplevel input, characters 7-86:	>       exact (transport (fun z => func_of_members (h a) ∈ z) memb_v^ (tr (h a; 1))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 826;
            data = "Toplevel input, characters 7-75:	>       apply (transport (fun y => [x, func_of_members (h a)] ∈ y) p_phi).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 827;
            data = "Toplevel input, characters 7-26:	>       apply tr; exists a.	>       ^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 828;
            data = "Toplevel input, characters 27-50:	> rewrite p; reflexivity.	> ^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 829;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-30:	>     + intros x y y' (Hy, Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 830;
            data = "Toplevel input, characters 0-30:	> generalize H; apply Trunc_rec.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 831;
            data = "Toplevel input, characters 32-49:	> intros [h p_phi].	> ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 832;
            data = "Toplevel input, characters 7-64:	>       generalize (transport (fun z => [x, y] ∈ z) p_phi^ Hy).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 833;
            data = "Toplevel input, characters 0-16:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 834;
            data = "Toplevel input, characters 18-31:	> intros [a p].	> ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 835;
            data = "Toplevel input, characters 7-66:	>       generalize (transport (fun z => [x, y'] ∈ z) p_phi^ Hy').	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 836;
            data = "Toplevel input, characters 0-16:	> apply Trunc_rec.	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 837;
            data = "Toplevel input, characters 18-33:	> intros [a' p'].	> ^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 838;
            data = "Toplevel input, characters 7-50:	>       destruct (fst path_pair_ord p) as (px, py).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 839;
            data = "Toplevel input, characters 0-46:	> destruct (fst path_pair_ord p') as (px', py').	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 840;
            data = "Toplevel input, characters 7-66:	>       transitivity (func_of_members (h a)); auto with path_hints.	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 841;
            data = "Toplevel input, characters 67-126:	> transitivity (func_of_members (h a'));auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 842;
            data = "Toplevel input, characters 7-37:	>       refine (ap func_of_members _).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 843;
            data = "Toplevel input, characters 0-16:	> refine (ap h _).	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 844;
            data = "Toplevel input, characters 7-90:	>       apply (isinj_embedding func_of_members IsEmbedding_funcofmembers a a' (px @ px'^)).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 845;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-26:	>   - intros ((H1, H2), H3).	>     ^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 846;
            data = "Toplevel input, characters 0-6:	> simpl.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 847;
            data = "Toplevel input, characters 5-93:	>     assert (h : forall a : [u], {b : [v] & [func_of_members a, func_of_members b] ∈ phi}).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 848;
            data = "Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-14:	>     { intro a.	>       ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 849;
            data = "Toplevel input, characters 16-46:	> pose (x := func_of_members a).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 850;
            data = "Toplevel input, characters 7-67:	>       transparent assert (H : {y : V & y ∈ v * [x, y] ∈ phi}).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 851;
            data = "Toplevel input, characters 7-164:	> ..... refine (@untrunc_istrunc -1 {y : V & y ∈ v * [x, y] ∈ phi} _	>                                  (H2 x (transport (fun z => x ∈ z) memb_u^ (tr (a; 1))))). 	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 852;
            data = "Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 8-28:	>       { apply hprop_allpath.	>         ^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 853;
            data = "Toplevel input, characters 30-74:	> intros [y (H1_y, H2_y)] [y' (H1_y', H2_y')].	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 854;
            data = "Toplevel input, characters 9-43:	>         apply path_sigma_uncurried; simpl.	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 855;
            data = "Toplevel input, characters 9-42:	>         exists (H3 x y y' (H2_y, H2_y')).	>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 856;
            data = "Toplevel input, characters 9-28:	>         apply path_ishprop.	>         ^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 36-67:	>       destruct H as [y (H1_y, H2_y)].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 857;
            data = "Toplevel input, characters 7-123:	>       destruct (@untrunc_istrunc -1 _ (IsEmbedding_funcofmembers y) (transport (fun z => y ∈ z) memb_v H1_y)) as [b Hb].	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 858;
            data = "Toplevel input, characters 7-16:	>       exists b.	>       ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 859;
            data = "Toplevel input, characters 17-70:	> exact (transport (fun z => [x, z] ∈ phi) Hb^ H2_y).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 860;
            data = "Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 7-45:	>     apply tr; exists (fun a => pr1 (h a)).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 861;
            data = "Toplevel input, characters 0-21:	> apply extensionality.	> ^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 862;
            data = "Toplevel input, characters 23-29:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 863;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 864;
            data = "Toplevel input, characters 20-51:	> generalize Hz; apply Trunc_rec.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 865;
            data = "Toplevel input, characters 33-47:	> intros [a Ha].	> ^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 866;
            data = "Toplevel input, characters 7-61:	>       exact (transport (fun w => w ∈ phi) Ha (pr2 (h a))).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 867;
            data = "Toplevel input, characters 5-6:	>     +	>     ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 6-18:	>     + intros z Hz.	>       ^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 868;
            data = "Toplevel input, characters 20-26:	> simpl.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 869;
            data = "Toplevel input, characters 7-28:	>       generalize (H1 z Hz).	>       ^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 870;
            data = "Toplevel input, characters 0-25:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 871;
            data = "Toplevel input, characters 0-17:	> intros [(a,b) p].	> ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 872;
            data = "Toplevel input, characters 0-11:	> simpl in p.	> ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 873;
            data = "Toplevel input, characters 7-16:	>       exists a.	>       ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 874;
            data = "Toplevel input, characters 17-93:	> transitivity ([func_of_members a, func_of_members b]); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 875;
            data = "Toplevel input, characters 7-16:	>       apply ap.	>       ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 876;
            data = "Toplevel input, characters 7-41:	>       apply H3 with (func_of_members a).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 877;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 878;
            data = "Toplevel input, characters 7-25:	>       exact (pr2 (h a)).	>       ^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 879;
            data = "Toplevel input, characters 7-52:	>       exact (transport (fun w => w ∈ phi) p^ Hz).	>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 880;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 881;
            data = "Toplevel input, characters 109-116:	>   hexists (fun w => forall y, y ∈ w <-> hexists (fun z => z ∈ x * (r z = y))).	>                                                           ^^^^^	Error:	In environment	ua : Univalence	r : V -> V	x : V	w : V	y : V	z : V	The term \"z ∈ x\" has type \"hProp\" while it is expected to have type \"V\".	";
            responses[i]=data;
          

            i = 882;
            data = "	";
            responses[i]=data;
          

            i = 883;
            data = "Toplevel input, characters 3-11:	>   intro r.	>   ^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 884;
            data = "Toplevel input, characters 12-39:	> refine (V_ind_hprop _ _ _).	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 885;
            data = "Toplevel input, characters 3-16:	>   intros A f _.	>   ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 886;
            data = "Toplevel input, characters 17-26:	> apply tr.	> ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 887;
            data = "Toplevel input, characters 11-32:	> exists (set (r o f)).	> ^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 888;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 889;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-29:	>   - apply (Trunc_functor -1).	>     ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 890;
            data = "Toplevel input, characters 5-18:	>     intros [a p].	>     ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 891;
            data = "Toplevel input, characters 0-13:	> exists (f a).	> ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 892;
            data = "Toplevel input, characters 0-6:	> split.	> ^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 893;
            data = "Toplevel input, characters 8-33:	> apply tr; exists a; auto.	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 894;
            data = "Toplevel input, characters 27-38:	> assumption.	> ^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 895;
            data = "Toplevel input, characters 3-4:	>   -	>   ^	Error: No focused proof (No proof-editing in progress).	Toplevel input, characters 4-20:	>   - apply Trunc_rec.	>     ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 896;
            data = "Toplevel input, characters 5-22:	>     intros [z [h p]].	>     ^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 897;
            data = "Toplevel input, characters 0-13:	> generalize h.	> ^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 898;
            data = "Toplevel input, characters 15-40:	> apply (Trunc_functor -1).	> ^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 899;
            data = "Toplevel input, characters 5-19:	>     intros [a p'].	>     ^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 900;
            data = "Toplevel input, characters 0-9:	> exists a.	> ^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 901;
            data = "Toplevel input, characters 11-52:	> transitivity (r z); auto with path_hints.	> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 902;
            data = "Toplevel input, characters 43-59:	> exact (ap r p').	> ^^^^^^^^^^^^^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 903;
            data = "Toplevel input, characters 0-4:	> Qed.	> ^^^^	Error: No focused proof (No proof-editing in progress).	";
            responses[i]=data;
          

            i = 904;
            data = "1 subgoal, subgoal 1 (ID 568)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall a : V, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ a * C x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 905;
            data = "1 subgoal, subgoal 1 (ID 568)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall a : V, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ a * C x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 906;
            data = "1 subgoal, subgoal 1 (ID 587)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ f a * C x)) ->	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 907;
            data = "1 subgoal, subgoal 1 (ID 591)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 908;
            data = "1 subgoal, subgoal 1 (ID 594)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  {w : V & forall x : V, x ∈ w <-> x ∈ set f * C x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 909;
            data = "1 subgoal, subgoal 1 (ID 600)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  forall x : V,	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) <-> x ∈ set f * C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 910;
            data = "2 subgoals, subgoal 1 (ID 603)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> x ∈ set f * C x		subgoal 2 (ID 604) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 911;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 603)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> x ∈ set f * C x		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 1), subgoal 1 (ID 656)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  {a : {a : A & C (f a)} & f a.1 = x} -> x ∈ set f * C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 912;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 665)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f * C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 913;
            data = "2 focused subgoals	(unfocused: 1), subgoal 1 (ID 667)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f		subgoal 2 (ID 668) is:	 C x	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 914;
            data = "1 focused subgoal	(unfocused: 1), subgoal 1 (ID 668)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  C x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 915;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal, subgoal 1 (ID 604)		subgoal 1 (ID 604) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 916;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 604)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)		(dependent evars: (printing disabled) )		1 focused subgoal	(unfocused: 0), subgoal 1 (ID 681)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 917;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 682)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set f -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 918;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 685)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  {a : A & f a = x} -> {a : {a : A & C (f a)} & f a.1 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 919;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 690)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  {a0 : {a0 : A & C (f a0)} & f a0.1 = x}		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 920;
            data = "1 focused subgoal	(unfocused: 0), subgoal 1 (ID 700)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  f (a; transport (fun x0 : V => C x0) p^ H2).1 = x		(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 921;
            data = "No more subgoals.	(dependent evars: (printing disabled) )		";
            responses[i]=data;
          

            i = 922;
            data = "<infomsg>separation is defined</infomsg>	";
            responses[i]=data;
          

            i = 923;
            data = "";
            responses[i]=data;
          

            i = 924;
            data = "";
            responses[i]=data;
          

            i = 925;
            data = "";
            responses[i]=data;
          

            i = 926;
            data = "";
            responses[i]=data;
          

            i = 927;
            data = "";
            responses[i]=data;
          

            i = 928;
            data = "";
            responses[i]=data;
          

            i = 929;
            data = "";
            responses[i]=data;
          

            i = 930;
            data = "";
            responses[i]=data;
          

            i = 931;
            data = "";
            responses[i]=data;
          

            i = 932;
            data = "";
            responses[i]=data;
          

            i = 933;
            data = "";
            responses[i]=data;
          

            i = 934;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.HIT.V</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<br>
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab378"></a><h1 class="section">The cumulative hierarchy <span class="inlinecode"><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a></span>.</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Basics.Notations.html#"><span class="id" title="library">HoTT.Basics.Notations</span></a> <a class="idref" href="HoTT.Basics.Utf8.html#"><span class="id" title="library">HoTT.Basics.Utf8</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.Unit.html#"><span class="id" title="library">Types.Unit</span></a> <a class="idref" href="HoTT.Types.Bool.html#"><span class="id" title="library">Types.Bool</span></a> <a class="idref" href="HoTT.Types.Universe.html#"><span class="id" title="library">Types.Universe</span></a> <a class="idref" href="HoTT.Types.Sigma.html#"><span class="id" title="library">Types.Sigma</span></a> <a class="idref" href="HoTT.Types.Arrow.html#"><span class="id" title="library">Types.Arrow</span></a> <a class="idref" href="HoTT.Types.Forall.html#"><span class="id" title="library">Types.Forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" title="library">HSet</span></a> <a class="idref" href="HoTT.UnivalenceImpliesFunext.html#"><span class="id" title="library">UnivalenceImpliesFunext</span></a> <a class="idref" href="HoTT.TruncType.html#"><span class="id" title="library">TruncType</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HIT.Truncations.html#"><span class="id" title="library">HIT.Truncations</span></a> <a class="idref" href="HoTT.HIT.quotient.html#"><span class="id" title="library">HIT.quotient</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
<a name="lab379"></a><h2 class="section">Pushout with respect to a relation</h2>
<div class="doc" scenenumber="4"> </div>

 This could be implemented using the pushouts in /HIT/Pushout.v, where <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.f"><span class="id" title="variable">f</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.g"><span class="id" title="variable">g</span></a></span> are <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Functor.Prod.Core.html#fst"><span class="id" title="definition">fst</span></a></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Grothendieck.ToCat.html#pr1"><span class="id" title="definition">pr1</span></a>)</span> and <span class="inlinecode">(<a class="idref" href="HoTT.Categories.Functor.Prod.Core.html#snd"><span class="id" title="definition">snd</span></a></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Grothendieck.ToCat.html#pr1"><span class="id" title="definition">pr1</span></a>)</span>, with domain {(a,b) : A * B &amp; R a b}. However, these pushouts weren't implemented when I started this work, and doing it this way is closer to exercise 10.11 of the HoTT book 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="RPushout"><span class="id" title="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a name="RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <span class="id" title="keyword">Type</span> :=<br>
| <a name="RPushout.inL"><span class="id" title="constructor">inL</span></a> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <span class="id" title="var">R</span><br>
| <a name="RPushout.inR"><span class="id" title="constructor">inR</span></a> : <span class="id" title="var">B</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <span class="id" title="var">R</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="RPushout.glue"><span class="id" title="axiom">glue</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout.RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>}<br>
  (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">i</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">j</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
: <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><br>
:= <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">a</span> ⇒ (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="var">a</span>)<br>
                        | <a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">b</span> ⇒ (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <span class="id" title="var">b</span>) <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="RPushout.RPushout_comp_glue"><span class="id" title="axiom">RPushout_comp_glue</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>}<br>
  (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">i</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">j</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a>) (<a class="idref" href="HoTT.HIT.V.html#RPushout.glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="module">RPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The non-depentent eliminator 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(54, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">i</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">j</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#RPushout_ind"><span class="id" title="definition">RPushout_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>) <a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(55, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="RPushout_comp_nd_glue"><span class="id" title="definition">RPushout_comp_nd_glue</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">i</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">j</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">gl</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>)<br>
  (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.HIT.V.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a>) (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#gl"><span class="id" title="variable">gl</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(56, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(57, '0_3_15');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>) (<span class="id" title="var">i</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(58, '0_3_15');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">gl</span>) (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" title="lemma">apD_const</span></a> (<a class="idref" href="HoTT.HIT.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <span class="id" title="var">P</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">gl</span>) (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">r</span>)<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(60, '0_3_15');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#RPushout_comp_glue"><span class="id" title="axiom">RPushout_comp_glue</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">P</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(61, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(62, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Bitotal relation 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(66, '0_3_19');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="bitotal"><span class="id" title="definition">bitotal</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(67, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
<a name="lab380"></a><h2 class="section">The cumulative hierarchy V</h2>
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(74, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(75, '0_3_23');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a name="CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U'</span>} :=<br>
| <a name="CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> {<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U</span>}} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(76, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(77, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.is0trunc_V"><span class="id" title="axiom">is0trunc_V</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(78, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Fixpoint</span> <a name="CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout.RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout.inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#RPushout.inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><br>
:= (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br>
     | <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>))<br>
    <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(79, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncation 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      ">
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_setext"><span class="id" title="definition">V_comp_setext</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The non-dependent eliminator 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(92, '0_3_31');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec"><span class="id" title="definition">V_rec</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(93, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(94, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(95, '0_3_31');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(96, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">H_setext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(97, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(98, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_nd_setext"><span class="id" title="definition">V_comp_nd_setext</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.HIT.V.html#RPushout"><span class="id" title="inductive">RPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(99, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(100, '0_3_31');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(101, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(102, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
<a name="lab381"></a><h2 class="section">Alternative induction principle (This is close to the one from the book)</h2>
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="equal_img"><span class="id" title="definition">equal_img</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="setext'"><span class="id" title="definition">setext'</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">R</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.HIT.V.html#RPushout_rec"><span class="id" title="definition">RPushout_rec</span></a> <span class="id" title="var">R</span> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <span class="id" title="var">R</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec'"><span class="id" title="definition">V_rec'</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext'</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br>
    <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">H_g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(117, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(118, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(119, '0_3_35');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(120, '0_3_35');
      "><br>
  <span class="id" title="tactic">apply</span> <span class="id" title="var">H_setext'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(121, '0_3_35');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(122, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(123, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(124, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(125, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(126, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(127, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(128, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(129, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(130, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(131, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(132, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(133, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(134, '0_3_35');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(135, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(136, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(137, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(138, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(139, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(140, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(141, '0_3_35');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(142, '0_3_35');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(143, '0_3_35');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(144, '0_3_35');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(145, '0_3_35');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(146, '0_3_35');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(147, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(148, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(152, '0_3_39');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_ind'"><span class="id" title="definition">V_ind'</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext'</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
    (<span class="id" title="var">eq_img</span>: <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>)<br>
    (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">H_g</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<br>
    (<span class="id" title="var">H_eqimg</span> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
             <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img"><span class="id" title="variable">eq_img</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a><br>
  )<br>
: <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(153, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(154, '0_3_39');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">H_set</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(155, '0_3_39');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(156, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">f</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(157, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">B</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(158, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_f</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(159, '0_3_39');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_g</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(160, '0_3_39');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(161, '0_3_39');
      "><br>
  { <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(162, '0_3_39');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(163, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(164, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(165, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(166, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(167, '0_3_39');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(168, '0_3_39');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(169, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(170, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(171, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(172, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(173, '0_3_39');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(174, '0_3_39');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inR"><span class="id" title="constructor">inR</span></a> <span class="id" title="var">R</span>) <span class="id" title="var">eq_img</span>)<br>
      (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(175, '0_3_39');
      "><br>
  { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#a6de5e3880d34535fbdc2e97dc6a65b0"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#inL"><span class="id" title="constructor">inL</span></a> <span class="id" title="var">R</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(176, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
  <span class="id" title="tactic">apply</span> (<span class="id" title="var">H_setext'</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(177, '0_3_39');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(178, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(179, '0_3_39');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">truncb</span> := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">truncb</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">trunca</span> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">trunca</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.HIT.V.html#glue"><span class="id" title="axiom">glue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Simpler induction principle when the goal is an hprop 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(207, '0_3_43');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_set</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">isHProp_P</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(208, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(209, '0_3_43');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(210, '0_3_43');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(211, '0_3_43');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(212, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(213, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(214, '0_3_43');
      "><br>
<span class="id" title="keyword">Context</span> `{<span class="id" title="var">ua</span> : <a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(215, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
<a name="lab382"></a><h2 class="section">Membership relation</h2>
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(222, '0_3_47');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="mem"><span class="id" title="definition">mem</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(223, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(224, '0_3_47');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(225, '0_3_47');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(226, '0_3_47');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(227, '0_3_47');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(228, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eqimg</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(229, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(230, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(231, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(232, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(233, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(234, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(235, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">"</span></a>x ∈ v" := (<a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a> <span class="id" title="var">x</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
<a name="lab383"></a><h2 class="section">Subset relation</h2>
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(256, '0_3_51');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="subset"><span class="id" title="definition">subset</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a><br>
:= <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="keyword">∀</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(257, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">"</span></a>x ⊆ y" := (<a class="idref" href="HoTT.HIT.V.html#subset"><span class="id" title="definition">subset</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(258, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
<a name="lab384"></a><h2 class="section">Bisimulation relation</h2>
 The equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in hProp_U : Type{U'}, hence the codomain is hProp@{U'}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(265, '0_3_55');
      ">
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a name="bisim_aux"><span class="id" title="definition">bisim_aux</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(266, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(267, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="keyword">with</span><br>
    (<span class="id" title="keyword">fun</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> ( <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
                               <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)) )<br>
    ).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(268, '0_3_55');
      "><br>
  <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(269, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">B'</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_g'</span> <span class="id" title="var">H_img</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(270, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(271, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(272, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(273, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(274, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(275, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(276, '0_3_55');
      "><br>
      <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(277, '0_3_55');
      "><span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">g'</span> <span class="id" title="var">b0</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g'</span> <span class="id" title="var">b0</span>)<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(278, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(279, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(280, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(281, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(282, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(283, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(284, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(285, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(286, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(287, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(288, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(289, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(290, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(291, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(292, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(293, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(294, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(295, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(296, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(297, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(298, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(299, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(300, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(301, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(302, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(303, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(304, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(305, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(306, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(307, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="bisimulation"><span class="id" title="definition">bisimulation</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp@</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">{</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">U'</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(308, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(309, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> (<a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#bisim_aux"><span class="id" title="definition">bisim_aux</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(310, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_img</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(311, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(312, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(313, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(314, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(315, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(316, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(317, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(318, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(319, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(320, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(321, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(322, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(323, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(324, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(325, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(326, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(327, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(328, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(329, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(330, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(331, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(332, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(333, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(334, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(335, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(336, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(337, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(338, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(339, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(340, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(341, '0_3_55');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(342, '0_3_55');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(343, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(344, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(345, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(346, '0_3_55');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(347, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(348, '0_3_55');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(349, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(350, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">"</span></a>u ~~ v" := (<a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(351, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Reflexive"><span class="id" title="class">Reflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(352, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(353, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(354, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>; <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(355, '0_3_55');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(356, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(357, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(358, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(359, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(360, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(361, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(362, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#equiv_iff_hprop"><span class="id" title="definition">equiv_iff_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(363, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> (<a class="idref" href="HoTT.HIT.V.html#reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> <span class="id" title="var">u</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(364, '0_3_55');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(365, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(366, '0_3_55');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(367, '0_3_55');
      "><br>
  <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(368, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(369, '0_3_55');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(370, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(371, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(372, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(373, '0_3_55');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(374, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(375, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(376, '0_3_55');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(377, '0_3_55');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(378, '0_3_55');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(379, '0_3_55');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(380, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(381, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
<a name="lab385"></a><h2 class="section">Canonical presentation of V-sets (Lemma 10.5.6)</h2>
<div class="doc" scenenumber="4"> </div>

 Using the regular kernel (with = instead of ~~) also works, but this seems to be a Coq bug, it should lead to a universe inconsistency in the monic_set_present lemma later. This version is the right way to do it. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(390, '0_3_59');
      ">
<span class="id" title="keyword">Definition</span> <a name="ker_bisim"><span class="id" title="definition">ker_bisim</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) := (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#b536d4c62efe2361a91a2d115328927a"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(391, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
  : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#fdd951a86e2a1b4ef3630e8a03060363"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(392, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(393, '0_3_59');
      "><br>
  <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(394, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(395, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(396, '0_3_59');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(400, '0_3_63');
      ">
<br>
<span class="id" title="keyword">Context</span> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">Au</span> <span class="id" title="var">Au'</span>: <span class="id" title="keyword">Type</span>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a>} {<span class="id" title="var">h'</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au'"><span class="id" title="variable">Au'</span></a>} {<span class="id" title="var">mu</span> : <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu"><span class="id" title="variable">mu</span></a>}<br>
  {<span class="id" title="var">mu'</span> : <a class="idref" href="HoTT.HIT.V.html#Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono'</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu'"><span class="id" title="variable">mu'</span></a>} {<span class="id" title="var">p</span> : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu"><span class="id" title="variable">mu</span></a>} {<span class="id" title="var">p'</span> : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu'"><span class="id" title="variable">mu'</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(401, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a'</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
                     <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">a'</span> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#a'"><span class="id" title="variable">a'</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(402, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(403, '0_3_63');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(404, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(405, '0_3_63');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.HIT.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a>) (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(406, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(407, '0_3_63');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.HIT.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a'</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(408, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(409, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(410, '0_3_63');
      "><br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a'</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a'"><span class="id" title="variable">a'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(411, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(412, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(413, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(414, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(415, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(416, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(417, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(418, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(419, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(420, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(421, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(422, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(423, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(424, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(425, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(426, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(427, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(428, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(429, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(430, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(431, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(432, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(433, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(434, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(435, '0_3_63');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(436, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X"><span class="id" title="variable">X</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(437, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Arrow.html#transport_arrow"><span class="id" title="definition">transport_arrow</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X"><span class="id" title="variable">X</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(438, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(439, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(440, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(441, '0_3_63');
      "><br>
  2: <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(442, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(443, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(444, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">a'</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(445, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#transport_path_universe"><span class="id" title="definition">transport_path_universe</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(446, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(447, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h'"><span class="id" title="variable">h'</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">m</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <span class="id" title="var">m</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">m</span><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(448, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(449, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(450, '0_3_63');
      "><br>
  <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(451, '0_3_63');
      "><br>
  <span class="id" title="tactic">transitivity</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e4b535f859a91001a949d70407b794ae"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transportD"><span class="id" title="definition">transportD</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(452, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(453, '0_3_63');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(454, '0_3_63');
      "><br>
  <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.V.html#mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(455, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(456, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(457, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
This lemma actually says a little more than 10.5.6, i.e., that Au is a hSet 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(461, '0_3_67');
      ">
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">∃</span></a> <a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">(</span></a><span class="id" title="var">Au</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">m</span> : <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Specif.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(462, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(463, '0_3_67');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(464, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(465, '0_3_67');
      "><br>
    <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.quotient.html#quotient_kernel_factor"><span class="id" title="lemma">quotient_kernel_factor</span></a> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.HIT.V.html#ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> <span class="id" title="var">f</span>))<br>
      <span class="id" title="keyword">as</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">eu</span> [<span class="id" title="var">mu</span> (((<span class="id" title="var">hset_Au</span>, <span class="id" title="var">epi_eu</span>), <span class="id" title="var">mono_mu</span>), <span class="id" title="var">factor</span>)]]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(466, '0_3_67');
      "><br>
    <span class="id" title="tactic">∃</span> <span class="id" title="var">Au</span>, <span class="id" title="var">mu</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(467, '0_3_67');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(468, '0_3_67');
      "><span class="id" title="tactic">exact</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">hset_Au</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">mono_mu</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(469, '0_3_67');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(470, '0_3_67');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(471, '0_3_67');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(472, '0_3_67');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(473, '0_3_67');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(474, '0_3_67');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">epi_eu</span> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(475, '0_3_67');
      "><br>
      <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" title="projection">center</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(476, '0_3_67');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(477, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(478, '0_3_67');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">mu</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(479, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(480, '0_3_67');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">mu</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(481, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(482, '0_3_67');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(483, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">mu</span> ((<span class="id" title="var">hset</span>, <span class="id" title="var">mono</span>), <span class="id" title="var">p</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(484, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au'</span> [<span class="id" title="var">mu'</span> ((<span class="id" title="var">hset'</span>, <span class="id" title="var">mono'</span>), <span class="id" title="var">p'</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(485, '0_3_67');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(486, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(487, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="type_of_members"><span class="id" title="definition">type_of_members</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(488, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">"</span></a>[ u ]" := (<a class="idref" href="HoTT.HIT.V.html#type_of_members"><span class="id" title="definition">type_of_members</span></a> <span class="id" title="var">u</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(489, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="func_of_members"><span class="id" title="definition">func_of_members</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)) : <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(490, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_hset_typeofmembers"><span class="id" title="definition">is_hset_typeofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> (<a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a>) := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(491, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(492, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(493, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a name="lab386"></a><h2 class="section">Lemmas 10.5.8 (i) &amp; (vii), we put them here because they are useful later</h2>
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(500, '0_3_71');
      ">
<span class="id" title="keyword">Lemma</span> <a name="extensionality"><span class="id" title="lemma">extensionality</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">},</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(501, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(502, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(503, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(504, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(505, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(506, '0_3_71');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(507, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(508, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(509, '0_3_71');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(510, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(511, '0_3_71');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a>1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(512, '0_3_71');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(513, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(514, '0_3_71');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(515, '0_3_71');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(516, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(517, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<span class="id" title="var">H2</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(518, '0_3_71');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(519, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(520, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(521, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(522, '0_3_71');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(523, '0_3_71');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(524, '0_3_71');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(525, '0_3_71');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
: <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(526, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(527, '0_3_71');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(528, '0_3_71');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(529, '0_3_71');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(530, '0_3_71');
      "><span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(531, '0_3_71');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(532, '0_3_71');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(533, '0_3_71');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(534, '0_3_71');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(535, '0_3_71');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(536, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
<a name="lab387"></a><h2 class="section">Two useful lemmas</h2>
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(543, '0_3_75');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a name="irreflexive_mem"><span class="id" title="instance">irreflexive_mem</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Irreflexive"><span class="id" title="class">Irreflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(544, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(545, '0_3_75');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">x0</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x0"><span class="id" title="variable">x0</span></a>) <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).   { </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(546, '0_3_75');
      "><span class="id" title="tactic">intro</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(547, '0_3_75');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(548, '0_3_75');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(549, '0_3_75');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(550, '0_3_75');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">Hv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(551, '0_3_75');
      "><br>
  <span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">v</span> <span class="id" title="var">Hv</span> <span class="id" title="var">Hv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(552, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(553, '0_3_75');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(554, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(555, '0_3_75');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(556, '0_3_75');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(557, '0_3_75');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(558, '0_3_75');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(559, '0_3_75');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(560, '0_3_75');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(561, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(562, '0_3_75');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(563, '0_3_75');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(564, '0_3_75');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(565, '0_3_75');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(566, '0_3_75');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(567, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(568, '0_3_75');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(569, '0_3_75');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(570, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
<a name="lab388"></a><h2 class="section">Definitions of particular sets in V</h2>
<div class="doc" scenenumber="4"> </div>

 The empty set 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(579, '0_3_79');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_empty"><span class="id" title="definition">V_empty</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(580, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The singleton {u} 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(584, '0_3_83');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_singleton"><span class="id" title="definition">V_singleton</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Unit_ind"><span class="id" title="definition">Unit_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(585, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="isequiv_ap_V_singleton"><span class="id" title="instance">isequiv_ap_V_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (@<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(586, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(587, '0_3_83');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#BuildIsEquiv"><span class="id" title="constructor">BuildIsEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> ].</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(588, '0_3_83');
      "><br>
  { <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(589, '0_3_83');
      "><span class="id" title="tactic">specialize</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(590, '0_3_83');
      "><span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(591, '0_3_83');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(592, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(593, '0_3_83');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(594, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The pair {u,v} 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(598, '0_3_87');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair"><span class="id" title="definition">V_pair</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(599, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair"><span class="id" title="lemma">path_pair</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">u'</span> <span class="id" title="var">v'</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>}} : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u'"><span class="id" title="variable">u'</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v'"><span class="id" title="variable">v'</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u'"><span class="id" title="variable">u'</span></a> <a class="idref" href="HoTT.HIT.V.html#v'"><span class="id" title="variable">v'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(600, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(601, '0_3_87');
      "><br>
  <span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(602, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(603, '0_3_87');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(604, '0_3_87');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(605, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(606, '0_3_87');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(607, '0_3_87');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(608, '0_3_87');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(609, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(610, '0_3_87');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(611, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(612, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(613, '0_3_87');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(614, '0_3_87');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(615, '0_3_87');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(616, '0_3_87');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(617, '0_3_87');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(618, '0_3_87');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(619, '0_3_87');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(620, '0_3_87');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(621, '0_3_87');
      "><br>
    <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>| <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(622, '0_3_87');
      "><br>
  + <span class="id" title="tactic">intros</span> (<span class="id" title="var">p1</span>, <span class="id" title="var">p2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(623, '0_3_87');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(624, '0_3_87');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(625, '0_3_87');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">p2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(626, '0_3_87');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(627, '0_3_87');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(628, '0_3_87');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(629, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The ordered pair (u,v) 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(633, '0_3_91');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(634, '0_3_91');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="10570db8ff454b79fa435e153566df40"><span class="id" title="notation">"</span></a> [ u , v ] " := (<a class="idref" href="HoTT.HIT.V.html#V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(635, '0_3_91');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> {<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(636, '0_3_91');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(637, '0_3_91');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(638, '0_3_91');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(639, '0_3_91');
      "><span class="id" title="tactic">assert</span> (<span class="id" title="var">p1</span> : <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(640, '0_3_91');
      "><br>
    + <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(641, '0_3_91');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(642, '0_3_91');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(643, '0_3_91');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(644, '0_3_91');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(645, '0_3_91');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a><a class="idref" href="HoTT.Basics.Overture.html#77ed8f3b30fae66d423e9f3dab28cba2"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(646, '0_3_91');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(647, '0_3_91');
      "><br>
    + <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(648, '0_3_91');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(649, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.HIT.Truncations.html#hor"><span class="id" title="definition">hor</span></a> (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">d</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(650, '0_3_91');
      "><br>
      { <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(651, '0_3_91');
      "><br>
        { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(652, '0_3_91');
      "><br>
          <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(653, '0_3_91');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(654, '0_3_91');
      "><br>
        × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">left</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(655, '0_3_91');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(656, '0_3_91');
      "><br>
        × <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(657, '0_3_91');
      "><br>
          <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>); <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(658, '0_3_91');
      "><br>
          <span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p''</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(659, '0_3_91');
      "><br>
          <span class="id" title="tactic">left</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(660, '0_3_91');
      "><span class="id" title="tactic">right</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(661, '0_3_91');
      "><span class="id" title="tactic">intro</span> <span class="id" title="tactic">case</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="tactic">case</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">p'</span>| <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(662, '0_3_91');
      "><br>
      2: <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(663, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(664, '0_3_91');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(665, '0_3_91');
      "><br>
        <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(666, '0_3_91');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(667, '0_3_91');
      "><br>
        <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(668, '0_3_91');
      "><br>
        <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>) | <span class="id" title="tactic">reflexivity</span>]. }</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(669, '0_3_91');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">H''</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">c</span> <span class="id" title="var">d</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)<br>
        <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> (<span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">H'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(670, '0_3_91');
      "><br>
      <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">H''</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(671, '0_3_91');
      "><br>
- <span class="id" title="tactic">intros</span> (<span class="id" title="var">p</span>, <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(672, '0_3_91');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(673, '0_3_91');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(674, '0_3_91');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(675, '0_3_91');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(676, '0_3_91');
      "><span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(677, '0_3_91');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(678, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The cartesian product a × b 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(682, '0_3_95');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(683, '0_3_95');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="cff9f46c83d2a5a363b7aa39336cc6c0"><span class="id" title="notation">"</span></a> a × b " := (<a class="idref" href="HoTT.HIT.V.html#V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(684, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
f is a function with domain a and codomain b 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(688, '0_3_99');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_is_func"><span class="id" title="definition">V_is_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) := <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#cff9f46c83d2a5a363b7aa39336cc6c0"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#fa6a5bba8fa0e18b4ac14595799ed8c1"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(689, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The set of functions from a to b 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(693, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_func"><span class="id" title="definition">V_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> )).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(694, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The union of a set Uv 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(698, '0_3_107');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_union"><span class="id" title="definition">V_union</span></a> (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) :=<br>
  @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(699, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
The ordinal successor x ∪ {x} 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(703, '0_3_111');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_succ"><span class="id" title="definition">V_succ</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(704, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(705, '0_3_111');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(706, '0_3_111');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(707, '0_3_111');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">a</span><br>
                                          | <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span> <span class="id" title="keyword">end</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(708, '0_3_111');
      "><br>
  <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(709, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(710, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(711, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(712, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(713, '0_3_111');
      "><br>
    + <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(714, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(715, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(716, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">b</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(717, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(718, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(719, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(720, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(721, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(722, '0_3_111');
      "><br>
    + <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(723, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(724, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(725, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(726, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(727, '0_3_111');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(728, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(729, '0_3_111');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(730, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
The set of finite ordinals 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(734, '0_3_115');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_omega"><span class="id" title="definition">V_omega</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fix</span> <span class="id" title="var">I</span> <span class="id" title="var">n</span> := <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span> 0   ⇒ <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><br>
                              | <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> (<a class="idref" href="HoTT.HIT.V.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.HIT.V.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">end</span>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(735, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
<a name="lab389"></a><h2 class="section">Axioms of set theory (theorem 10.5.8)</h2>
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(742, '0_3_119');
      ">
<br>
<span class="id" title="keyword">Lemma</span> <a name="not_mem_Vempty"><span class="id" title="lemma">not_mem_Vempty</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><a class="idref" href="HoTT.Basics.Overture.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(743, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(744, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(745, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(746, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">ff</span> <span class="id" title="var">_</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(747, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">ff</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(748, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(749, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pairing"><span class="id" title="lemma">pairing</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hor"><span class="id" title="definition">hor</span></a> (<a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(750, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(751, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(752, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(753, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(754, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(755, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [[|] <span class="id" title="var">p</span>]; [<span class="id" title="tactic">left</span>|<span class="id" title="tactic">right</span>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(756, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">p</span> | <span class="id" title="var">p</span>]; [<span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a> | <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(757, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(758, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="infinity"><span class="id" title="lemma">infinity</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(759, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(760, '0_3_119');
      "><br>
  <span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(761, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> 0; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(762, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(763, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(764, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">n</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(765, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(766, '0_3_119');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(767, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(768, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="union"><span class="id" title="lemma">union</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(769, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(770, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(771, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_union"><span class="id" title="definition">V_union</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(772, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(773, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(774, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(775, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(776, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">u'</span> <span class="id" title="var">x'</span>] <span class="id" title="var">p</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(777, '0_3_119');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(778, '0_3_119');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(779, '0_3_119');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(780, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">x'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(781, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(782, '0_3_119');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(783, '0_3_119');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(784, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">u'</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(785, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(786, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u</span> (<span class="id" title="var">Hx</span>, <span class="id" title="var">Hu</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(787, '0_3_119');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>) <span class="id" title="var">Hu</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(788, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(789, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u'</span> <span class="id" title="var">pu</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(790, '0_3_119');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">pu</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hx</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(791, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(792, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">x'</span> <span class="id" title="var">px</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(793, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(794, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">u'</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">x'</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(795, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">px</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(796, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(797, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="function"><span class="id" title="lemma">function</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#V_is_func"><span class="id" title="definition">V_is_func</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(798, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(799, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(800, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_func"><span class="id" title="definition">V_func</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(801, '0_3_119');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_u</span> : <span class="id" title="var">u</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">u</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(802, '0_3_119');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_v</span> : <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">v</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(803, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">phi</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(804, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(805, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(806, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(807, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(808, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(809, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(810, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(811, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(812, '0_3_119');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(813, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(814, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(815, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(816, '0_3_119');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(817, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(818, '0_3_119');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">memb_u</span> <span class="id" title="var">Hx</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(819, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(820, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(821, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(822, '0_3_119');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(823, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(824, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(825, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(826, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">p_phi</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(827, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(828, '0_3_119');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(829, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> (<span class="id" title="var">Hy</span>, <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(830, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(831, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(832, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(833, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(834, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(835, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y'</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(836, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(837, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a'</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(838, '0_3_119');
      "><br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px</span>, <span class="id" title="var">py</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(839, '0_3_119');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px'</span>, <span class="id" title="var">py'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(840, '0_3_119');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(841, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a'</span>));<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(842, '0_3_119');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(843, '0_3_119');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(844, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> (<span class="id" title="var">px</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <span class="id" title="var">px'</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(845, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> ((<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>), <span class="id" title="var">H3</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(846, '0_3_119');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(847, '0_3_119');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><span class="id" title="var">u</span><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">b</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">[</span></a><span class="id" title="var">v</span><a class="idref" href="HoTT.HIT.V.html#95e1ee98dab96bee6bcb9a9276f9ec2d"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(848, '0_3_119');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(849, '0_3_119');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(850, '0_3_119');
      "><br>
      <span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">y</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(851, '0_3_119');
      "><br>
      <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.HIT.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">y</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span><br>
                                 (<span class="id" title="var">H2</span> <span class="id" title="var">x</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_u</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(852, '0_3_119');
      "><br>
      { <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(853, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)] [<span class="id" title="var">y'</span> (<span class="id" title="var">H1_y'</span>, <span class="id" title="var">H2_y'</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(854, '0_3_119');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(855, '0_3_119');
      "><br>
        <span class="id" title="tactic">∃</span> (<span class="id" title="var">H3</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> <a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">H2_y</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">H2_y'</span><a class="idref" href="Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(856, '0_3_119');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(857, '0_3_119');
      "><br>
      <span class="id" title="tactic">destruct</span> (@<a class="idref" href="HoTT.HIT.Truncations.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">y</span>) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">y</span> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span> <span class="id" title="var">H1_y</span>)) <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">Hb</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(858, '0_3_119');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(859, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Hb</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2_y</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(860, '0_3_119');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(861, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(862, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(863, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(864, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hz</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(865, '0_3_119');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Ha</span>].</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(866, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Ha</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(867, '0_3_119');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(868, '0_3_119');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(869, '0_3_119');
      "><br>
      <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(870, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(871, '0_3_119');
      "><span class="id" title="tactic">intros</span> [(<span class="id" title="var">a</span>,<span class="id" title="var">b</span>) <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(872, '0_3_119');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(873, '0_3_119');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(874, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#10570db8ff454b79fa435e153566df40"><span class="id" title="notation">]</span></a>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(875, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(876, '0_3_119');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">H3</span> <span class="id" title="keyword">with</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(877, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(878, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(879, '0_3_119');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(880, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(881, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="replacement"><span class="id" title="lemma">replacement</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(882, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(883, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">r</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(884, '0_3_119');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(885, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(886, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(887, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="var">r</span> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <span class="id" title="var">f</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(888, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(889, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(890, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(891, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(892, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(893, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(894, '0_3_119');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(895, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(896, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">z</span> [<span class="id" title="var">h</span> <span class="id" title="var">p</span>]]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(897, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(898, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(899, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(900, '0_3_119');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(901, '0_3_119');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">r</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(902, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">r</span> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(903, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(904, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="separation"><span class="id" title="lemma">separation</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a><br>
  <a class="idref" href="HoTT.HIT.Truncations.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#ed947126266a9babd76dbeaa4b4b4870"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(905, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(906, '0_3_119');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(907, '0_3_119');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(908, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(909, '0_3_119');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">C</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>)<a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> ⇒ <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>))). </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(910, '0_3_119');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(911, '0_3_119');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(912, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">h</span>] <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(913, '0_3_119');
      "><span class="id" title="tactic">split</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(914, '0_3_119');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.Truncations.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">assumption</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(915, '0_3_119');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(916, '0_3_119');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(917, '0_3_119');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(918, '0_3_119');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HIT.Truncations.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> <a class="idref" href="HoTT.Basics.Overture.html#e69d10f17606e66cf161b3799092cb31"><span class="id" title="notation">-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(919, '0_3_119');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(920, '0_3_119');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(921, '0_3_119');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(922, '0_3_119');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(923, '0_3_119');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(924, '0_3_119');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
