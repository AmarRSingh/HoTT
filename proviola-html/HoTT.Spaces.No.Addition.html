<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "<infomsg>HasAddition is defined</infomsg>	<infomsg>HasAddition_rect is defined</infomsg>	<infomsg>HasAddition_ind is defined</infomsg>	<infomsg>HasAddition_rec is defined</infomsg>	<infomsg>empty_options is defined</infomsg>	<infomsg>sum_options is defined</infomsg>	";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "<infomsg>hasaddition_maxsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 23;
            data = "<infomsg>hasaddition_ordsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "1 subgoal (ID 21)	  	  ============================	  HasAddition DecSort	";
            responses[i]=data;
          

            i = 26;
            data = "2 subgoals (ID 23)	  	  ============================	  InSort DecSort Empty Empty		subgoal 2 (ID 24) is:	 forall L R L' R' : Type,	 InSort DecSort L R ->	 InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	";
            responses[i]=data;
          

            i = 27;
            data = "1 subgoal (ID 23)	  	  ============================	  InSort DecSort Empty Empty	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 24)		subgoal 1 (ID 24) is:	 forall L R L' R' : Type,	 InSort DecSort L R ->	 InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	";
            responses[i]=data;
          

            i = 28;
            data = "1 subgoal (ID 24)	  	  ============================	  forall L R L' R' : Type,	  InSort DecSort L R ->	  InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	No more subgoals.	";
            responses[i]=data;
          

            i = 29;
            data = "<infomsg>hasaddition_decsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "<infomsg>H is declared</infomsg>	";
            responses[i]=data;
          

            i = 32;
            data = "<infomsg>S is declared</infomsg>	<infomsg>H0 is declared</infomsg>	";
            responses[i]=data;
          

            i = 33;
            data = "<infomsg>No is defined</infomsg>	";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "<infomsg>L is declared</infomsg>	<infomsg>R is declared</infomsg>	<infomsg>Sx is declared</infomsg>	<infomsg>xL is declared</infomsg>	<infomsg>xR is declared</infomsg>	<infomsg>xcut is declared</infomsg>	";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>A is defined</infomsg>	";
            responses[i]=data;
          

            i = 37;
            data = "<infomsg>xL_plus is declared</infomsg>	<infomsg>xR_plus is declared</infomsg>	<infomsg>xL_lt_xR_plus is declared</infomsg>	";
            responses[i]=data;
          

            i = 38;
            data = "1 subgoal (ID 55)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  {g	  : forall y : No,	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y)} &	  (forall y z : No, y <= z -> (g y).1 <= (g z).1) *	  (forall y z : No, y < z -> (g y).1 < (g z).1)}	";
            responses[i]=data;
          

            i = 39;
            data = "1 subgoal (ID 55)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  {g	  : forall y : No,	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y)} &	  (forall y z : No, y <= z -> (g y).1 <= (g z).1) *	  (forall y z : No, y < z -> (g y).1 < (g z).1)}	";
            responses[i]=data;
          

            i = 40;
            data = "5 subgoals (ID 90)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r)),	  (forall (l : L0) (r : R0),	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) (fxL l) 	     (fxR r)) ->	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ xL0 | xR0 // xcut0 }}		subgoal 2 (ID 92) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 94) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l) (?dcut L' R' s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	subgoal 4 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	subgoal 5 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 41;
            data = "1 subgoal (ID 90)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r)),	  (forall (l : L0) (r : R0),	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) (fxL l) 	     (fxR r)) ->	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ xL0 | xR0 // xcut0 }}	1 subgoal (ID 529)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 42;
            data = "1 subgoal (ID 531)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 43;
            data = "1 subgoal (ID 533)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 44;
            data = "1 subgoal (ID 548)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 45;
            data = "1 subgoal (ID 563)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 46;
            data = "2 subgoals (ID 565)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  forall (l : L'') (r : R''), zL l < zR r		subgoal 2 (ID 567) is:	 (fun y : GenNo S =>	  {x_plus_y : No &	  (forall l : L, (xL_plus l).1 y < x_plus_y) *	  (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 47;
            data = "1 subgoal (ID 565)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  forall (l : L'') (r : R''), zL l < zR r	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 subgoals (ID 567)		subgoal 1 (ID 567) is:	 (fun y : GenNo S =>	  {x_plus_y : No &	  (forall l : L, (xL_plus l).1 y < x_plus_y) *	  (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	subgoal 2 (ID 92) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 94) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R'	       s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	       xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	subgoal 4 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	subgoal 5 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 48;
            data = "1 subgoal (ID 567)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	1 subgoal (ID 784)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 49;
            data = "2 subgoals (ID 798)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall l : L, (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}		subgoal 2 (ID 799) is:	 forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 50;
            data = "1 subgoal (ID 798)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall l : L, (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}	1 subgoal (ID 800)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  l : L	  ============================	  (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}	";
            responses[i]=data;
          

            i = 51;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	5 subgoals (ID 799)		subgoal 1 (ID 799) is:	 forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	subgoal 2 (ID 92) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 94) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	       s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	       s xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	subgoal 4 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	subgoal 5 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 52;
            data = "1 subgoal (ID 799)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	1 subgoal (ID 840)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  r : R	  ============================	  {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 53;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 subgoals (ID 92)		subgoal 1 (ID 92) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 2 (ID 94) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 3 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 4 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 54;
            data = "1 subgoal (ID 92)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (x y : GenNo S)	  (a : (fun y0 : GenNo S =>	        {x_plus_y : No &	        (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	        (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	  (b : (fun y0 : GenNo S =>	        {x_plus_y : No &	        (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	        (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	  (p : x <= y) (q : y <= x),	  (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	     (z : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	     (w : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	   z.1 <= w.1) x y p a b ->	  (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	     (z : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	     (w : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	   z.1 <= w.1) y x q b a ->	  transport	    (fun y0 : GenNo S =>	     {x_plus_y : No &	     (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	     (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	    (path_No x y p q) a = b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 55;
            data = "3 subgoals (ID 94)		subgoal 1 (ID 94) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 2 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 3 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal (ID 94)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	  (forall l : L0,	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	     (fxL l)	     ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	         (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	         (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	         (x_plus_yL : forall l0 : L'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                       (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                        (yL0 l0))	         (x_plus_yR : forall r : R'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                       (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                        (yR0 r))	         (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                            (fun (x y : GenNo S) (_ : x < y)	                               (z : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l1 : L,	                                      (xL_plus l1).1 y0 < x_plus_y) *	                                     (forall r0 : R,	                                      x_plus_y < (xR_plus r0).1 y0)}) x)	                               (w : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l1 : L,	                                      (xL_plus l1).1 y0 < x_plus_y) *	                                     (forall r0 : R,	                                      x_plus_y < (xR_plus r0).1 y0)}) y) =>	                             z.1 < w.1) (yL0 l0) (yR0 r) 	                              (ycut0 l0 r) (x_plus_yL l0) 	                              (x_plus_yR r)) =>	       let L'' := L + L'0 in	       let R'' := R + R'0 in	       let zL :=	         sum_ind (fun _ : L + L'0 => No)	           (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	           (fun l0 : L'0 => (x_plus_yL l0).1)	         :	         L'' -> No in	       let zR :=	         sum_ind (fun _ : R + R'0 => No)	           (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	           (fun r : R'0 => (x_plus_yR r).1)	         :	         R'' -> No in	       let zcut :=	         plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	           x_plus_yL_lt_yR in	       let X := sum_options L R L'0 R'0 Sx s0 in	       ({{ zL | zR // zcut }};	       (fun l0 : L => lt_lopt zL zR zcut (inl l0),	       fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	        fycut)) ->	  forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	  (forall r : R',	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	     ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	         (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	         (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	         (x_plus_yL : forall l : L'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                       (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                        (yL0 l))	         (x_plus_yR : forall r0 : R'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l : L, (xL_plus l).1 y < x_plus_y) *	                       (forall r1 : R, x_plus_y < (xR_plus r1).1 y)})	                        (yR0 r0))	         (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                            (fun (x y : GenNo S) (_ : x < y)	                               (z : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l0 : L,	                                      (xL_plus l0).1 y0 < x_plus_y) *	                                     (forall r1 : R,	                                      x_plus_y < (xR_plus r1).1 y0)}) x)	                               (w : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l0 : L,	                                      (xL_plus l0).1 y0 < x_plus_y) *	                                     (forall r1 : R,	                                      x_plus_y < (xR_plus r1).1 y0)}) y) =>	                             z.1 < w.1) (yL0 l) (yR0 r0) 	                              (ycut0 l r0) (x_plus_yL l) 	                              (x_plus_yR r0)) =>	       let L'' := L + L'0 in	       let R'' := R + R'0 in	       let zL :=	         sum_ind (fun _ : L + L'0 => No)	           (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	           (fun l : L'0 => (x_plus_yL l).1)	         :	         L'' -> No in	       let zR :=	         sum_ind (fun _ : R + R'0 => No)	           (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	           (fun r0 : R'0 => (x_plus_yR r0).1)	         :	         R'' -> No in	       let zcut :=	         plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	           x_plus_yL_lt_yR in	       let X := sum_options L R L'0 R'0 Sx s0 in	       ({{ zL | zR // zcut }};	       (fun l : L => lt_lopt zL zR zcut (inl l),	       fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	        fxR fxcut) (fyR r)) ->	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (le_lr xL0 xR0 xcut0 yL yR ycut p q)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r) 	                             (ycut0 l r) (x_plus_yL l) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r) 	                             (ycut0 l r) (x_plus_yL l) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 57;
            data = "2 subgoals (ID 96)		subgoal 1 (ID 96) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 2 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	1 subgoal (ID 96)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyL l) ->	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (lt_l xL0 xR0 xcut0 yL yR ycut l p)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 98)		subgoal 1 (ID 98) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	1 subgoal (ID 98)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL	       fyR fycut) ->	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (lt_r xL0 xR0 xcut0 yL yR ycut r p)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL	       fyR fycut)	";
            responses[i]=data;
          

            i = 58;
            data = "No more subgoals.	<infomsg>plus_inner is defined</infomsg>	";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "1 subgoal (ID 115)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  let L'' := L + L' in	  let R'' := R + R' in	  let zL :=	    sum_ind (fun _ : L + L' => No)	      (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	      (fun l : L' => (plus_inner.1 (yL l)).1) in	  let zR :=	    sum_ind (fun _ : R + R' => No)	      (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	      (fun r : R' => (plus_inner.1 (yR r)).1) in	  let Sz := sum_options L R L' R' Sx Sy in	  {zcut : forall (l : L'') (r : R''), zL l < zR r &	  (plus_inner.1 {{ yL | yR // ycut }}).1 = {{ zL | zR // zcut }}}	";
            responses[i]=data;
          

            i = 70;
            data = "1 subgoal (ID 115)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  let L'' := L + L' in	  let R'' := R + R' in	  let zL :=	    sum_ind (fun _ : L + L' => No)	      (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	      (fun l : L' => (plus_inner.1 (yL l)).1) in	  let zR :=	    sum_ind (fun _ : R + R' => No)	      (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	      (fun r : R' => (plus_inner.1 (yR r)).1) in	  let Sz := sum_options L R L' R' Sx Sy in	  {zcut : forall (l : L'') (r : R''), zL l < zR r &	  (plus_inner.1 {{ yL | yR // ycut }}).1 = {{ zL | zR // zcut }}}	";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "1 focused subgoal	(shelved: 1) (ID 118)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  (plus_inner.1 {{ yL | yR // ycut }}).1 =	  {{ sum_ind (fun _ : L + L' => No)	       (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	       (fun l : L' => (plus_inner.1 (yL l)).1) | sum_ind	                                                 (fun _ : R + R' => No)	                                                 (fun r : R =>	                                                 (xR_plus r).1	                                                 {{ yL | yR // ycut }})	                                                 (fun r : R' =>	                                                 (plus_inner.1 (yR r)).1) // 	  ?zcut }}	";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "1 focused subgoal	(shelved: 1) (ID 120)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  {|	  game_of := opt (L + L') (R + R') (sum_options L R L' R' Sx Sy)	               (fun x : L + L' =>	                game_of	                  (sum_ind (fun _ : L + L' => No)	                     (fun l : L =>	                      (xL_plus l).1	                        {{ fun l0 : L' =>	                           {|	                           game_of := game_of (yL l0);	                           isno_game_of := isno_game_of (yL l0) |} | 	                        (fun r : R' =>	                         {|	                         game_of := game_of (yR r);	                         isno_game_of := isno_game_of (yR r) |}) // ycut }})	                     (fun l : L' =>	                      (No_ind_internal	                         (fun y : GenNo S =>	                          {x_plus_y : No &	                          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                          (forall r : R, x_plus_y < (xR_plus r).1 y)})	                         (fun (x0 y : GenNo S) (_ : x0 <= y)	                            (z : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 x0 < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          => z.1 <= w.1)	                         (fun (x0 y : GenNo S) (_ : x0 < y)	                            (z : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 x0 < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          => z.1 < w.1)	                         (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                            (yL0 : L'0 -> GenNo S) 	                            (yR0 : R'0 -> GenNo S)	                            (ycut0 : forall (l0 : L'0) 	                                     (r : R'0), yL0 l0 < yR0 r)	                            (x_plus_yL : forall l0 : L'0,	                                         {x_plus_y : No &	                                         (forall l1 : L,	                                          (xL_plus l1).1 (yL0 l0) < x_plus_y) *	                                         (forall r : R,	                                          x_plus_y < (xR_plus r).1 (yL0 l0))})	                            (x_plus_yR : forall r : R'0,	                                         {x_plus_y : No &	                                         (forall l0 : L,	                                          (xL_plus l0).1 (yR0 r) < x_plus_y) *	                                         (forall r0 : R,	                                          x_plus_y < (xR_plus r0).1 (yR0 r))})	                            (x_plus_yL_lt_yR : forall 	                                               (l0 : L'0) 	                                               (r : R'0),	                                               (x_plus_yL l0).1 <	                                               (x_plus_yR r).1) =>	                          let L'' := L + L'0 in	                          let R'' := R + R'0 in	                          let zL :=	                            sum_ind (fun _ : L + L'0 => No)	                              (fun l0 : L =>	                               (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                              (fun l0 : L'0 => (x_plus_yL l0).1) in	                          let zR :=	                            sum_ind (fun _ : R + R'0 => No)	                              (fun r : R =>	                               (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                              (fun r : R'0 => (x_plus_yR r).1) in	                          let zcut :=	                            plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                              x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                          let X := sum_options L R L'0 R'0 Sx s in	                          ({{ zL | zR // zcut }};	                          (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                          fun r : R => lt_ropt zL zR zcut (inl r))))	                         plus_inner_subproof0 plus_inner_subproof1	                         plus_inner_subproof2 plus_inner_subproof3	                         (game_of (yL l)) (isno_game_of (yL l))).1) x))	               (fun x : R + R' =>	                game_of	                  (sum_ind (fun _ : R + R' => No)	                     (fun r : R =>	                      (xR_plus r).1	                        {{ fun l : L' =>	                           {|	                           game_of := game_of (yL l);	                           isno_game_of := isno_game_of (yL l) |} | 	                        (fun r0 : R' =>	                         {|	                         game_of := game_of (yR r0);	                         isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                     (fun r : R' =>	                      (No_ind_internal	                         (fun y : GenNo S =>	                          {x_plus_y : No &	                          (forall l : L, (xL_plus l).1 y < x_plus_y) *	                          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                         (fun (x0 y : GenNo S) (_ : x0 <= y)	                            (z : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 x0 < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          => z.1 <= w.1)	                         (fun (x0 y : GenNo S) (_ : x0 < y)	                            (z : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 x0 < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          => z.1 < w.1)	                         (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                            (yL0 : L'0 -> GenNo S) 	                            (yR0 : R'0 -> GenNo S)	                            (ycut0 : forall (l : L'0) 	                                     (r0 : R'0), yL0 l < yR0 r0)	                            (x_plus_yL : forall l : L'0,	                                         {x_plus_y : No &	                                         (forall l0 : L,	                                          (xL_plus l0).1 (yL0 l) < x_plus_y) *	                                         (forall r0 : R,	                                          x_plus_y < (xR_plus r0).1 (yL0 l))})	                            (x_plus_yR : forall r0 : R'0,	                                         {x_plus_y : No &	                                         (forall l : L,	                                          (xL_plus l).1 (yR0 r0) < x_plus_y) *	                                         (forall r1 : R,	                                          x_plus_y < (xR_plus r1).1 (yR0 r0))})	                            (x_plus_yL_lt_yR : forall 	                                               (l : L'0) 	                                               (r0 : R'0),	                                               (x_plus_yL l).1 <	                                               (x_plus_yR r0).1) =>	                          let L'' := L + L'0 in	                          let R'' := R + R'0 in	                          let zL :=	                            sum_ind (fun _ : L + L'0 => No)	                              (fun l : L =>	                               (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                              (fun l : L'0 => (x_plus_yL l).1) in	                          let zR :=	                            sum_ind (fun _ : R + R'0 => No)	                              (fun r0 : R =>	                               (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                              (fun r0 : R'0 => (x_plus_yR r0).1) in	                          let zcut :=	                            plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                              x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                          let X := sum_options L R L'0 R'0 Sx s in	                          ({{ zL | zR // zcut }};	                          (fun l : L => lt_lopt zL zR zcut (inl l),	                          fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                         plus_inner_subproof0 plus_inner_subproof1	                         plus_inner_subproof2 plus_inner_subproof3	                         (game_of (yR r)) (isno_game_of (yR r))).1) x));	  isno_game_of := isno (L + L') (R + R') (sum_options L R L' R' Sx Sy)	                    (fun x : L + L' =>	                     game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L =>	                           (xL_plus l).1	                             {{ fun l0 : L' =>	                                {|	                                game_of := game_of (yL l0);	                                isno_game_of := isno_game_of (yL l0) |} | 	                             (fun r : R' =>	                              {|	                              game_of := game_of (yR r);	                              isno_game_of := isno_game_of (yR r) |}) // ycut }})	                          (fun l : L' =>	                           (No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                               (forall r : R, x_plus_y < (xR_plus r).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l0 : L'0) 	                                          (r : R'0), 	                                          yL0 l0 < yR0 r)	                                 (x_plus_yL : forall 	                                              l0 : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l1 : L,	                                               (xL_plus l1).1 (yL0 l0) <	                                               x_plus_y) *	                                              (forall 	                                               r : R,	                                               x_plus_y <	                                               (xR_plus r).1 (yL0 l0))})	                                 (x_plus_yR : forall 	                                              r : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yR0 r) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yR0 r))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l0 : L'0) 	                                  (r : R'0),	                                  (x_plus_yL l0).1 < (x_plus_yR r).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l0 : L =>	                                    (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l0 : L'0 => (x_plus_yL l0).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r : R =>	                                    (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r : R'0 => (x_plus_yR r).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                               fun r : R => lt_ropt zL zR zcut (inl r))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yL l)) (isno_game_of (yL l))).1) x))	                    (fun x : R + R' =>	                     game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R =>	                           (xR_plus r).1	                             {{ fun l : L' =>	                                {|	                                game_of := game_of (yL l);	                                isno_game_of := isno_game_of (yL l) |} | 	                             (fun r0 : R' =>	                              {|	                              game_of := game_of (yR r0);	                              isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                          (fun r : R' =>	                           (No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l : L, (xL_plus l).1 y < x_plus_y) *	                               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l : L'0) 	                                          (r0 : R'0), 	                                          yL0 l < yR0 r0)	                                 (x_plus_yL : forall 	                                              l : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yL0 l) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yL0 l))})	                                 (x_plus_yR : forall 	                                              r0 : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l : L,	                                               (xL_plus l).1 (yR0 r0) <	                                               x_plus_y) *	                                              (forall 	                                               r1 : R,	                                               x_plus_y <	                                               (xR_plus r1).1 (yR0 r0))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l : L'0) 	                                  (r0 : R'0),	                                  (x_plus_yL l).1 < (x_plus_yR r0).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l : L =>	                                    (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l : L'0 => (x_plus_yL l).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r0 : R =>	                                    (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r0 : R'0 => (x_plus_yR r0).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l : L => lt_lopt zL zR zcut (inl l),	                               fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yR r)) (isno_game_of (yR r))).1) x))	                    (fun x : L + L' =>	                     isno_game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L =>	                           (xL_plus l).1	                             {{ fun l0 : L' =>	                                {|	                                game_of := game_of (yL l0);	                                isno_game_of := isno_game_of (yL l0) |} | 	                             (fun r : R' =>	                              {|	                              game_of := game_of (yR r);	                              isno_game_of := isno_game_of (yR r) |}) // ycut }})	                          (fun l : L' =>	                           (No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                               (forall r : R, x_plus_y < (xR_plus r).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l0 : L'0) 	                                          (r : R'0), 	                                          yL0 l0 < yR0 r)	                                 (x_plus_yL : forall 	                                              l0 : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l1 : L,	                                               (xL_plus l1).1 (yL0 l0) <	                                               x_plus_y) *	                                              (forall 	                                               r : R,	                                               x_plus_y <	                                               (xR_plus r).1 (yL0 l0))})	                                 (x_plus_yR : forall 	                                              r : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yR0 r) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yR0 r))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l0 : L'0) 	                                  (r : R'0),	                                  (x_plus_yL l0).1 < (x_plus_yR r).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l0 : L =>	                                    (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l0 : L'0 => (x_plus_yL l0).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r : R =>	                                    (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r : R'0 => (x_plus_yR r).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                               fun r : R => lt_ropt zL zR zcut (inl r))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yL l)) (isno_game_of (yL l))).1) x))	                    (fun x : R + R' =>	                     isno_game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R =>	                           (xR_plus r).1	                             {{ fun l : L' =>	                                {|	                                game_of := game_of (yL l);	                                isno_game_of := isno_game_of (yL l) |} | 	                             (fun r0 : R' =>	                              {|	                              game_of := game_of (yR r0);	                              isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                          (fun r : R' =>	                           (No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l : L, (xL_plus l).1 y < x_plus_y) *	                               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l : L'0) 	                                          (r0 : R'0), 	                                          yL0 l < yR0 r0)	                                 (x_plus_yL : forall 	                                              l : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yL0 l) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yL0 l))})	                                 (x_plus_yR : forall 	                                              r0 : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l : L,	                                               (xL_plus l).1 (yR0 r0) <	                                               x_plus_y) *	                                              (forall 	                                               r1 : R,	                                               x_plus_y <	                                               (xR_plus r1).1 (yR0 r0))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l : L'0) 	                                  (r0 : R'0),	                                  (x_plus_yL l).1 < (x_plus_yR r0).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l : L =>	                                    (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l : L'0 => (x_plus_yL l).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r0 : R =>	                                    (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r0 : R'0 => (x_plus_yR r0).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l : L => lt_lopt zL zR zcut (inl l),	                               fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yR r)) (isno_game_of (yR r))).1) x))	                    (plus_inner_subproof L' R' Sy	                       (fun l : L' =>	                        {|	                        game_of := game_of (yL l);	                        isno_game_of := isno_game_of (yL l) |})	                       (fun r : R' =>	                        {|	                        game_of := game_of (yR r);	                        isno_game_of := isno_game_of (yR r) |}) ycut	                       (fun l : L' =>	                        No_ind_internal	                          (fun y : GenNo S =>	                           {x_plus_y : No &	                           (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                           (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          (fun (x y : GenNo S) (_ : x <= y)	                             (z : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 x < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 y)})	                           => z.1 <= w.1)	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 x < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 y)})	                           => z.1 < w.1)	                          (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                             (yL0 : L'0 -> GenNo S) 	                             (yR0 : R'0 -> GenNo S)	                             (ycut0 : forall (l0 : L'0) 	                                      (r : R'0), yL0 l0 < yR0 r)	                             (x_plus_yL : forall l0 : L'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l1 : L,	                                           (xL_plus l1).1 (yL0 l0) < x_plus_y) *	                                          (forall 	                                           r : R,	                                           x_plus_y < (xR_plus r).1 (yL0 l0))})	                             (x_plus_yR : forall r : R'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l0 : L,	                                           (xL_plus l0).1 (yR0 r) < x_plus_y) *	                                          (forall 	                                           r0 : R,	                                           x_plus_y < (xR_plus r0).1 (yR0 r))})	                             (x_plus_yL_lt_yR : forall 	                                                (l0 : L'0) 	                                                (r : R'0),	                                                (x_plus_yL l0).1 <	                                                (x_plus_yR r).1) =>	                           let L'' := L + L'0 in	                           let R'' := R + R'0 in	                           let zL :=	                             sum_ind (fun _ : L + L'0 => No)	                               (fun l0 : L =>	                                (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                               (fun l0 : L'0 => (x_plus_yL l0).1) in	                           let zR :=	                             sum_ind (fun _ : R + R'0 => No)	                               (fun r : R =>	                                (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                               (fun r : R'0 => (x_plus_yR r).1) in	                           let zcut :=	                             plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                               x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                           let X := sum_options L R L'0 R'0 Sx s in	                           ({{ zL | zR // zcut }};	                           (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                           fun r : R => lt_ropt zL zR zcut (inl r))))	                          plus_inner_subproof0 plus_inner_subproof1	                          plus_inner_subproof2 plus_inner_subproof3	                          (game_of (yL l)) (isno_game_of (yL l)))	                       (fun r : R' =>	                        No_ind_internal	                          (fun y : GenNo S =>	                           {x_plus_y : No &	                           (forall l : L, (xL_plus l).1 y < x_plus_y) *	                           (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          (fun (x y : GenNo S) (_ : x <= y)	                             (z : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 x < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                           => z.1 <= w.1)	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 x < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                           => z.1 < w.1)	                          (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                             (yL0 : L'0 -> GenNo S) 	                             (yR0 : R'0 -> GenNo S)	                             (ycut0 : forall (l : L'0) 	                                      (r0 : R'0), 	                                      yL0 l < yR0 r0)	                             (x_plus_yL : forall l : L'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l0 : L,	                                           (xL_plus l0).1 (yL0 l) < x_plus_y) *	                                          (forall 	                                           r0 : R,	                                           x_plus_y < (xR_plus r0).1 (yL0 l))})	                             (x_plus_yR : forall r0 : R'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l : L,	                                           (xL_plus l).1 (yR0 r0) < x_plus_y) *	                                          (forall 	                                           r1 : R,	                                           x_plus_y < (xR_plus r1).1 (yR0 r0))})	                             (x_plus_yL_lt_yR : forall 	                                                (l : L'0) 	                                                (r0 : R'0),	                                                (x_plus_yL l).1 <	                                                (x_plus_yR r0).1) =>	                           let L'' := L + L'0 in	                           let R'' := R + R'0 in	                           let zL :=	                             sum_ind (fun _ : L + L'0 => No)	                               (fun l : L =>	                                (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                               (fun l : L'0 => (x_plus_yL l).1) in	                           let zR :=	                             sum_ind (fun _ : R + R'0 => No)	                               (fun r0 : R =>	                                (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                               (fun r0 : R'0 => (x_plus_yR r0).1) in	                           let zcut :=	                             plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                               x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                           let X := sum_options L R L'0 R'0 Sx s in	                           ({{ zL | zR // zcut }};	                           (fun l : L => lt_lopt zL zR zcut (inl l),	                           fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                          plus_inner_subproof0 plus_inner_subproof1	                          plus_inner_subproof2 plus_inner_subproof3	                          (game_of (yR r)) (isno_game_of (yR r)))	                       (fun (l : L') (r : R') =>	                        match	                          No_Empty_admitted	                          return	                            ((No_ind_internal	                                (fun y : GenNo S =>	                                 {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 <= y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 <= w.1)	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 < y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 < w.1)	                                (fun (L'0 R'0 : Type) 	                                   (s : InSort S L'0 R'0)	                                   (yL0 : L'0 -> GenNo S)	                                   (yR0 : R'0 -> GenNo S)	                                   (ycut0 : forall 	                                            (l0 : L'0) 	                                            (r0 : R'0), 	                                            yL0 l0 < yR0 r0)	                                   (x_plus_yL : forall 	                                                l0 : L'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l1 : L,	                                                 (xL_plus l1).1 (yL0 l0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r0 : R,	                                                 x_plus_y <	                                                 (xR_plus r0).1 (yL0 l0))})	                                   (x_plus_yR : forall 	                                                r0 : R'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l0 : L,	                                                 (xL_plus l0).1 (yR0 r0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r1 : R,	                                                 x_plus_y <	                                                 (xR_plus r1).1 (yR0 r0))})	                                   (x_plus_yL_lt_yR : 	                                    forall (l0 : L'0) 	                                    (r0 : R'0),	                                    (x_plus_yL l0).1 < (x_plus_yR r0).1) =>	                                 let L'' := L + L'0 in	                                 let R'' := R + R'0 in	                                 let zL :=	                                   sum_ind (fun _ : L + L'0 => No)	                                     (fun l0 : L =>	                                      (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun l0 : L'0 => (x_plus_yL l0).1) in	                                 let zR :=	                                   sum_ind (fun _ : R + R'0 => No)	                                     (fun r0 : R =>	                                      (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun r0 : R'0 => (x_plus_yR r0).1) in	                                 let zcut :=	                                   plus_inner_subproof L'0 R'0 s yL0 yR0	                                     ycut0 x_plus_yL x_plus_yR	                                     x_plus_yL_lt_yR in	                                 let X := sum_options L R L'0 R'0 Sx s in	                                 ({{ zL | zR // zcut }};	                                 (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                                 fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                                plus_inner_subproof0 plus_inner_subproof1	                                plus_inner_subproof2 plus_inner_subproof3	                                (game_of (yL l)) (isno_game_of (yL l))).1 <	                             (No_ind_internal	                                (fun y : GenNo S =>	                                 {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 <= y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 <= w.1)	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 < y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 < w.1)	                                (fun (L'0 R'0 : Type) 	                                   (s : InSort S L'0 R'0)	                                   (yL0 : L'0 -> GenNo S)	                                   (yR0 : R'0 -> GenNo S)	                                   (ycut0 : forall 	                                            (l0 : L'0) 	                                            (r0 : R'0), 	                                            yL0 l0 < yR0 r0)	                                   (x_plus_yL : forall 	                                                l0 : L'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l1 : L,	                                                 (xL_plus l1).1 (yL0 l0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r0 : R,	                                                 x_plus_y <	                                                 (xR_plus r0).1 (yL0 l0))})	                                   (x_plus_yR : forall 	                                                r0 : R'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l0 : L,	                                                 (xL_plus l0).1 (yR0 r0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r1 : R,	                                                 x_plus_y <	                                                 (xR_plus r1).1 (yR0 r0))})	                                   (x_plus_yL_lt_yR : 	                                    forall (l0 : L'0) 	                                    (r0 : R'0),	                                    (x_plus_yL l0).1 < (x_plus_yR r0).1) =>	                                 let L'' := L + L'0 in	                                 let R'' := R + R'0 in	                                 let zL :=	                                   sum_ind (fun _ : L + L'0 => No)	                                     (fun l0 : L =>	                                      (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun l0 : L'0 => (x_plus_yL l0).1) in	                                 let zR :=	                                   sum_ind (fun _ : R + R'0 => No)	                                     (fun r0 : R =>	                                      (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun r0 : R'0 => (x_plus_yR r0).1) in	                                 let zcut :=	                                   plus_inner_subproof L'0 R'0 s yL0 yR0	                                     ycut0 x_plus_yL x_plus_yR	                                     x_plus_yL_lt_yR in	                                 let X := sum_options L R L'0 R'0 Sx s in	                                 ({{ zL | zR // zcut }};	                                 (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                                 fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                                plus_inner_subproof0 plus_inner_subproof1	                                plus_inner_subproof2 plus_inner_subproof3	                                (game_of (yR r)) (isno_game_of (yR r))).1)	                        with	                        end)) |} =	  {|	  game_of := opt (L + L') (R + R') (sum_options L R L' R' Sx Sy)	               (fun x : L + L' =>	                game_of	                  (sum_ind (fun _ : L + L' => No)	                     (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                     (fun l : L' => (plus_inner.1 (yL l)).1) x))	               (fun x : R + R' =>	                game_of	                  (sum_ind (fun _ : R + R' => No)	                     (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                     (fun r : R' => (plus_inner.1 (yR r)).1) x));	  isno_game_of := isno (L + L') (R + R') (sum_options L R L' R' Sx Sy)	                    (fun x : L + L' =>	                     game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                          (fun l : L' => (plus_inner.1 (yL l)).1) x))	                    (fun x : R + R' =>	                     game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                          (fun r : R' => (plus_inner.1 (yR r)).1) x))	                    (fun x : L + L' =>	                     isno_game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                          (fun l : L' => (plus_inner.1 (yL l)).1) x))	                    (fun x : R + R' =>	                     isno_game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                          (fun r : R' => (plus_inner.1 (yR r)).1) x)) 	                    ?zcut |}	";
            responses[i]=data;
          

            i = 83;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 84;
            data = "<infomsg>plus_inner_cut is defined</infomsg>	";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "1 subgoal (ID 54)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  {f	  : No ->	    {g : No -> No &	    (forall x y : GenNo S, x <= y -> g x <= g y) *	    (forall x y : GenNo S, x < y -> g x < g y)} &	  (forall x y : GenNo S, x <= y -> forall z : No, (f x).1 z <= (f y).1 z) *	  (forall x y : GenNo S, x < y -> forall z : No, (f x).1 z < (f y).1 z)}	";
            responses[i]=data;
          

            i = 87;
            data = "1 subgoal (ID 54)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  {f	  : No ->	    {g : No -> No &	    (forall x y : GenNo S, x <= y -> g x <= g y) *	    (forall x y : GenNo S, x < y -> g x < g y)} &	  (forall x y : GenNo S, x <= y -> forall z : No, (f x).1 z <= (f y).1 z) *	  (forall x y : GenNo S, x < y -> forall z : No, (f x).1 z < (f y).1 z)}	";
            responses[i]=data;
          

            i = 88;
            data = "4 subgoals (ID 343)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall	  a	   b : {g : No -> No &	       (forall x y : GenNo S, x <= y -> g x <= g y) *	       (forall x y : GenNo S, x < y -> g x < g y)},	  (forall x : No, a.1 x <= b.1 x) -> (forall x : No, b.1 x <= a.1 x) -> a = b		subgoal 2 (ID 344) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	 (forall l : L, xL l < {{ yL | yR // ycut }}) ->	 (forall (l : L) (x : No),	  (fxL l).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 (forall r : R', {{ xL | xR // xcut }} < yR r) ->	 (forall (r : R') (x : No),	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (fyR r).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 3 (ID 345) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 4 (ID 346) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 89;
            data = "1 subgoal (ID 343)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall	  a	   b : {g : No -> No &	       (forall x y : GenNo S, x <= y -> g x <= g y) *	       (forall x y : GenNo S, x < y -> g x < g y)},	  (forall x : No, a.1 x <= b.1 x) -> (forall x : No, b.1 x <= a.1 x) -> a = b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 344)		subgoal 1 (ID 344) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	 (forall l : L, xL l < {{ yL | yR // ycut }}) ->	 (forall (l : L) (x : No),	  (fxL l).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 (forall r : R', {{ xL | xR // xcut }} < yR r) ->	 (forall (r : R') (x : No),	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (fyR r).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 2 (ID 345) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 3 (ID 346) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "";
            responses[i]=data;
          

            i = 100;
            data = "";
            responses[i]=data;
          

            i = 101;
            data = "";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "1 subgoal (ID 344)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	  (forall l : L, xL l < {{ yL | yR // ycut }}) ->	  (forall (l : L) (x : No),	   (fxL l).1 x <	   (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	  (forall r : R', {{ xL | xR // xcut }} < yR r) ->	  (forall (r : R') (x : No),	   (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	   (fyR r).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 107;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 345)		subgoal 1 (ID 345) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 2 (ID 346) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	1 subgoal (ID 345)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S),	  (forall (l : L') (r : R'), yL l < yR r) ->	  forall	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	  (l : L'),	  {{ xL | xR // xcut }} <= yL l ->	  (forall x : No,	   (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	   (fyL l).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 108;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 346)		subgoal 1 (ID 346) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	1 subgoal (ID 346)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S),	  (forall (l : L) (r : R), xL l < xR r) ->	  forall	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	  (r : R),	  xR r <= {{ yL | yR // ycut }} ->	  (forall x : No,	   (fxR r).1 x <=	   (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 109;
            data = "No more subgoals.	<infomsg>plus_outer is defined</infomsg>	";
            responses[i]=data;
          

            i = 110;
            data = "<infomsg>plus is defined</infomsg>	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>plus_le_l is defined</infomsg>	";
            responses[i]=data;
          

            i = 113;
            data = "<infomsg>plus_lt_l is defined</infomsg>	";
            responses[i]=data;
          

            i = 114;
            data = "<infomsg>plus_le_r is defined</infomsg>	";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>plus_lt_r is defined</infomsg>	";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "<infomsg>plus_cut is defined</infomsg>	";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "";
            responses[i]=data;
          

            i = 134;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Spaces.No.Addition</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.No.Core.html#"><span class="id" title="library">HoTT.Spaces.No.Core</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab450"></a><h1 class="section">Addition of surreal numbers</h1>
<div class="doc" scenenumber="4"> </div>

 Addition requires the option sorts to be closed under finite sums. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      ">
<span class="id" title="keyword">Class</span> <a name="HasAddition"><span class="id" title="record">HasAddition</span></a> (<span class="id" title="var">S</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort</span></a>) := <br>
  { <a name="empty_options"><span class="id" title="projection">empty_options</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a><br>
    ; <a name="sum_options"><span class="id" title="projection">sum_options</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a><br>
        <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>)<br>
  }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">empty_options</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">sum_options</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_maxsort"><span class="id" title="instance">hasaddition_maxsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#MaxSort"><span class="id" title="definition">MaxSort</span></a><br>
  := { <a class="idref" href="HoTT.Spaces.No.Addition.html#empty_options"><span class="id" title="projection">empty_options</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ;<br>
       <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_ordsort"><span class="id" title="instance">hasaddition_ordsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#OrdSort"><span class="id" title="definition">OrdSort</span></a><br>
  := { <a class="idref" href="HoTT.Spaces.No.Addition.html#empty_options"><span class="id" title="projection">empty_options</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> ;<br>
       <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> ⇒ <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_decsort"><span class="id" title="instance">hasaddition_decsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#DecSort"><span class="id" title="definition">DecSort</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
  <span class="id" title="tactic">constructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#insort_decsort"><span class="id" title="instance">insort_decsort</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> [? ?] [? ?]; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="Addition"><span class="id" title="section">Addition</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">S</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort@</span></a>{<span class="id" title="var">i</span>}} `{<a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
  <span class="id" title="keyword">Let</span> <a name="Addition.No"><span class="id" title="variable">No</span></a> := <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.GenNo"><span class="id" title="record">GenNo</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Section</span> <a name="Addition.Inner"><span class="id" title="section">Inner</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Context</span> {<span class="id" title="var">L</span> <span class="id" title="var">R</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sx</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a>}<br>
            (<span class="id" title="var">xL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">xR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
            (<span class="id" title="var">xcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Let</span> <a name="Addition.Inner.A"><span class="id" title="variable">A</span></a> := <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
              <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
              <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Context</span> (<span class="id" title="var">xL_plus</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">xR_plus</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.A"><span class="id" title="variable">A</span></a>)<br>
            (<span class="id" title="var">xL_lt_xR_plus</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
                               <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Definition</span> <a name="plus_inner"><span class="id" title="definition">plus_inner</span></a><br>
    : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a><br>
              <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">x_plus_y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
        <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
        <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
    <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
      <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_ind_package"><span class="id" title="definition">No_ind_package</span></a><br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">x_plus_y</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
                            <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
                            <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>)<br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>)<br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a>)<br>
                <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(42, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">L''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <span class="id" title="var">L'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(43, '0_3_7');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">R''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <span class="id" title="var">R'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(44, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yL</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a>)<br>
                    : <span class="id" title="var">L''</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(45, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yR</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a>)<br>
                    : <span class="id" title="var">R''</span> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(46, '0_3_7');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">zcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<span class="id" title="var">L''</span>) (<span class="id" title="var">r</span>:<span class="id" title="var">R''</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(47, '0_3_7');
      "><br>
        { <span class="id" title="tactic">abstract</span> (<br>
          <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>]; <span class="id" title="var">cbn</span>;<br>
          [ <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_lt_xR_plus"><span class="id" title="variable">xL_lt_xR_plus</span></a><br>
          | <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> (<span class="id" title="var">yR</span> <span class="id" title="var">r</span>));<br>
            [ <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a>), <a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span><br>
            | <span class="id" title="tactic">exact</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yR</span> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <span class="id" title="var">l</span>) ]<br>
          | <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> (<span class="id" title="var">yL</span> <span class="id" title="var">l</span>));<br>
            [ <span class="id" title="tactic">exact</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yL</span> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <span class="id" title="var">r</span>)<br>
            | <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a>), <a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ]<br>
          | <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_yL_lt_yR</span> ]). }</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(48, '0_3_7');
      "><br>
        <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(49, '0_3_7');
      "><br>
        <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(50, '0_3_7');
      "><br>
        + <span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(51, '0_3_7');
      "><br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(52, '0_3_7');
      "><br>
        + <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(53, '0_3_7');
      "><br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(54, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> [<span class="id" title="var">a</span> ?] [<span class="id" title="var">b</span> ?] <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">r</span> <span class="id" title="var">s</span>;<br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>, <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>; <span class="id" title="tactic">assumption</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(55, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">yL_lt_z</span> <span class="id" title="var">x_plus_yL_lt_z</span> <span class="id" title="var">y_lt_zR</span> <span class="id" title="var">x_plus_y_lt_zR</span>;<br>
        <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] | <span class="id" title="tactic">intros</span> [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>] ]; <span class="id" title="var">cbn</span>;<br>
        [ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span><a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>);<br>
          [ <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">assumption</span>)<br>
          | <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)) ]<br>
        | <span class="id" title="tactic">exact</span> (<span class="id" title="var">x_plus_yL_lt_z</span> <span class="id" title="var">l</span>)<br>
        | <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span><br>
                    (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span><a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>));<br>
          [ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>))<br>
          | <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">assumption</span>) ]<br>
        | <span class="id" title="tactic">exact</span> (<span class="id" title="var">x_plus_y_lt_zR</span> <span class="id" title="var">r</span>) ] ).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(56, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">l</span> <span class="id" title="var">y_le_zL</span> <span class="id" title="var">x_plus_y_le_zL</span>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_l"><span class="id" title="definition">lt_l</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">l</span>);<br>
        <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_y_le_zL</span> ).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(57, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">r</span> <span class="id" title="var">yR_le_z</span> <span class="id" title="var">x_plus_yR_le_z</span>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">r</span>);<br>
        <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_yR_le_z</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(58, '0_3_7');
      "><br>
    <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(59, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
We now prove a computation law for <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a></span>.  It holds definitionally, so we would like to prove it with just <span class="inlinecode">:=</span> <span class="inlinecode">1</span> and then rewrite along it later, as we did above.  However, there is a subtlety in that the output should be a surreal defined by a cut, which in particular includes a proof of cut-ness, and that proof is rather long, so we would not like to see it in the type of this lemma.  Thus, instead we assert only that there *exists* some proof of cut-ness and an equality. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(69, '0_3_11');
      ">
    <span class="id" title="keyword">Definition</span> <a name="plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a><br>
               {<span class="id" title="var">L'</span> <span class="id" title="var">R'</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sy</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>}<br>
               (<span class="id" title="var">yL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">yR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
               (<span class="id" title="var">ycut</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
    : <span class="id" title="keyword">let</span> <span class="id" title="var">L''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">R''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a>)<br>
                : <a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a>)<br>
                : <a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">Sz</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <br>
      <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a>) (<span class="id" title="var">r</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
        <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a>@<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_cut"><span class="id" title="definition">No_cut</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Sz"><span class="id" title="variable">Sz</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zcut"><span class="id" title="variable">zcut</span></a><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(70, '0_3_11');
      "><br>
    <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(71, '0_3_11');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
Now we tell Coq that we want the equality to be definitional, and let it figure out what the proof of cut-ness has to be. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(75, '0_3_15');
      ">
      <span class="id" title="tactic">eexists</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(76, '0_3_15');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Adding <span class="inlinecode"><span class="id" title="var">rel_hnf</span></span> here speeds things up considerably, possibly because it puts the terms in a form where the evar can be instantiated without unfolding or reduction, preventing backtracking across the evar instantiation. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(82, '0_3_19');
      ">
      <span class="id" title="var">rel_hnf</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(83, '0_3_19');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(84, '0_3_19');
      "><br>
    <span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(85, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner"><span class="id" title="section">Inner</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(86, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_outer"><span class="id" title="definition">plus_outer</span></a><br>
  : <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">f</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
                  <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
                  <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
      <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
      <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(87, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(88, '0_3_19');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_rec_package"><span class="id" title="definition">No_rec_package</span></a><br>
              <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>)<br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>)<br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">Sx</span> <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span> ⇒<br>
                 <span class="id" title="keyword">let</span> <span class="id" title="var">g</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL_lt_xR_plus"><span class="id" title="variable">xL_lt_xR_plus</span></a> <span class="id" title="tactic">in</span><br>
                 <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">((</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a>)<br>
               <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(89, '0_3_19');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">g</span> ?] [<span class="id" title="var">h</span> ?] <span class="id" title="var">p</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; [ <span class="id" title="tactic">apply</span> <span class="id" title="var">p</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">q</span> ] ).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(90, '0_3_19');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
           <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">xL_lt_y</span> <span class="id" title="var">xL_lt_y_plus</span> <span class="id" title="var">x_lt_yR</span> <span class="id" title="var">x_lt_yR_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] | <span class="id" title="tactic">intros</span> [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>] ];<br>
      [ </span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
x^L + z &lt; y + z 
</div>
<div scenenumber="23" class="code"><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(94, '0_3_23');
      ">
        <span class="id" title="tactic">specialize</span> (<span class="id" title="var">xL_lt_y_plus</span> <span class="id" title="var">l</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>);<br>
        <span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span> <span class="id" title="tactic">in</span> <span class="id" title="var">xL_lt_y_plus</span>;<br>
        <span class="id" title="tactic">exact</span> <span class="id" title="var">xL_lt_y_plus</span><br>
      | </span></div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
x + z^L &lt; y + z 
</div>
<div scenenumber="27" class="code"><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      ">
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">l</span>) <span class="id" title="var">_</span>);<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">l</span>))<br>
      | </span></div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
x + z &lt; y^R + z 
</div>
<div scenenumber="31" class="code"><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(102, '0_3_31');
      ">
        <span class="id" title="tactic">specialize</span> (<span class="id" title="var">x_lt_yR_plus</span> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>);<br>
        <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span> <span class="id" title="tactic">in</span> <span class="id" title="var">x_lt_yR_plus</span>;<br>
        <span class="id" title="tactic">exact</span> <span class="id" title="var">x_lt_yR_plus</span><br>
      | </span></div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
x + z &lt; y + z^R 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(106, '0_3_35');
      ">
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">x_le_y_plus_zR</span> <span class="id" title="var">r</span>));<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">r</span>)) ]).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(107, '0_3_35');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
             <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">x_le_yL</span> <span class="id" title="var">x_le_yL_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<span class="id" title="var">x_le_yL_plus</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>) <span class="id" title="var">_</span>);<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)) ).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(108, '0_3_35');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
             <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">xR_le_y</span> <span class="id" title="var">xR_le_y_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">xR_le_y_plus</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a>));<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>)) ).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus"><span class="id" title="definition">plus</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><br>
    := <a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Infix</span> <a name="ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">"</span></a>+" := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus"><span class="id" title="definition">plus</span></a> : <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_le_l"><span class="id" title="definition">plus_le_l</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">x'</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a>) <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_lt_l"><span class="id" title="definition">plus_lt_l</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">x'</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a>) <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_le_r"><span class="id" title="definition">plus_le_r</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#6eb80bf0eb5ea89029633d789a8256e9"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_lt_r"><span class="id" title="definition">plus_lt_r</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
See the remarks above <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a></span> to explain the type of this lemma. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(122, '0_3_39');
      ">
  <span class="id" title="keyword">Definition</span> <a name="plus_cut"><span class="id" title="definition">plus_cut</span></a><br>
             {<span class="id" title="var">L</span> <span class="id" title="var">R</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sx</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a>}<br>
             (<span class="id" title="var">xL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">xR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
             (<span class="id" title="var">xcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
             {<span class="id" title="var">L'</span> <span class="id" title="var">R'</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sy</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>}<br>
             (<span class="id" title="var">yL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">yR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
             (<span class="id" title="var">ycut</span> : <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
  : <span class="id" title="keyword">let</span> <span class="id" title="var">L''</span> := (<a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>)%<span class="id" title="keyword">type</span> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">R''</span> := (<a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#3dcaec3b772747610227247939f96b01"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>)%<span class="id" title="keyword">type</span> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xcut"><span class="id" title="variable">xcut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">y</span> := <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#bb28bf676ab5ced8b95e9c9874b6bff4"><span class="id" title="notation">}}</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                      (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">)</span></a>)<br>
              : <a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                      (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">)</span></a>)<br>
              : <a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">Sz</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <br>
    <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a>) (<span class="id" title="var">r</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a><a class="idref" href="HoTT.Basics.Notations.html#d2ec56b4b399745cfaad1420e500e21b"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#35b878b20de125dbc1ccb1a189ba099d"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a><br>
      <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ab8f32b49c4ef49a800c2b89de555f7c"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_cut"><span class="id" title="definition">No_cut</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Sz"><span class="id" title="variable">Sz</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zcut"><span class="id" title="variable">zcut</span></a> <a class="idref" href="Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><br>
    := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> (<span class="id" title="var">Sx</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Sx"><span class="id" title="variable">Sx</span></a>)<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>))<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>))<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#xcut"><span class="id" title="variable">xcut</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>))<br>
         <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(123, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition"><span class="id" title="section">Addition</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(124, '0_3_39');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
