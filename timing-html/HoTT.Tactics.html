<html>
<head>
<title>Tactics.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Tactics.v</h1>

<div class="code" title="File: Tactics.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*-  *)

</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 2
Time: 0.028s">
<div class="time" style="width: 28%"></div>
<pre>Require Import Overture types.Prod types.Forall PathGroupoids Contractible types.Paths.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 2
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Extra tactics for homotopy type theory. *)

(** ** Tactics for dealing with [Funext] *)
(** *** Tactics about [transport]ing with [path_forall] *)

(** Given using the variable names from [transport : forall {A : Type} (P : A -&gt; Type) {x y : A}, x = y -&gt; P x -&gt; P y] and [path_forall : {Funext} -&gt; forall {A B} (f g : forall x : A, B x), (forall x : A, f x = g x) -&gt; f = g]:

The high-level idea is that we don't really need functional extensionality if we end up just applying the functions to arguments anyway.  That is, if we have that [forall x, f x = g x], and we only talk about [f y] and [f z], then we don't actually need to transport across [f = g], just [f y = g y] and [f z = g z].

In a bit more detail, if we are transporting across [path_forall f g H], and in the function [P], all instances of [f] are applied to some expressions, say we only see [f x], [f y], ..., [f z], then we can eliminate the [path_forall] by explicitly transporting across [H x], [H y], ..., [H z].  The lemma [path_forall_1_beta] expresses this fact in the case that we see [f] applied to only a single argument in [P], and the tactic [transport_path_forall_hammer] is some fancy Ltac to auto-infer what [P] is and what the argument to [f] is.

The way the tactic does this is by creating an evar for [P] and an evar for the argument to [f], and then using a combination of [assert], [pattern], etc to figure out what each should be.  If you want to see how it works, you can step through each step of [transport_path_forall_hammer] when trying to prove [path_forall_2_beta]. *)

(** First, we prove some helpful lemmas about [path_forall] and [transport] *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Ltac path_forall_beta_t :=
  lazymatch goal with
    | [ |- appcontext[@path_forall ?H ?A ?B ?f ?g ?e] ]
      =&gt; let X := fresh in
         pose proof (eissect (@path_forall H A B f g) e) as X;
           case X;
           generalize (@path_forall H A B f g e);
           clear X; clear e;
           intro X; destruct X;
           simpl;
           unfold apD10;
           rewrite !(path_forall_1 f)
  end;
  reflexivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 32
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The basic idea is expressed in the type of this lemma. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 34
Time: 0.006s">
<div class="time" style="width: 6%"></div>
<pre>Lemma path_forall_1_beta `{Funext} A B x P f g e Px
: @transport (forall a : A, B a) (fun f =&gt; P (f x)) f g (@path_forall _ _ _ _ _ e) Px
  = @transport (B x) P (f x) (g x) (e x) Px.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 37
Time: 0.048s">
<div class="time" style="width: 48%"></div>
<pre>
  path_forall_beta_t.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 38
Time: 0.011s">
<div class="time" style="width: 11%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The powerful recursive case *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 41
Time: 0.014s">
<div class="time" style="width: 14%"></div>
<pre>Lemma path_forall_recr_beta' `{Funext} A B x0 P f g e Px
: @transport (forall a : A, B a)
             (fun f =&gt; P f (f x0))
             f
             g
             (@path_forall _ _ _ _ _ e)
             Px
  = @transport ((forall a, B a) * B x0)%type
               (fun x =&gt; P (fst x) (snd x))
               (f, f x0)
               (g, g x0)
               (path_prod' (@path_forall _ _ _ _ _ e) (e x0))
               Px.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 54
Time: 0.1s">
<div class="time" style="width: 100%"></div>
<pre>
  path_forall_beta_t.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 55
Time: 0.022s">
<div class="time" style="width: 22%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 56
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Two lemmas about [transport]ing across [path_prod'], used for cleanup *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 58
Time: 0.008s">
<div class="time" style="width: 8%"></div>
<pre>Definition transport_path_prod'_beta A B P (x x' : A) (y y' : B) (HA : x = x') (HB : y = y') (Px : P (x, y))
: @transport (A * B) P (x, y) (x', y') (@path_prod' A B x x' y y' HA HB) Px
  = @transport A (fun x =&gt; P (x, y')) x x' HA
               (@transport B (fun y =&gt; P (x, y)) y y' HB Px).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 62
Time: 0.013s">
<div class="time" style="width: 13%"></div>
<pre>
  path_induction.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 63
Time: 0.003s">
<div class="time" style="width: 3%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 64
Time: 0.007s">
<div class="time" style="width: 7%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 65
Time: 0.008s">
<div class="time" style="width: 8%"></div>
<pre>

Definition transport_path_prod'_beta' A B P (x x' : A) (y y' : B) (HA : x = x') (HB : y = y') (Px : P x y)
: @transport (A * B) (fun xy =&gt; P (fst xy) (snd xy)) (x, y) (x', y') (@path_prod' A B x x' y y' HA HB) Px
  = @transport A (fun x =&gt; P x y') x x' HA
               (@transport B (fun y =&gt; P x y) y y' HB Px).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 70
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 71
Time: 0.016s">
<div class="time" style="width: 16%"></div>
<pre>
  path_induction.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 72
Time: 0.003s">
<div class="time" style="width: 3%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 73
Time: 0.008s">
<div class="time" style="width: 8%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 74
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Rewrite the recursive case after clean-up *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 76
Time: 0.01s">
<div class="time" style="width: 10%"></div>
<pre>Lemma path_forall_recr_beta `{Funext} A B x0 P f g e Px
: @transport (forall a : A, B a)
             (fun f =&gt; P f (f x0))
             f
             g
             (@path_forall _ _ _ _ _ e)
             Px
  = @transport (forall x : A, B x)
               (fun x =&gt; P x (g x0))
               f
               g
               (@path_forall H A B f g e)
               (@transport (B x0)
                           (fun y =&gt; P f y)
                           (f x0)
                           (g x0)
                           (e x0)
                           Px).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 94
Time: 0.008s">
<div class="time" style="width: 8%"></div>
<pre>
  etransitivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 96
Time: 0.004s">
<div class="time" style="width: 4%"></div>
<pre> apply path_forall_recr_beta'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 97
Time: 0.004s">
<div class="time" style="width: 4%"></div>
<pre> apply transport_path_prod'_beta'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 97
Time: 0.006s">
<div class="time" style="width: 6%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** The sledge-hammer for computing with [transport]ing across a [path_forall].  Note that it uses [rewrite], and so should only be used in opaque proofs. *)

(** We separate the inference part and the rewrite part to avoid 'Anomaly: Uncaught exception Invalid_argument("to_constraints: non-trivial algebraic constraint between universes", _).
Please report.' on rewrite *)

</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 105
Time: 0.001s">
<div class="time" style="width: 1%"></div>
<pre>Ltac transport_path_forall_hammer_helper :=
  (* pull out the parts of the goal to use [path_forall_recr_beta] *)
  let F := match goal with |- appcontext[@transport _ (fun x0 =&gt; @?F x0) _ _ (@path_forall ?H ?X ?T ?f ?g ?e)] =&gt; constr:(F) end in
  let H := match goal with |- appcontext[@transport _ (fun x0 =&gt; @?F x0) _ _ (@path_forall ?H ?X ?T ?f ?g ?e)] =&gt; constr:(H) end in
  let X := match goal with |- appcontext[@transport _ (fun x0 =&gt; @?F x0) _ _ (@path_forall ?H ?X ?T ?f ?g ?e)] =&gt; constr:(X) end in
  let T := match goal with |- appcontext[@transport _ (fun x0 =&gt; @?F x0) _ _ (@path_forall ?H ?X ?T ?f ?g ?e)] =&gt; constr:(T) end in
  let t0 := fresh "t0" in
  let t1 := fresh "t1" in
  let T1 := lazymatch type of F with (?T -&gt; _) -&gt; _ =&gt; constr:(T) end in
      evar (t1 : T1);
    let T0 := lazymatch type of F with (forall a : ?A, @?B a) -&gt; ?C =&gt; constr:((forall a : A, B a) -&gt; B t1 -&gt; C) end in
        evar (t0 : T0);
      (* make a dummy goal to figure out the functional form of [P] in [@transport _ P] *)
      let dummy := fresh in
      assert (dummy : forall x0, F x0 = t0 x0 (x0 t1));
        [ let x0 := fresh in
          intro x0;
            simpl in *;
            let GL0 := lazymatch goal with |- ?GL0 = _ =&gt; constr:(GL0) end in
                let GL0' := fresh in
                let GL1' := fresh in
                set (GL0' := GL0);
                  (* find [x0] applied to some argument, and note the argument *)
                  let arg := match GL0 with appcontext[x0 ?arg] =&gt; constr:(arg) end in
                  assert (t1 = arg) by (subst t1; reflexivity); subst t1;
                  pattern (x0 arg) in GL0';
                  match goal with
                    | [ GL0'' := ?GR _ |- _ ] =&gt; constr_eq GL0' GL0'';
                                                pose GR as GL1'
                  end;
                  (* remove the other instances of [x0], and figure out the shape *)
                  pattern x0 in GL1';
                  match goal with
                    | [ GL1'' := ?GR _ |- _ ] =&gt; constr_eq GL1' GL1'';
                                                assert (t0 = GR)
                  end;
                  subst t0; [ reflexivity | reflexivity ]
              | clear dummy ];
        let p := fresh in
        pose (@path_forall_recr_beta H X T t1 t0) as p;
          simpl in *;
          rewrite p;
          subst t0 t1 p.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac transport_path_forall_hammer :=
  progress
    repeat (
      transport_path_forall_hammer_helper;
      cbv beta;
      rewrite ?transport_const
    ).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 155
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** An example showing that it works *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 157
Time: 0.013s">
<div class="time" style="width: 13%"></div>
<pre>Lemma path_forall_2_beta' `{Funext} A B x0 x1 P f g e Px
: @transport (forall a : A, B a) (fun f =&gt; P (f x0) (f x1)) f g (@path_forall _ _ _ _ _ e) Px
  = @transport (B x0 * B x1)%type (fun x =&gt; P (fst x) (snd x)) (f x0, f x1) (g x0, g x1) (path_prod' (e x0) (e x1)) Px.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 159
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 160
Time: 0.089s">
<div class="time" style="width: 89%"></div>
<pre>
  transport_path_forall_hammer.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 161
Time: 0.033s">
<div class="time" style="width: 33%"></div>
<pre>
  repeat match goal with
           | [ |- appcontext[e ?x] ] =&gt; induction (e x)
         end;
    simpl.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 166
Time: 0.034s">
<div class="time" style="width: 34%"></div>
<pre>
Qed.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 167
Time: 0.008s">
<div class="time" style="width: 8%"></div>
<pre>

Lemma path_forall_2_beta `{Funext} A B x0 x1 P f g e Px
: @transport (forall a : A, B a) (fun f =&gt; P (f x0) (f x1)) f g (@path_forall _ _ _ _ _ e) Px
  = transport (fun y : B x1 =&gt; P (g x0) y) (e x1)
     (transport (fun y : B x0 =&gt; P y (f x1)) (e x0) Px).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 173
Time: 0.063s">
<div class="time" style="width: 63%"></div>
<pre>
  transport_path_forall_hammer.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 174
Time: 0.002s">
<div class="time" style="width: 2%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 175
Time: 0.022s">
<div class="time" style="width: 22%"></div>
<pre>
Qed.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 176
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** A more powerful variant of [path_induction] *)
(** We first define some helper tactics, and then define [path_induction_hammer], which has poor computational behavior, but is vastly more powerful than [path_induction], and removes paths which are discoverably contractible, and paths which only appear in the goal, etc. *)

(** A variant of [induction] which also tries [destruct] and [case], and may be extended to using other [destruct]-like tactics. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac induction_hammer H :=
  destruct H || induction H || (case H; clear H).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Takes a term of type [_ = _], and tries to replace it by [idpath] by trying to prove that it's an hProp.  The ordering of attempts is tuned for speed. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac clear_contr_path p :=
  let H := fresh in
  let T := type of p in
  progress (
      first [ assert (H : idpath = p) by exact (center _)
            | assert (H : idpath = p)
              by (
                  let a := match goal with |- @paths (?x = ?y) ?a ?b =&gt; constr:(a) end in
                  let b := match goal with |- @paths (?x = ?y) ?a ?b =&gt; constr:(b) end in
                  let x := match goal with |- @paths (?x = ?y) ?a ?b =&gt; constr:(x) end in
                  let y := match goal with |- @paths (?x = ?y) ?a ?b =&gt; constr:(y) end in
                  apply (@equiv_inv _ _ _ (@equiv_ap _ _ _ (@isequiv_apD10 _ _ _ x y) a b));
                  exact (center _)
                )
            | pose proof (@path_contr T _ idpath p) as H ];
      destruct H;
      (* now reduce any matches on [idpath] (and on other things too) *)
      cbv iota in *
    ).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 202
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Use both [induction_hammer] and [clear_contr_path] on a path, to try to get rid of it *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 204
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac clear_path_no_check p :=
  induction_hammer p || clear_contr_path p.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 205
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac clear_path p :=
  let t := type of p in
  lazymatch eval hnf in t with
    | @paths _ _ _ =&gt; clear_path_no_check p
    | _ =&gt; fail 0 "clear_path only works on paths;" p "is not a path"
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Run [clear_path] on hypotheses *)
(** We don't match only on things of type [_ = _], because maybe that's the head normal form, but it's hiding behind something else; [clear_path] will make sure it's of the right type.  We include some redundant cases at the top, for speed; it is faster to try to destruct everything first, and then do the full battery of tactics, than to just run the hammer. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 214
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac step_clear_paths :=
  match goal with
    | [ p : _ = _ |- _ ] =&gt; destruct p
    | [ p : _ = _ |- _ ] =&gt; clear_path_no_check p
    | [ p : _ |- _ ] =&gt; clear_path p
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 219
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac clear_paths := progress repeat step_clear_paths.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 220
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Run [clear_path] on anything inside a [match] *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 222
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac step_clear_paths_in_match :=
  match goal with
    | [ |- appcontext[match ?p with idpath =&gt; _ end] ] =&gt; progress destruct p
    | [ |- appcontext[match ?p with idpath =&gt; _ end] ] =&gt; clear_path_no_check p
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 226
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac clear_paths_in_match := progress repeat step_clear_paths_in_match.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 227
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Now some lemmas about trivial [match]es *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 229
Time: 0.016s">
<div class="time" style="width: 16%"></div>
<pre>Definition match_eta T (x y : T) (H0 : x = y)
: (H0 = match H0 in (_ = y) return (x = y) with
          | idpath =&gt; idpath
        end)
  := match H0 with idpath =&gt; idpath end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 233
Time: 0.003s">
<div class="time" style="width: 3%"></div>
<pre>

Definition match_eta1 T (x : T) (E : x = x)
: (match E in (_ = y) return (x = y) with
     | idpath =&gt; idpath
   end = idpath)
  -&gt; idpath = E
  := fun H =&gt; ((H # match_eta E) ^)%path.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 240
Time: 0.003s">
<div class="time" style="width: 3%"></div>
<pre>

Definition match_eta2 T (x : T) (E : x = x)
: (idpath
   = match E in (_ = y) return (x = y) with
       | idpath =&gt; idpath
     end)
  -&gt; idpath = E
  := fun H =&gt; match_eta1 E (H ^)%path.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 248
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** And now the actual tactic.  Note that the order of the cases in the [match goal with ... end] is somewhat finely tuned for speed. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 250
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac step_path_induction_hammer :=
  match goal with
    | _ =&gt; reflexivity
    | _ =&gt; intro
    | _ =&gt; progress simpl in *
    | _ =&gt; exact (contr _)
    | [ p : _ = _ |- _ ]
      =&gt; progress destruct p (* placed up here for speed *)
    | [ H : _ |- _ ]
      =&gt; let H' := fresh in assert (H' := match_eta1 _ H); destruct H'
    | [ H : _ |- _ ]
      =&gt; let H' := fresh in assert (H' := match_eta2 _ H); destruct H'
    | _ =&gt; step_clear_paths
    | _ =&gt; expand; step_clear_paths_in_match
    | _ =&gt; progress auto with path_hints
    | _ =&gt; done
    | _ =&gt; exact (center _)
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 267
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac path_induction_hammer := progress repeat step_path_induction_hammer.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 269
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Miscellaneous tactics *)

(** Substitute all hypotheses with bodies, i.e., of the form [H := _]. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 273
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac subst_body :=
  repeat match goal with
           | [ H := _ |- _ ] =&gt; subst H
         end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 276
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Some tactics to do things with some arbitrary hypothesis in the context.  These tactics are similar to, e.g., [assumption]. *)

</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 279
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac do_with_hyp tac :=
  match goal with
    | [ H : _ |- _ ] =&gt; tac H
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac rewrite_hyp' := do_with_hyp ltac:(fun H =&gt; rewrite H).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 284
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac rewrite_hyp := repeat rewrite_hyp'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 285
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac rewrite_rev_hyp' := do_with_hyp ltac:(fun H =&gt; rewrite &lt;- H).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac rewrite_rev_hyp := repeat rewrite_rev_hyp'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 287
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac apply_hyp' := do_with_hyp ltac:(fun H =&gt; apply H).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 289
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac apply_hyp := repeat apply_hyp'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 290
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac eapply_hyp' := do_with_hyp ltac:(fun H =&gt; eapply H).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 291
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac eapply_hyp := repeat eapply_hyp'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 292
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Run [simpl] on a hypothesis before rewriting with it. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 294
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac simpl_do_clear tac term :=
  let H := fresh in
  assert (H := term);
    simpl in H |- *;
    tac H;
    clear H.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 299
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite    H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 301
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 303
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite    H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 305
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 306
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 309
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 310
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 311
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 313
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 314
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 315
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite    H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 317
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 318
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 319
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


Tactic Notation "simpl" "rewrite"      "!" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite    !H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 322
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "!" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; !H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 323
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "!" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- !H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 324
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "!" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite    !H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 326
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "!" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; !H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 327
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "!" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- !H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 328
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "!" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    !H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 330
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "!" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; !H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 331
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "!" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- !H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 332
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "!" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    !H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 334
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "!" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; !H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 335
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "!" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- !H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 336
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "!" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite    !H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 338
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "!" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; !H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 339
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "!" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- !H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 340
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


Tactic Notation "simpl" "rewrite"      "?" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite    ?H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 343
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "?" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; ?H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 344
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "?" constr(term) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- ?H) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 345
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "?" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite    ?H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 347
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "?" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; ?H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 348
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "?" constr(term) "in" hyp(hyp) := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- ?H in hyp) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 349
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "?" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    ?H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 351
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "?" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; ?H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 352
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "?" constr(term) "in" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- ?H in * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 353
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "?" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite    ?H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 355
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "?" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; ?H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 356
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "?" constr(term) "in" hyp(hyp) "|-" "*" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- ?H in hyp |- * ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 357
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "simpl" "rewrite"      "?" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite    ?H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 359
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "-&gt;" "?" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite -&gt; ?H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 360
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "simpl" "rewrite" "&lt;-" "?" constr(term) "in" "*" "|-" := simpl_do_clear ltac:(fun H =&gt; rewrite &lt;- ?H in * |- ) term.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 361
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** find the head of the given expression *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 363
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac head expr :=
  match expr with
    | ?f _ =&gt; head f
    | _ =&gt; expr
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 367
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac head_hnf expr := let expr' := eval hnf in expr in head expr'.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 369
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* given a [matcher] that succeeds on some hypotheses and fails on
   others, destruct any matching hypotheses, and then execute [tac]
   after each [destruct].

   The [tac] part exists so that you can, e.g., [simpl in *], to
   speed things up. *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 376
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac destruct_all_matches_then matcher tac :=
  repeat match goal with
           | [ H : ?T |- _ ] =&gt; matcher T; destruct H; tac
         end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 379
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac destruct_all_matches matcher := destruct_all_matches_then matcher ltac:(simpl in *).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 381
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_all_matches' matcher := destruct_all_matches_then matcher idtac.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 382
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** matches anything whose type has a [T] in it *)</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 384
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac destruct_type_matcher T HT :=
  match HT with
    | context[T] =&gt; idtac
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 387
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_type T := destruct_all_matches ltac:(destruct_type_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 388
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_type' T := destruct_all_matches' ltac:(destruct_type_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 389
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac destruct_head_matcher T HT :=
  match head HT with
    | T =&gt; idtac
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 394
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_head T := destruct_all_matches ltac:(destruct_head_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 395
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_head' T := destruct_all_matches' ltac:(destruct_head_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 396
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac destruct_head_hnf_matcher T HT :=
  match head_hnf HT with
    | T =&gt; idtac
  end.</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 401
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_head_hnf T := destruct_all_matches ltac:(destruct_head_hnf_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 402
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Ltac destruct_head_hnf' T := destruct_all_matches' ltac:(destruct_head_hnf_matcher T).</pre>
</div>
<div class="code" title="File: Tactics.v
Line: 404
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

