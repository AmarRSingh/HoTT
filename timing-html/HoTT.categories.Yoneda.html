<html>
<head>
<title>Yoneda.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Yoneda.v</h1>

<div class="code" title="File: Yoneda.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(** * The Yoneda Lemma *)</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 1
Time: 0.008s">
<div class="time" style="width: 0.41753653444676%"></div>
<pre>Require Import Category.Core Functor.Core NaturalTransformation.Core.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 1
Time: 0.044s">
<div class="time" style="width: 2.2964509394572%"></div>
<pre>
Require Import Category.Dual.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 2
Time: 0.002s">
<div class="time" style="width: 0.10438413361169%"></div>
<pre>
Require Import Category.Prod.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 3
Time: 0.001s">
<div class="time" style="width: 0.052192066805846%"></div>
<pre>
Require Import Functor.Composition.Core.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 4
Time: 0.002s">
<div class="time" style="width: 0.10438413361169%"></div>
<pre>
Require Import Category.Morphisms.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 5
Time: 0.027s">
<div class="time" style="width: 1.4091858037578%"></div>
<pre>
Require Import SetCategory.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 6
Time: 0.045s">
<div class="time" style="width: 2.348643006263%"></div>
<pre>
Require Import Functor.Attributes.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 7
Time: 0.013s">
<div class="time" style="width: 0.67849686847599%"></div>
<pre>
Require ExponentialLaws.Law4.Functors.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 8
Time: 0.222s">
<div class="time" style="width: 11.586638830898%"></div>
<pre>
Require ProductLaws.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import HomFunctor.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import FunctorCategory.Core.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 11
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Require Import NaturalTransformation.Paths.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 12
Time: 0.002s">
<div class="time" style="width: 0.10438413361169%"></div>
<pre>
Require Import HSet HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Set Universe Polymorphism.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 15
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Implicit Arguments.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable All Variables.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 17
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Set Asymmetric Patterns.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 18
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope category_scope.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 20
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope functor_scope.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 21
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Quoting Wikipedia on the Yoneda lemma (chainging [A] to [a] and
    [C] to [A] so that we can use unicode superscripts and
    subscripts):

    In mathematics, specifically in category theory, the Yoneda lemma
    is an abstract result on functors of the type morphisms into a
    fixed object. It is a vast generalisation of Cayley's theorem from
    group theory (viewing a group as a particular kind of category
    with just one object). It allows the embedding of any category
    into a category of functors (contravariant set-valued functors)
    defined on that category. It also clarifies how the embedded
    category, of representable functors and their natural
    transformations, relates to the other objects in the larger
    functor category. It is an important tool that underlies several
    modern developments in algebraic geometry and representation
    theory. It is named after Nobuo Yoneda.

    ** Generalities

    The Yoneda lemma suggests that instead of studying the (locally
    small) category [A], one should study the category of all functors
    of [A] into [Set] (the category of sets with functions as
    morphisms). [Set] is a category we understand well, and a functor
    of [A] into [Set] can be seen as a "representation" of [A] in
    terms of known structures. The original category [A] is contained
    in this functor category, but new objects appear in the functor
    category which were absent and "hidden" in [A]. Treating these new
    objects just like the old ones often unifies and simplifies the
    theory.  This approach is akin to (and in fact generalizes) the
    common method of studying a ring by investigating the modules over
    that ring. The ring takes the place of the category [A], and the
    category of modules over the ring is a category of functors
    defined on [A].

    ** Formal statement

    *** General version

    Yoneda's lemma concerns functors from a fixed category [A] to the
    category of sets, [Set]. If [A] is a locally small category
    (i.e. the hom-sets are actual sets and not proper classes), then
    each object [a] of [A] gives rise to a natural functor to [Set]
    called a hom-functor. This functor is denoted:

    [hᵃ = Hom(a, ─)].

    The (covariant) hom-functor [hᵃ] sends [x] to the set of morphisms
    [Hom(a, x)] and sends a morphism [f] from [x] to [y] to the
    morphism [f ∘ ─] (composition with [f] on the left) that sends a
    morphism [g] in [Hom(a, x)] to the morphism [f ∘ g] in [Hom(a,
    y)]. That is,

    [f ↦ Hom(a, f) = ⟦ Hom(a, x) ∋ g ↦ f ∘ g ∈ Hom(a,y) ⟧].
 *)

(** ** The (co)yoneda functors [A → (Aᵒᵖ → set)] *)</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section yoneda.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable A : PreCategory.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (* TODO(JasonGross): Find a way to unify the [yoneda] and [coyoneda] lemmas into a single lemma which is more functorial. *)

 </pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 84
Time: 0.032s">
<div class="time" style="width: 1.6701461377871%"></div>
<pre>Definition coyoneda : Functor A^op (A -&gt; set_cat)
    := ExponentialLaws.Law4.Functors.inverse _ _ _ (hom_functor A).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 85
Time: 0.035s">
<div class="time" style="width: 1.8267223382046%"></div>
<pre>

  Definition yoneda : Functor A (A^op -&gt; set_cat)
    := ExponentialLaws.Law4.Functors.inverse _ _ _ (hom_functor A o ProductLaws.Swap.functor _ _).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 88
Time: 0.002s">
<div class="time" style="width: 0.10438413361169%"></div>
<pre>
End yoneda.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 89
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** The (co)yoneda lemma *)</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section coyoneda_lemma.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable A : PreCategory.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** Let [F] be an arbitrary functor from [A] to [Set]. Then Yoneda's
      lemma says that: *)
 </pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 96
Time: 0.012s">
<div class="time" style="width: 0.62630480167015%"></div>
<pre>Variable F : object (A -&gt; set_cat).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** For each object [a] of [A], *)
 </pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Variable a : A.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** the natural transformations from [hᵃ] to [F] are in one-to-one
      correspondence with the elements of [F(a)]. That is,

      [Nat(hᵃ, F) ≅ F(a)].

      Moreover this isomorphism is natural in [a] and [F] when both
      sides are regarded as functors from [Setᴬ × A] to
      [Set].

      Given a natural transformation [Φ] from [hᵃ] to [F], the
      corresponding element of [F(a)] is [u = Φₐ(idₐ)]. *)

 </pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 111
Time: 0.13s">
<div class="time" style="width: 6.7849686847599%"></div>
<pre>Definition coyoneda_lemma_morphism
  : morphism set_cat
             (BuildhSet
                (morphism (A -&gt; set_cat) (coyoneda A a) F)
                _)
             (F a)
    := fun phi =&gt; phi a 1%morphism.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Arguments Overture.compose / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 119
Time: 0.061s">
<div class="time" style="width: 3.1837160751566%"></div>
<pre>

  Definition coyoneda_lemma_morphism_inverse
  : morphism set_cat
             (F a)
             (BuildhSet
                (morphism (A -&gt; set_cat) (coyoneda A a) F)
                _).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 127
Time: 0.001s">
<div class="time" style="width: 0.052192066805846%"></div>
<pre>
    intro Fa.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 128
Time: 0.001s">
<div class="time" style="width: 0.052192066805846%"></div>
<pre>
    hnf.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 129
Time: 0.115s">
<div class="time" style="width: 6.0020876826722%"></div>
<pre>
    let F0 := match goal with |- NaturalTransformation ?F ?G =&gt; constr:(F) end in
    let G0 := match goal with |- NaturalTransformation ?F ?G =&gt; constr:(G) end in
    refine (Build_NaturalTransformation
              F0 G0
              (fun a' : A =&gt; (fun f : morphism A a a' =&gt; morphism_of F f Fa))
              _
           ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 136
Time: 0.009s">
<div class="time" style="width: 0.46972860125261%"></div>
<pre>
    simpl.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 137
Time: 0.328s">
<div class="time" style="width: 17.118997912317%"></div>
<pre>
    abstract (
        repeat first [ reflexivity
                     | intro
                     | apply path_forall
                     | progress rewrite ?composition_of, ?identity_of ]
      ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 143
Time: 0.043s">
<div class="time" style="width: 2.2442588726514%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Arguments coyoneda_lemma_morphism / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Local Arguments coyoneda_lemma_morphism_inverse / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 147
Time: 0.007s">
<div class="time" style="width: 0.36534446764092%"></div>
<pre>

  Global Instance coyoneda_lemma : IsIsomorphism coyoneda_lemma_morphism.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 149
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 150
Time: 1.451s">
<div class="time" style="width: 75.730688935282%"></div>
<pre>
    exists coyoneda_lemma_morphism_inverse;
    abstract (
        repeat (intro || apply path_forall || path_natural_transformation);
        simpl in *;
          solve [ simpl rewrite &lt;- (fun c d m =&gt; ap10 (commutes x c d m));
                  rewrite ?right_identity, ?left_identity;
                  reflexivity
                | rewrite identity_of;
                  reflexivity ]
      ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 160
Time: 0.043s">
<div class="time" style="width: 2.2442588726514%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 161
Time: 0.037s">
<div class="time" style="width: 1.9311064718163%"></div>
<pre>
End coyoneda_lemma.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section yoneda_lemma.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable A : PreCategory.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 166
Time: 0.009s">
<div class="time" style="width: 0.46972860125261%"></div>
<pre>
  Variable G : object (A^op -&gt; set_cat).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 167
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable a : A.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** There is a contravariant version of Yoneda's lemma which
        concerns contravariant functors from [A] to [Set]. This
        version involves the contravariant hom-functor

        [hₐ = Hom(─, A)],

        which sends [x] to the hom-set [Hom(x, a)]. Given an arbitrary
        contravariant functor [G] from [A] to [Set], Yoneda's lemma
        asserts that

        [Nat(hₐ, G) ≅ G(a)]. *)

 </pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 181
Time: 0.115s">
<div class="time" style="width: 6.0020876826722%"></div>
<pre>Definition yoneda_lemma_morphism
  : morphism set_cat
             (BuildhSet
                (morphism (A^op -&gt; set_cat) (yoneda A a) G)
                _)
             (G a)
    := fun phi =&gt; phi a 1%morphism.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 187
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Arguments Overture.compose / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 189
Time: 0.045s">
<div class="time" style="width: 2.348643006263%"></div>
<pre>

  Definition yoneda_lemma_morphism_inverse
  : morphism set_cat
             (G a)
             (BuildhSet
                (morphism (A^op -&gt; set_cat) (yoneda A a) G)
                _).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 196
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 197
Time: 0.001s">
<div class="time" style="width: 0.052192066805846%"></div>
<pre>
    intro Ga.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 198
Time: 0.001s">
<div class="time" style="width: 0.052192066805846%"></div>
<pre>
    hnf.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 199
Time: 0.105s">
<div class="time" style="width: 5.4801670146138%"></div>
<pre>
    let F0 := match goal with |- NaturalTransformation ?F ?G =&gt; constr:(F) end in
    let G0 := match goal with |- NaturalTransformation ?F ?G =&gt; constr:(G) end in
    refine (Build_NaturalTransformation
              F0 G0
              (fun a' : A =&gt; (fun f : morphism A a' a =&gt; morphism_of G f Ga))
              _
           ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 206
Time: 0.012s">
<div class="time" style="width: 0.62630480167015%"></div>
<pre>
    simpl in *.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 207
Time: 0.213s">
<div class="time" style="width: 11.116910229645%"></div>
<pre>
    abstract (
        repeat first [ reflexivity
                     | intro
                     | apply path_forall
                     | progress rewrite ?composition_of, ?identity_of, ?left_identity, ?right_identity
                     | match goal with
                         | [ F : Functor _ _ |- _ ]
                             (* the [rewrite ?composition_of] doesn't catch this, because it looks for [A^op] in some places that it finds [A]. *)
                           =&gt; simpl rewrite (composition_of F)
                       end ]
      ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 218
Time: 0.064s">
<div class="time" style="width: 3.3402922755741%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 219
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Arguments yoneda_lemma_morphism / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 221
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Local Arguments yoneda_lemma_morphism_inverse / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 222
Time: 0.009s">
<div class="time" style="width: 0.46972860125261%"></div>
<pre>

  Global Instance yoneda_lemma : IsIsomorphism yoneda_lemma_morphism.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 224
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 225
Time: 1.916s">
<div class="time" style="width: 100%"></div>
<pre>
    exists yoneda_lemma_morphism_inverse;
    abstract (
        repeat (intro || apply path_forall || path_natural_transformation);
        simpl in *;
          solve [ simpl rewrite &lt;- (fun c d m =&gt; ap10 (commutes x c d m));
                  rewrite ?right_identity, ?left_identity;
                  reflexivity
                | match goal with
                    | [ F : Functor _ _ |- _ ] =&gt; rewrite (identity_of F)
                  end;
                  reflexivity ]
      ).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 237
Time: 0.042s">
<div class="time" style="width: 2.1920668058455%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 238
Time: 0.042s">
<div class="time" style="width: 2.1920668058455%"></div>
<pre>
End yoneda_lemma.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 239
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** The Yoneda embedding

    An important special case of Yoneda's lemma is when the functor
    [F] from [A] to [Set] is another hom-functor [hᵇ]. In this case,
    the covariant version of Yoneda's lemma states that

    [Nat(hᵃ, hᵇ) ≅ Hom(b, a)].

    That is, natural transformations between hom-functors are in
    one-to-one correspondence with morphisms (in the reverse
    direction) between the associated objects. Given a morphism [f : b
    → a] the associated natural transformation is denoted [Hom(f, ─)].

    Mapping each object [a] in [A] to its associated hom-functor [hᵃ=
    Hom(a, ─)] and each morphism [f : B → A] to the corresponding
    natural transformation [Hom(f, ─)] determines a contravariant
    functor [h⁻] from [A] to [Setᴬ], the functor category of all
    (covariant) functors from [A] to [Set]. One can interpret [h⁻] as
    a covariant functor:

    [h⁻ : Aᵒᵖ → Setᴬ].

    The meaning of Yoneda's lemma in this setting is that the functor
    [h⁻] is fully faithful, and therefore gives an embedding of [Aᵒᵖ]
    in the category of functors to [Set]. The collection of all
    functors {[hᵃ], [a] in [A]} is a subcategory of [Set̂ᴬ]. Therefore,
    Yoneda embedding implies that the category [Aᵒᵖ] is isomorphic to
    the category {[hᵃ], [a] in [A]}.

    The contravariant version of Yoneda's lemma states that

    [Nat(hₐ, h_b) ≅ Hom(a, b)].

    Therefore, [h₋] gives rise to a covariant functor from [A] to the
    category of contravariant functors to [Set]:

    [h₋ : A → Set⁽⁽ᴬ⁾ᵒᵖ⁾].

    Yoneda's lemma then states that any locally small category [A] can
    be embedded in the category of contravariant functors from [A] to
    [Set] via [h₋]. This is called the Yoneda embedding. *)

</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section FullyFaithful.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context `{Funext}.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 283
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Variable A : PreCategory.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 284
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Local Arguments Overture.compose / .</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 286
Time: 0.003s">
<div class="time" style="width: 0.15657620041754%"></div>
<pre>

  Definition coyoneda_embedding : IsFullyFaithful (coyoneda A).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 289
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros a b.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 290
Time: 0.009s">
<div class="time" style="width: 0.46972860125261%"></div>
<pre>
    pose (coyoneda_lemma (A := A) (coyoneda A b) a) as YL.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 291
Time: 1.704s">
<div class="time" style="width: 88.935281837161%"></div>
<pre>
    exists (coyoneda_lemma_morphism (F := coyoneda A b) (a := a));
      [ eapply iso_moveR_Mp
      | eapply iso_moveR_pM ];
      repeat (intro || apply path_forall || path_natural_transformation);
        simpl;
        rewrite ?left_identity, ?right_identity;
        reflexivity.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 298
Time: 0.881s">
<div class="time" style="width: 45.98121085595%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 299
Time: 0.002s">
<div class="time" style="width: 0.10438413361169%"></div>
<pre>

  Definition yoneda_embedding : IsFullyFaithful (yoneda A).</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 301
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros a b.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 303
Time: 0.006s">
<div class="time" style="width: 0.31315240083507%"></div>
<pre>
    pose (yoneda_lemma (A := A) (yoneda A b) a) as YL.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 304
Time: 1.564s">
<div class="time" style="width: 81.628392484342%"></div>
<pre>
    exists (yoneda_lemma_morphism (G := yoneda A b) (a := a));
      [ eapply iso_moveR_Mp
      | eapply iso_moveR_pM ];
      repeat (intro || apply path_forall || path_natural_transformation);
        simpl;
        rewrite ?left_identity, ?right_identity;
        reflexivity.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 311
Time: 0.949s">
<div class="time" style="width: 49.530271398747%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 312
Time: 0.039s">
<div class="time" style="width: 2.035490605428%"></div>
<pre>
End FullyFaithful.</pre>
</div>
<div class="code" title="File: Yoneda.v
Line: 314
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

