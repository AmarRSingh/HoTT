<html>
<head>
<title>Lex.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Lex.v</h1>

<div class="code" title="File: Lex.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.042s">
<div class="time" style="width: 1.6451233842538%"></div>
<pre>Require Import HoTT.Basics HoTT.Types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.012s">
<div class="time" style="width: 0.47003525264395%"></div>
<pre>
Require Import EquivalenceVarieties Fibrations Extensions Pullback NullHomotopy.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 2
Time: 0.019s">
<div class="time" style="width: 0.74422248335292%"></div>
<pre>
Require Import Modality Accessible.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 3
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** * Lex modalities *)

(** ** Basic theory *)

(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;http://mathoverflow.net/questions/185980/a-small-definition-of-sub-%E2%88%9E-1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. *)

</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Lex_Modalities_Theory (Os : Modalities).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0.095s">
<div class="time" style="width: 3.7211124167646%"></div>
<pre>

  Module Export Os_Theory := Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 18
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>

  Class Lex (O : Modality@{u a})
    := isconnected_paths : forall (A : Type@{i}) (x y : A),
                             IsConnected@{u a i} O A -&gt;
                             IsConnected@{u a i} O (x = y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Existing Instance isconnected_paths.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** The following numbered lemmas are all actually equivalent characterizations of lex-ness. *)

  (** 1. Every map between connected types is a connected map. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 30
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>Global Instance conn_map_lex {O : Modality} `{Lex O}
         {A : Type@{i}} {B : Type@{j}} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 34
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>
    intros b; refine (isconnected_sigma O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 35
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 2. Connected maps are left- as well as right-cancellable. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 39
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>Definition cancelL_conn_map (O : Modality) `{Lex O}
             {A B C : Type} (f : A -&gt; B) (g : B -&gt; C)
  : IsConnMap O g -&gt; IsConnMap O (g o f) -&gt; IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 41
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros ? ? b.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 43
Time: 0.054s">
<div class="time" style="width: 2.1151586368978%"></div>
<pre>
    refine (isconnected_equiv O _ (hfiber_hfiber_compose_map f g b) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 44
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 3. Every map inverted by [O] is [O]-connected. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 48
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>Definition isconnected_O_inverts (O : Modality) `{Lex O}
             {A B : Type} (f : A -&gt; B) `{O_inverts O f}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 50
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 51
Time: 0.041s">
<div class="time" style="width: 1.6059537798668%"></div>
<pre>
    refine (cancelL_conn_map O f (to O B) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 52
Time: 0.028s">
<div class="time" style="width: 1.0967489228359%"></div>
<pre>
    refine (conn_map_homotopic O _ _ (to_O_natural O f) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 55
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 55
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 4. Connected types are closed under pullbacks.  (Closure under fibers is [conn_map_lex] above. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 58
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>Global Instance isconnected_pullback (O : Modality) `{Lex O}
         {A B C : Type} {f : A -&gt; C} {g : B -&gt; C}
         `{IsConnected O A} `{IsConnected O B} `{IsConnected O C}
  : IsConnected O (Pullback f g).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 62
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    apply isconnected_sigma; [ exact _ | intros a ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 63
Time: 0.012s">
<div class="time" style="width: 0.47003525264395%"></div>
<pre>
    refine (isconnected_equiv O (hfiber g (f a))
                              (equiv_functor_sigma' (equiv_idmap _)
                              (fun b =&gt; equiv_path_inverse _ _))
                              _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 67
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 68
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 5. The reflector preserves pullbacks.  This justifies the terminology "lex". *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 71
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>Definition O_functor_pullback (O : Modality) `{Lex O}
             {A B C} (f : B -&gt; A) (g : C -&gt; A)
  : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 74
Time: 0.119s">
<div class="time" style="width: 4.6611829220525%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 75
Time: 0.032s">
<div class="time" style="width: 1.2534273403839%"></div>
<pre>
    refine (O_inverts_conn_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 76
Time: 0.252s">
<div class="time" style="width: 9.8707403055229%"></div>
<pre>
    refine (cancelR_conn_map O (to O (Pullback f g)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 77
Time: 0.116s">
<div class="time" style="width: 4.5436741088915%"></div>
<pre>
    refine (conn_map_homotopic O
             (functor_pullback f g (O_functor O f) (O_functor O g)
                               (to O A) (to O B) (to O C)
                               (to_O_natural O f) (to_O_natural O g))
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 84
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 84
Time: 0.007s">
<div class="time" style="width: 0.27418723070897%"></div>
<pre> intros [b [c e]];
        unfold functor_pullback, functor_sigma, pullback_corec;
        simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 86
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr1 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 87
Time: 0.01s">
<div class="time" style="width: 0.39169604386996%"></div>
<pre>
      rewrite transport_sigma'; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 88
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr2 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 89
Time: 0.009s">
<div class="time" style="width: 0.35252643948296%"></div>
<pre>
      rewrite transport_paths_Fl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 90
Time: 0.008s">
<div class="time" style="width: 0.31335683509597%"></div>
<pre>
      rewrite transport_paths_Fr.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 92
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold O_functor_square.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 93
Time: 0.174s">
<div class="time" style="width: 6.8155111633373%"></div>
<pre>
      rewrite ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 94
Time: 0.038s">
<div class="time" style="width: 1.4884449667058%"></div>
<pre>
      unfold pullback_commsq; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 95
Time: 0.168s">
<div class="time" style="width: 6.5804935370153%"></div>
<pre>
      rewrite to_O_natural_compose, !concat_pp_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0.01s">
<div class="time" style="width: 0.39169604386996%"></div>
<pre>
      do 3 apply whiskerL.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 97
Time: 0.016s">
<div class="time" style="width: 0.62671367019193%"></div>
<pre>
      rewrite ap_V, &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 98
Time: 0.023s">
<div class="time" style="width: 0.9009009009009%"></div>
<pre>
      rewrite &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 99
Time: 0.008s">
<div class="time" style="width: 0.31335683509597%"></div>
<pre>
      apply inverse2, to_O_natural_compose.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by [hfiber_functor_pullback] and typeclass magic invoking [isconnected_pullback]. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 103
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre> intros [ob [oc oe]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 103
Time: 2.553s">
<div class="time" style="width: 100%"></div>
<pre>
      refine (isconnected_equiv O _
                (hfiber_functor_pullback _ _ _ _ _ _ _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 105
Time: 0.738s">
<div class="time" style="width: 28.907168037603%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 106
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 6. The reflector preserves fibers.  This is a slightly simpler version of the previous. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 109
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>Global Instance isequiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 111
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 112
Time: 0.124s">
<div class="time" style="width: 4.8570309439875%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 113
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    apply O_inverts_conn_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 114
Time: 0.277s">
<div class="time" style="width: 10.849980415198%"></div>
<pre>
    refine (cancelR_conn_map O (to O _) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 116
Time: 0.129s">
<div class="time" style="width: 5.0528789659224%"></div>
<pre>
    refine (conn_map_homotopic O
             (@functor_hfiber _ _ _ _ f (O_functor O f)
                               (to O A) (to O B)
                               (fun x =&gt; (to_O_natural O f x)^) b)
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 122
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre> intros [a p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 122
Time: 0.006s">
<div class="time" style="width: 0.23501762632197%"></div>
<pre>
      rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold functor_hfiber, functor_sigma.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 124
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre> apply ap.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 124
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
      apply whiskerR, inv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre> intros [oa p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0.238s">
<div class="time" style="width: 9.322365844105%"></div>
<pre>
      refine (isconnected_equiv O _
               (hfiber_functor_hfiber _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 128
Time: 0.029s">
<div class="time" style="width: 1.1359185272229%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 129
Time: 0.019s">
<div class="time" style="width: 0.74422248335292%"></div>
<pre>

  Definition equiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : O (hfiber f b) &lt;~&gt; hfiber (O_functor O f) (to O B b)
    := BuildEquiv _ _ (O_functor_hfiber O f b) _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 7. Lex modalities preserve path-spaces. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 137
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>Definition O_path_cmp (O : Modality) {A} (x y : A)
  : O (x = y) -&gt; (to O A x = to O A y)
    := O_rec (ap (to O A)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 139
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>

  Global Instance isequiv_O_path_cmp {O : Modality} `{Lex O} {A} (x y : A)
  : IsEquiv (O_path_cmp O x y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 142
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 143
Time: 0.038s">
<div class="time" style="width: 1.4884449667058%"></div>
<pre>
    refine (isequiv_conn_ino_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 144
Time: 0.144s">
<div class="time" style="width: 5.6404230317274%"></div>
<pre>
    refine (cancelR_conn_map O (to O (x = y)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 145
Time: 0.026s">
<div class="time" style="width: 1.0184097140619%"></div>
<pre>
    refine (conn_map_homotopic O (ap (to O A)) _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 147
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre> intros ?; symmetry; by apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 148
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 148
Time: 0.348s">
<div class="time" style="width: 13.631022326675%"></div>
<pre>
      refine (isconnected_equiv O _ (hfiber_ap p)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 149
Time: 0.006s">
<div class="time" style="width: 0.23501762632197%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 150
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We will not prove that any of these lemmas are equivalent characterizations of lex-ness, because they are all fairly obvious and we don't yet know of any use for them; [isconnected_paths] is usually strictly easier to prove than they are. *)

  (** Another useful lemma, which is probably not equivalent to lex-ness: any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 155
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre>Definition ispullback_connmap_mapino_commsq (O : Modality) `{Lex O} {A B C D}
             {f : A -&gt; B} {g : C -&gt; D} {h : A -&gt; C} {k : B -&gt; D}
             `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
             `{MapIn O _ _ h} `{MapIn O _ _ k}
             (p : k o f == g o h)
  : IsPullback p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 161
Time: 0.036s">
<div class="time" style="width: 1.4101057579318%"></div>
<pre>
    refine (isequiv_conn_ino_map O (pullback_corec p)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 163
Time: 0.01s">
<div class="time" style="width: 0.39169604386996%"></div>
<pre> refine (cancelL_conn_map O (pullback_corec p) (k^* g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 163
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 164
Time: 0.134s">
<div class="time" style="width: 5.2487269878574%"></div>
<pre> refine (cancelL_mapinO O _ (equiv_pullback_symm k g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 164
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>
      refine (cancelL_mapinO O _ (g^* k) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 165
Time: 0.007s">
<div class="time" style="width: 0.27418723070897%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 166
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 169
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>Global Instance istrunc_O_lex `{Funext} {O : Modality} `{Lex O}
         {n} {A} `{IsTrunc n A}
  : IsTrunc n (O A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 171
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 172
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    generalize dependent A; simple_induction n n IHn; intros A ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 173
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 174
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 174
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>               (** Already proven for all modalities. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 175
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 175
Time: 0.025s">
<div class="time" style="width: 0.97924010967489%"></div>
<pre> refine (O_ind (fun x =&gt; forall y, IsTrunc n (x = y)) _); intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 175
Time: 0.01s">
<div class="time" style="width: 0.39169604386996%"></div>
<pre>
      refine (O_ind (fun y =&gt; IsTrunc n (to O A x = y)) _); intros y.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 176
Time: 0.009s">
<div class="time" style="width: 0.35252643948296%"></div>
<pre>
      refine (trunc_equiv _ (O_path_cmp O x y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 177
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 178
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Lex reflective subuniverses *)

(** A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Type Preserves_Fibers (Os : ReflectiveSubuniverses).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Export Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 186
Time: 0.039s">
<div class="time" style="width: 1.5276145710928%"></div>
<pre>
  Module Export Os_Theory := ReflectiveSubuniverses_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 187
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>

  Parameter isequiv_O_functor_hfiber :
     forall (O : ReflectiveSubuniverse) {A B} (f : A -&gt; B) (b : B),
       IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Preserves_Fibers.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 193
Time: 0.008s">
<div class="time" style="width: 0.31335683509597%"></div>
<pre>

Module Lex_Reflective_Subuniverses
       (Os : ReflectiveSubuniverses) (Opf : Preserves_Fibers Os)
  &lt;: SigmaClosed Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 197
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>

  Import Opf.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 199
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition inO_sigma@{u a i j k} (O : ReflectiveSubuniverse@{u a})
             (A:Type@{i}) (B:A -&gt; Type@{j})
             (A_inO : In@{u a i} O A)
             (B_inO : forall a, In@{u a j} O (B a))
  : In@{u a k} O {x:A &amp; B x}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 205
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 206
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    pose (g := O_rec@{u a k i k k i} pr1 : O {x : A &amp; B x} -&gt; A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 207
Time: 0.007s">
<div class="time" style="width: 0.27418723070897%"></div>
<pre>
    transparent assert (p : (forall x, g (to O _ x) = x.1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 208
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 209
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros x; subst g; apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 209
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 209
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply inO_isequiv_to_O@{u a k k}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 210
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isequiv_fcontr; intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 211
Time: 0.049s">
<div class="time" style="width: 1.9193106149628%"></div>
<pre>
    refine (contr_equiv' _ (hfiber_hfiber_compose_map@{k k i k k k k k} _ g x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    apply fcontr_isequiv.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 213
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber_compose_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 214
Time: 0.021s">
<div class="time" style="width: 0.82256169212691%"></div>
<pre>
    transparent assert (h : (Equiv@{k k} (hfiber@{k i} (@pr1 A B) (g x))
                                         (hfiber@{k i} g (g x)))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 216
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 217
Time: 0.024s">
<div class="time" style="width: 0.9400705052879%"></div>
<pre> refine (_ oE equiv_to_O@{u a k k} O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 217
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 218
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre> refine (_ oE BuildEquiv _ _
                  (O_functor_hfiber O (@pr1 A B) (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 219
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 220
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
        refine (equiv_functor_sigma' 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 221
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros y; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 221
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>
        refine (_ oE (equiv_moveR_equiv_V _ _)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 222
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        apply equiv_concat_l.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 223
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        apply moveL_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 224
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        unfold g, O_functor.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 225
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>
        revert y; apply O_indpaths@{u a k i i k k}; intros [a q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 226
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
        refine (_ @ (O_rec_beta _ _)^).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 227
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
        apply ap, O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 228
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 229
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre> refine (inO_equiv_inO@{u (*dwim1*) a (*dwim2*) j (*dwim3*) k (* &lt;- dwim4 *) k} _
                 (hfiber_fibration@{i j k} (g x) B)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 230
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 230
Time: 0.029s">
<div class="time" style="width: 1.1359185272229%"></div>
<pre>
    refine (isequiv_homotopic (h oE equiv_hfiber_homotopic _ _ p (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 231
Time: 0.016s">
<div class="time" style="width: 0.62671367019193%"></div>
<pre>
    intros [[a b] q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 232
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> clear h.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 232
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 233
Time: 0.033s">
<div class="time" style="width: 1.2925969447709%"></div>
<pre>
    rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 234
Time: 0.009s">
<div class="time" style="width: 0.35252643948296%"></div>
<pre>
    unfold functor_sigma; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 235
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    refine (path_sigma' _ 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 236
Time: 0.016s">
<div class="time" style="width: 0.62671367019193%"></div>
<pre>
    rewrite O_indpaths_beta; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 237
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold moveL_equiv_V, moveR_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 238
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 239
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Opaque eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 240
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 241
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre>set (k := @eissect); change @eissect with k; subst k.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 241
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4543 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 242
Time: 0.127s">
<div class="time" style="width: 4.9745397571485%"></div>
<pre>rewrite !ap_pp, !concat_p_pp, !ap_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 242
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold to_O_natural.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 243
Time: 0.008s">
<div class="time" style="width: 0.31335683509597%"></div>
<pre>
    rewrite concat_pV_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 244
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    subst p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 245
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>
    rewrite concat_pp_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 246
Time: 0.004s">
<div class="time" style="width: 0.15667841754798%"></div>
<pre>
    rewrite concat_pp_p; apply moveR_Vp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 247
Time: 0.009s">
<div class="time" style="width: 0.35252643948296%"></div>
<pre>
    rewrite &lt;- !(ap_compose (to O A) (to O A)^-1).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 248
Time: 0.008s">
<div class="time" style="width: 0.31335683509597%"></div>
<pre>
    rapply @concat_A1p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 249
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Transparent eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 250
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 251
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 251
Time: 0.271s">
<div class="time" style="width: 10.614962788876%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 252
Time: 0.02s">
<div class="time" style="width: 0.78339208773991%"></div>
<pre>

End Lex_Reflective_Subuniverses.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 254
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Accessible lex modalities *)

(** We now restrict to lex modalities that are also accessible. *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 258
Time: 0.015s">
<div class="time" style="width: 0.58754406580494%"></div>
<pre>Module Accessible_Lex_Modalities_Theory
       (Os : Modalities)
       (Acc : Accessible_Modalities Os).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 260
Time: 0.162s">
<div class="time" style="width: 6.3454759106933%"></div>
<pre>

  Module Export Acc_Theory := Accessible_Modalities_Theory Os Acc.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 262
Time: 0.112s">
<div class="time" style="width: 4.3869956913435%"></div>
<pre>
  Module Export Lex_Theory := Lex_Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications [Module Os_Theory := Modalities_Theory Os] that occur in both [Accessible_Modalities_Theory Os Acc] and [Lex_Modalities_Theory Os] create two *different* modules, which appear here as [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory].  Thus, for instance, we have two different definitions [Acc_Theory.Os_Theory.O_ind] and [Lex_Theory.Os_Theory.O_ind], etc.

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in [Modalities_Theory] is opaque, then Coq will be unable to notice that its duplicate copies in [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory] were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, [Inductive] and [Record] definitions, like modules, always create a new object not convertible to any previously existing one.  There are no [Inductive] or [Record] definitions in [Modalities_Theory], but there are [Class] declarations, and these function similarly.  In particular, typeclass search is unable to use [Instance]s defined in [Acc_Theory] to instantiate typeclasses from [Modalities_Theory] (such as [IsConnected]) needed by functions in [Lex_Theory], and vice versa.

  Fortunately, all the typeclasses defined in [Modalities_Theory] are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the [Instance]s from [Acc_Theory] can in fact be typechecked to *belong* to the typeclasses needed by [Lex_Theory], and hence can be supplied explicitly.

  We can also do this once and for all by defining [Instance]s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in [Acc_Theory], so this direction seems likely to be the most useful. *)

 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 275
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>Global Instance isconnected_acc_to_lex {O : Modality} {A : Type}
         {H : Acc_Theory.Os_Theory.IsConnected O A}
            : Lex_Theory.Os_Theory.IsConnected O A
         := H.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 278
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 281
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance inO_typeO `{Univalence} (O : Modality) `{Lex O}
  : In O (Type_ O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 283
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    apply (snd (inO_iff_isnull O _)); intros i n; simpl in *.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 284
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
    destruct n; [ exact tt | split ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 285
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros P.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Here is the core of the proof: we must show that any family of modal types indexed by a (generating) connected type is equivalent to a constant family.  We take the constant family to be constant at the reflection of the sum of our given family [P]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 288
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>simple refine (fun u =&gt; (O (sigT P) ; _) ; _); cbn beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 288
Time: 0.001s">
<div class="time" style="width: 0.039169604386996%"></div>
<pre>
      1:exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 289
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>
      intros x; symmetry; apply path_TypeO; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 290
Time: 0.195s">
<div class="time" style="width: 7.6380728554642%"></div>
<pre>
      refine (path_universe (fun p =&gt; to O _ (x ; p))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 291
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      revert x; apply isequiv_from_functor_sigma.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 292
Time: 0.074s">
<div class="time" style="width: 2.8985507246377%"></div>
<pre>
      refine (@isequiv_compose _ _
                (pullback_corec ((fun w:sigT P =&gt; 1)
                                 : const tt o to O (sigT P) == const tt o pr1))
                _ _ (fun w =&gt; (w.2.1 ; w.1)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 296
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** And here is the core of why it works: the useful lemma above about detecting pullback squares. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 298
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>+</pre>
</div>
<div class="code" title="File: Lex.v
Line: 298
Time: 0.037s">
<div class="time" style="width: 1.4492753623188%"></div>
<pre> refine (ispullback_connmap_mapino_commsq O
                 ((fun w:sigT P =&gt; 1)
                  : const tt o to O (sigT P) == const tt o pr1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 300
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        (** All the necessary hypotheses are found by typeclass magic! *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>+</pre>
</div>
<div class="code" title="File: Lex.v
Line: 302
Time: 0.113s">
<div class="time" style="width: 4.4261652957305%"></div>
<pre> refine (@isequiv_compose _ _
                  (equiv_compose
                    (equiv_prod_symm (O (sigT P)) (acc_gen O i))
                    (equiv_pullback_unit_prod (O (sigT P)) (acc_gen O i)))
                  _ _ (equiv_sigma_prod0 _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 306
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 307
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n&gt;0] is actually quite easy, using univalence and the fact that modal types are closed under [Equiv]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 309
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>refine (extendable_postcompose' n _ _ _
                (fun b =&gt; (equiv_path_TypeO O (A b) (B b))
                            oE (equiv_path_universe (A b) (B b)))
                _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 312
Time: 0.027s">
<div class="time" style="width: 1.0575793184489%"></div>
<pre>
      refine (extendable_conn_map_inO O n (@const (acc_gen O i) Unit tt)
                                      (fun b =&gt; A b &lt;~&gt; B b)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 314
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 316
Time: 0.028s">
<div class="time" style="width: 1.0967489228359%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 316
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** [inO_typeO] is also an equivalent characterization of lex-ness for a modality.  We will prove this, because it is less obvious, and also more useful. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 319
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition lex_inO_typeO (O : Modality) `{In O (Type_ O)}
  : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 320
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 321
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 322
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_from_elim_to_O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 323
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** The idea is that if [A] is connected and [Type_ O] is modal, then [fun y =&gt; O (x = y) : A -&gt; Type_ O] is constant.  Thus, [to O (x=x) 1] can be transported around to make it contractible everywhere. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 325
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>pose (e := isconnected_elim O (Type_ O)
                 (fun y' =&gt; (O (x = y') ; O_inO _))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 326
Time: 0.003s">
<div class="time" style="width: 0.11750881316099%"></div>
<pre>
    exists (transport idmap (e.2 x @ (e.2 y)^)..1 (to O (x=x) 1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 327
Time: 0.002s">
<div class="time" style="width: 0.078339208773991%"></div>
<pre>
    intros [].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 328
Time: 0.005s">
<div class="time" style="width: 0.19584802193498%"></div>
<pre>
    exact ((transport2 idmap (ap (ap pr1) (concat_pV (e.2 x))) _)^).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 329
Time: 0.014s">
<div class="time" style="width: 0.54837446141794%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 330
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Accessible_Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 333
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

