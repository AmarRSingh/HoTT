<html>
<head>
<title>Lex.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Lex.v</h1>

<div class="code" title="File: Lex.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.054s">
<div class="time" style="width: 1.5215553677092%"></div>
<pre>Require Import HoTT.Basics HoTT.Types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.012s">
<div class="time" style="width: 0.33812341504649%"></div>
<pre>
Require Import Fibrations Extensions Pullback NullHomotopy.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 2
Time: 0.022s">
<div class="time" style="width: 0.61989292758524%"></div>
<pre>
Require Import Modality Accessible.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 3
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** * Lex modalities *)

(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;http://mathoverflow.net/questions/185980/a-small-definition-of-sub-%E2%88%9E-1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. *)

</pre>
</div>
<div class="code" title="File: Lex.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Lex_Modalities_Theory (Os : Modalities).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 14
Time: 0.022s">
<div class="time" style="width: 0.61989292758524%"></div>
<pre>

  Module Export Os_Theory := Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0.003s">
<div class="time" style="width: 0.084530853761623%"></div>
<pre>

  Class Lex (O : Modality@{u a})
    := isconnected_paths : forall (A : Type@{i}) (x y : A),
                             IsConnected@{u a i} O A -&gt;
                             IsConnected@{u a i} O (x = y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 21
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Existing Instance isconnected_paths.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** The next six lemmas are equivalent characterizations of lex-ness. *)

  (** 1. Every map between connected types is a connected map. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 28
Time: 0.002s">
<div class="time" style="width: 0.056353902507749%"></div>
<pre>Global Instance conn_map_lex {O : Modality} `{Lex O}
         {A : Type@{i}} {B : Type@{j}} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 32
Time: 0.006s">
<div class="time" style="width: 0.16906170752325%"></div>
<pre>
    intros b; refine (isconnected_sigma O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 33
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 2. Connected maps are left- as well as right-cancellable. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 37
Time: 0.003s">
<div class="time" style="width: 0.084530853761623%"></div>
<pre>Definition cancelL_conn_map (O : Modality) `{Lex O}
             {A B C : Type} (f : A -&gt; B) (g : B -&gt; C)
  : IsConnMap O g -&gt; IsConnMap O (g o f) -&gt; IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 40
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros ? ? b.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 41
Time: 0.083s">
<div class="time" style="width: 2.3386869540716%"></div>
<pre>
    refine (isconnected_equiv O _ (hfiber_hfiber_compose_map f g b) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 42
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 43
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 3. Every map inverted by [O] is [O]-connected. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 46
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>Definition isconnected_O_inverts (O : Modality) `{Lex O}
             {A B : Type} (f : A -&gt; B) `{O_inverts O f}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 49
Time: 0.036s">
<div class="time" style="width: 1.0143702451395%"></div>
<pre>
    refine (cancelL_conn_map O f (to O B) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 50
Time: 0.035s">
<div class="time" style="width: 0.9861932938856%"></div>
<pre>
    refine (conn_map_homotopic O _ _ (to_O_natural O f) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 53
Time: 0.002s">
<div class="time" style="width: 0.056353902507749%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 4. Connected types are closed under pullbacks. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 56
Time: 0.002s">
<div class="time" style="width: 0.056353902507749%"></div>
<pre>Global Instance isconnected_pullback (O : Modality) `{Lex O}
         {A B C : Type} {f : A -&gt; C} {g : B -&gt; C}
         `{IsConnected O A} `{IsConnected O B} `{IsConnected O C}
  : IsConnected O (Pullback f g).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 59
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 60
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
    apply isconnected_sigma; [ exact _ | intros a ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 61
Time: 0.012s">
<div class="time" style="width: 0.33812341504649%"></div>
<pre>
    refine (isconnected_equiv O (hfiber g (f a))
                              (equiv_functor_sigma' (equiv_idmap _)
                              (fun b =&gt; equiv_path_inverse _ _))
                              _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 65
Time: 0.002s">
<div class="time" style="width: 0.056353902507749%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 66
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 5. The reflector preserves pullbacks.  This justifies the terminology "lex". *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 69
Time: 0.004s">
<div class="time" style="width: 0.1127078050155%"></div>
<pre>Definition O_functor_pullback (O : Modality) `{Lex O}
             {A B C} (f : B -&gt; A) (g : C -&gt; A)
  : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 71
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 72
Time: 0.146s">
<div class="time" style="width: 4.1138348830657%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 73
Time: 0.037s">
<div class="time" style="width: 1.0425471963934%"></div>
<pre>
    refine (O_inverts_conn_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 74
Time: 0.225s">
<div class="time" style="width: 6.3398140321217%"></div>
<pre>
    refine (cancelR_conn_map O (to O (Pullback f g)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 75
Time: 0.262s">
<div class="time" style="width: 7.3823612285151%"></div>
<pre>
    refine (conn_map_homotopic O
             (functor_pullback f g (O_functor O f) (O_functor O g)
                               (to O A) (to O B) (to O C)
                               (to_O_natural O f) (to_O_natural O g))
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 82
Time: 0.014s">
<div class="time" style="width: 0.39447731755424%"></div>
<pre> intros [b [c e]];
        unfold functor_pullback, functor_sigma, pullback_corec;
        simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 84
Time: 0.017s">
<div class="time" style="width: 0.47900817131586%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr1 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 85
Time: 0.012s">
<div class="time" style="width: 0.33812341504649%"></div>
<pre>
      rewrite transport_sigma'; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 86
Time: 0.018s">
<div class="time" style="width: 0.50718512256974%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr2 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 87
Time: 0.014s">
<div class="time" style="width: 0.39447731755424%"></div>
<pre>
      rewrite transport_paths_Fl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 88
Time: 0.009s">
<div class="time" style="width: 0.25359256128487%"></div>
<pre>
      rewrite transport_paths_Fr.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 89
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 90
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold O_functor_square.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 91
Time: 0.189s">
<div class="time" style="width: 5.3254437869822%"></div>
<pre>
      rewrite ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 92
Time: 0.043s">
<div class="time" style="width: 1.2116089039166%"></div>
<pre>
      unfold pullback_commsq; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 93
Time: 0.184s">
<div class="time" style="width: 5.1845590307129%"></div>
<pre>
      rewrite to_O_natural_compose, !concat_pp_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 94
Time: 0.012s">
<div class="time" style="width: 0.33812341504649%"></div>
<pre>
      do 3 apply whiskerL.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 95
Time: 0.023s">
<div class="time" style="width: 0.64806987883911%"></div>
<pre>
      rewrite ap_V, &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0.031s">
<div class="time" style="width: 0.8734854888701%"></div>
<pre>
      rewrite &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 97
Time: 0.01s">
<div class="time" style="width: 0.28176951253874%"></div>
<pre>
      apply inverse2, to_O_natural_compose.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by [hfiber_functor_pullback] and typeclass magic invoking [isconnected_pullback]. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 0.005s">
<div class="time" style="width: 0.14088475626937%"></div>
<pre> intros [ob [oc oe]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 3.549s">
<div class="time" style="width: 100%"></div>
<pre>
      refine (isconnected_equiv O _
                (equiv_inverse
                   (hfiber_functor_pullback _ _ _ _ _ _ _ _ _ _)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 104
Time: 0.961s">
<div class="time" style="width: 27.078050154973%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 6. Lex modalities preserve path-spaces. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 108
Time: 0.006s">
<div class="time" style="width: 0.16906170752325%"></div>
<pre>Definition O_path_cmp (O : Modality) {A} (x y : A)
  : O (x = y) -&gt; (to O A x = to O A y)
    := O_rec (ap (to O A)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 110
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>

  Global Instance isequiv_O_path_cmp {O : Modality} `{Lex O} {A} (x y : A)
  : IsEquiv (O_path_cmp O x y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 114
Time: 0.043s">
<div class="time" style="width: 1.2116089039166%"></div>
<pre>
    refine (isequiv_conn_ino_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0.172s">
<div class="time" style="width: 4.8464356156664%"></div>
<pre>
    refine (cancelR_conn_map O (to O (x = y)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 116
Time: 0.025s">
<div class="time" style="width: 0.70442378134686%"></div>
<pre>
    refine (conn_map_homotopic O (ap (to O A)) _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 118
Time: 0.008s">
<div class="time" style="width: 0.22541561003099%"></div>
<pre> intros ?; symmetry; by apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 119
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 119
Time: 0.467s">
<div class="time" style="width: 13.158636235559%"></div>
<pre>
      refine (isconnected_equiv O _ (equiv_inverse (hfiber_ap p)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 120
Time: 0.009s">
<div class="time" style="width: 0.25359256128487%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** We will not prove that any of these lemmas are equivalent characterizations of lex-ness, because they are all fairly obvious and we don't yet know of any use for them; [isconnected_paths] is usually strictly easier to prove than they are. *)

  (** Another useful lemma, which is probably not equivalent to lex-ness: any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0.004s">
<div class="time" style="width: 0.1127078050155%"></div>
<pre>Definition ispullback_connmap_mapino_commsq (O : Modality) `{Lex O} {A B C D}
             {f : A -&gt; B} {g : C -&gt; D} {h : A -&gt; C} {k : B -&gt; D}
             `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
             `{MapIn O _ _ h} `{MapIn O _ _ k}
             (p : k o f == g o h)
  : IsPullback p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 131
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 132
Time: 0.033s">
<div class="time" style="width: 0.92983939137785%"></div>
<pre>
    refine (isequiv_conn_ino_map O (pullback_corec p)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 133
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0.007s">
<div class="time" style="width: 0.19723865877712%"></div>
<pre> refine (cancelL_conn_map O (pullback_corec p) (k^* g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 135
Time: 0.138s">
<div class="time" style="width: 3.8884192730347%"></div>
<pre> refine (cancelL_mapinO O _ (equiv_pullback_symm k g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 135
Time: 0.007s">
<div class="time" style="width: 0.19723865877712%"></div>
<pre>
      refine (cancelL_mapinO O _ (g^* k) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 136
Time: 0.004s">
<div class="time" style="width: 0.1127078050155%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 140
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>Global Instance istrunc_O_lex `{Funext} {O : Modality} `{Lex O}
         {n} {A} `{IsTrunc n A}
  : IsTrunc n (O A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 142
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 143
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
    generalize dependent A; simple_induction n n IHn; intros A ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 145
Time: 0.002s">
<div class="time" style="width: 0.056353902507749%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>               (** Already proven for all modalities. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0.035s">
<div class="time" style="width: 0.9861932938856%"></div>
<pre> refine (O_ind (fun x =&gt; forall y, IsTrunc n (x = y)) _); intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0.018s">
<div class="time" style="width: 0.50718512256974%"></div>
<pre>
      refine (O_ind (fun y =&gt; IsTrunc n (to O A x = y)) _); intros y.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 147
Time: 0.019s">
<div class="time" style="width: 0.53536207382361%"></div>
<pre>
      refine (trunc_equiv _ (O_path_cmp O x y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 148
Time: 0.005s">
<div class="time" style="width: 0.14088475626937%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 149
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 151
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We now restrict to lex modalities that are also accessible. *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 153
Time: 0.02s">
<div class="time" style="width: 0.56353902507749%"></div>
<pre>Module Accessible_Lex_Modalities_Theory
       (Os : Modalities)
       (Acc : Accessible_Modalities Os).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 155
Time: 0.115s">
<div class="time" style="width: 3.2403493941955%"></div>
<pre>

  Module Export Acc_Theory := Accessible_Modalities_Theory Os Acc.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 157
Time: 0.027s">
<div class="time" style="width: 0.76077768385461%"></div>
<pre>
  Module Export Lex_Theory := Lex_Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 158
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications [Module Os_Theory := Modalities_Theory Os] that occur in both [Accessible_Modalities_Theory Os Acc] and [Lex_Modalities_Theory Os] create two *different* modules, which appear here as [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory].  Thus, for instance, we have two different definitions [Acc_Theory.Os_Theory.O_ind] and [Lex_Theory.Os_Theory.O_ind], etc.

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in [Modalities_Theory] is opaque, then Coq will be unable to notice that its duplicate copies in [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory] were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, [Inductive] and [Record] definitions, like modules, always create a new object not convertible to any previously existing one.  There are no [Inductive] or [Record] definitions in [Modalities_Theory], but there are [Class] declarations, and these function similarly.  In particular, typeclass search is unable to use [Instance]s defined in [Acc_Theory] to instantiate typeclasses from [Modalities_Theory] (such as [IsConnected]) needed by functions in [Lex_Theory], and vice versa.

  Fortunately, all the typeclasses defined in [Modalities_Theory] are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the [Instance]s from [Acc_Theory] can in fact be typechecked to *belong* to the typeclasses needed by [Lex_Theory], and hence can be supplied explicitly.

  We can also do this once and for all by defining [Instance]s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in [Acc_Theory], so this direction seems likely to be the most useful. *)

 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 170
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>Global Instance isconnected_acc_to_lex {O : Modality} {A : Type}
         {H : Acc_Theory.Os_Theory.IsConnected O A}
            : Lex_Theory.Os_Theory.IsConnected O A
         := H.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 173
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 176
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance inO_typeO `{Univalence} (O : Modality) `{Lex O}
  : In O (Type_ O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 177
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 178
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
    apply (snd (inO_iff_isnull O _)); intros i n; simpl in *.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 179
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
    destruct n; [ exact tt | split ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros P.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Here is the core of the proof: we must show that any family of modal types indexed by a (generating) connected type is equivalent to a constant family.  We take the constant family to be constant at the reflection of the sum of our given family [P]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 183
Time: 0.004s">
<div class="time" style="width: 0.1127078050155%"></div>
<pre>refine (fun u =&gt; (O (sigT P) ; _) ; _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      1:exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 184
Time: 0.005s">
<div class="time" style="width: 0.14088475626937%"></div>
<pre>
      intros x; symmetry; apply path_TypeO; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 185
Time: 0.216s">
<div class="time" style="width: 6.0862214708369%"></div>
<pre>
      refine (path_universe (fun p =&gt; to O _ (x ; p))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 186
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>
      revert x; apply isequiv_from_functor_sigma.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 187
Time: 0.089s">
<div class="time" style="width: 2.5077486615948%"></div>
<pre>
      refine (@isequiv_compose _ _
                (pullback_corec ((fun w:sigT P =&gt; 1)
                                 : const tt o to O (sigT P) == const tt o pr1))
                _ _ (fun w =&gt; (w.2.1 ; w.1)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** And here is the core of why it works: the useful lemma above about detecting pullback squares. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 193
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>+</pre>
</div>
<div class="code" title="File: Lex.v
Line: 193
Time: 0.064s">
<div class="time" style="width: 1.803324880248%"></div>
<pre> refine (ispullback_connmap_mapino_commsq O
                 ((fun w:sigT P =&gt; 1)
                  : const tt o to O (sigT P) == const tt o pr1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 195
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
        (** All the necessary hypotheses are found by typeclass magic! *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 197
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>+</pre>
</div>
<div class="code" title="File: Lex.v
Line: 197
Time: 0.232s">
<div class="time" style="width: 6.5370526908988%"></div>
<pre> refine (@isequiv_compose _ _
                  (equiv_compose
                    (equiv_prod_symm (O (sigT P)) (acc_gen O i))
                    (equiv_pullback_unit_prod (O (sigT P)) (acc_gen O i)))
                  _ _ (equiv_inverse (equiv_sigma_prod0 _ _)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 201
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 202
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 202
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n&gt;0] is actually quite easy, using univalence and the fact that modal types are closed under [Equiv]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 204
Time: 0.006s">
<div class="time" style="width: 0.16906170752325%"></div>
<pre>refine (extendable_postcompose' n _ _ _
                (fun b =&gt; equiv_compose'
                            (equiv_path_TypeO O (A b) (B b))
                            (equiv_path_universe (A b) (B b)))
                _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 208
Time: 0.048s">
<div class="time" style="width: 1.352493660186%"></div>
<pre>
      refine (extendable_conn_map_inO O n (@const (acc_gen O i) Unit tt)
                                      (fun b =&gt; A b &lt;~&gt; B b)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 210
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0.036s">
<div class="time" style="width: 1.0143702451395%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** [inO_typeO] is also an equivalent characterization of lex-ness for a modality.  We will prove this, because it is less obvious, and also more useful. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 215
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition lex_inO_typeO (O : Modality) `{In O (Type_ O)}
  : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 216
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 217
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 218
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_from_elim_to_O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 219
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** The idea is that if [A] is connected and [Type_ O] is modal, then [fun y =&gt; O (x = y) : A -&gt; Type_ O] is constant.  Thus, [to O (x=x) 1] can be transported around to make it contractible everywhere. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 221
Time: 0.001s">
<div class="time" style="width: 0.028176951253874%"></div>
<pre>pose (e := isconnected_elim O (Type_ O)
                 (fun y' =&gt; (O (x = y') ; O_inO _))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 222
Time: 0.003s">
<div class="time" style="width: 0.084530853761623%"></div>
<pre>
    exists (transport idmap (e.2 x @ (e.2 y)^)..1 (to O (x=x) 1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 223
Time: 0.003s">
<div class="time" style="width: 0.084530853761623%"></div>
<pre>
    intros [].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 224
Time: 0.005s">
<div class="time" style="width: 0.14088475626937%"></div>
<pre>
    exact ((transport2 idmap (ap (ap pr1) (concat_pV (e.2 x))) _)^).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 225
Time: 0.017s">
<div class="time" style="width: 0.47900817131586%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 226
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Accessible_Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 229
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

