<html>
<head>
<title>Record.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Record.v</h1>

<div class="code" title="File: Record.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)
(** * Techniques for applying theorems from [Sigma.v] to record types. *)

</pre>
</div>
<div class="code" title="File: Record.v
Line: 3
Time: 0.024s">
<div class="time" style="width: 10.714285714286%"></div>
<pre>Require Import Overture Contractible Equivalences types.Sigma types.Forall.</pre>
</div>
<div class="code" title="File: Record.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Record.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope equiv_scope.</pre>
</div>
<div class="code" title="File: Record.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The following tactic proves automatically that a two-component record type is equivalent to a Sigma-type.  Specifically, it proves a goal that looks like

   { x : A &amp; B x } &lt;~&gt; Some_Record

   You have to give it the record constructor and the two record projections as arguments (it has no way to guess what those might be). *)

</pre>
</div>
<div class="code" title="File: Record.v
Line: 12
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac issig1 build pr1 pr2 :=
  (* What follows is is a bit of Ltac black magic.  We want to give the explicit proof term except for the coherence cell and define that cell afterwards with tactics.  We could do this by calling the tactic [refine] and leaving a placeholder [_] in the term.  However, the following trick seems to be noticably faster, at least when we move on to the 3- and 4-variable versions below. *)
  let T := fresh in
  let t := fresh in
  (* We introduce a new existential variable [T:Type], assert an element [t:T], and substitute away the definition of [T] in the context. *)
  evar (T : Type); assert (t : T); subst T;
  (* At this point we have two subgoals.  The first is to construct [t] whose type is utterly unknown (an existential variable), and the second is to prove our desired equivalence under the additional assumption of [t] (with its unknown type).  We proceed to ignore the first subgoal and supply a term proving the second one, with [t] standing in for the coherence cell.  This enables Coq to infer what the type of [t] must be.  Since existential variables are the only way that Coq can communicate typing information between subgoals, this information then propagates over to the first subgoal. *)
  [ |
  (* Just in case the user supplied a goal which only *reduces* to one of the desired form. *)
  hnf;
  (* Extract the fibration of which our Sigma-type is the total space, as well as the record type. We pull the terms out of a [match], rather than leaving everything inside the [match] because this gives us better error messages. *)
  let fibration := match goal with |- sigT ?fibration &lt;~&gt; ?record =&gt; constr:(fibration) end in
  let record := match goal with |- sigT ?fibration &lt;~&gt; ?record =&gt; constr:(record) end in
  exact (BuildEquiv (sigT fibration) record (fun u =&gt; build u.1 u.2)
    (BuildIsEquiv (sigT fibration) record (fun u =&gt; build u.1 u.2)
      (fun v =&gt; existT fibration (pr1 v) (pr2 v))
      (fun v =&gt;
        let (v1,v2) as v' return (build (pr1 v') (pr2 v') = v')
          := v in 1)
      (fun u =&gt;
        match u return
          (existT fibration
            (pr1 (build (u.1) (u.2)))
            (pr2 (build (u.1) (u.2))))
          = u with
          existT x y =&gt; 1
        end)
      (* We *could* actually give an explicit proof term for the coherence cell.  Here it is:

      (fun u =&gt; match u return
                  ((let (v1,v2) as v' return (build (pr1 v') (pr2 v') = v')
                      := (build u.1 u.2) in 1) =
                  ap (fun u =&gt; build u.1 u.2)
                    (match u return
                       (existT fibration
                         (pr1 (build (u.1) (u.2)))
                         (pr2 (build (u.1) (u.2))))
                       = u with
                       existT x y =&gt; 1
                     end)) with
                  existT x y =&gt; 1
                end)

      However, for the 3- and 4-variable versions, giving the explicit proof term seems to actually *slow down* the tactic.  Perhaps it is because Coq has to infer more implicit arguments.  Thus, we proceed instead by supplying the term [t] whose type is an existential variable. *)
      t)) ];
  (* Now we are left only with the one subgoal to prove [t], and at this point we know its type.  The proof basically amounts to destructing a pair.  First, though, we instruct Coq to incorporate learned values of all unification variables.  This speeds things up significantly (although again, the difference is really only noticable for the 3- and 4-variable versions below). *)
  instantiate;
  simpl;
  let x := fresh in intro x;
  destruct x as [? ?];
  exact 1.</pre>
</div>
<div class="code" title="File: Record.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This allows us to use the same notation for the tactics with varying numbers of variables. *)</pre>
</div>
<div class="code" title="File: Record.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Tactic Notation "issig" constr(build) constr(pr1) constr(pr2) :=
  issig1 build pr1 pr2.</pre>
</div>
<div class="code" title="File: Record.v
Line: 65
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We show how the tactic works in a couple of examples. *)

</pre>
</div>
<div class="code" title="File: Record.v
Line: 68
Time: 0.001s">
<div class="time" style="width: 0.44642857142857%"></div>
<pre>Definition issig_contr (A : Type)
  : { x : A &amp; forall y:A, x = y } &lt;~&gt; Contr A.</pre>
</div>
<div class="code" title="File: Record.v
Line: 69
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Record.v
Line: 70
Time: 0.059s">
<div class="time" style="width: 26.339285714286%"></div>
<pre>
  issig (BuildContr A) (@center A) (@contr A).</pre>
</div>
<div class="code" title="File: Record.v
Line: 71
Time: 0.031s">
<div class="time" style="width: 13.839285714286%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Record.v
Line: 72
Time: 0.001s">
<div class="time" style="width: 0.44642857142857%"></div>
<pre>

Definition issig_equiv (A B : Type)
  : { f : A -&gt; B &amp; IsEquiv f } &lt;~&gt; Equiv A B.</pre>
</div>
<div class="code" title="File: Record.v
Line: 75
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Record.v
Line: 76
Time: 0.143s">
<div class="time" style="width: 63.839285714286%"></div>
<pre>
  issig (BuildEquiv A B) (equiv_fun A B) (equiv_isequiv A B).</pre>
</div>
<div class="code" title="File: Record.v
Line: 77
Time: 0.039s">
<div class="time" style="width: 17.410714285714%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Record.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Here is a version of the [issig] tactic for three-component records, which proves goals that look like

   { x : A &amp; { y : B x &amp; C x y } } &lt;~&gt; Some_Record.

   It takes the record constructor and its three projections as arguments, as before. *)

(* This is the version that is not adjointified.  For 3 or more component records, we first adjointify, for speed. *)
(*
Ltac issig2 build pr1 pr2 pr3 :=
  let T := fresh in
  let t := fresh in
  evar (T : Type); assert (t : T); subst T;
  [ |
  hnf;
  let fibration := match goal with |- sigT (fun u1 =&gt; sigT (@?fibration u1)) &lt;~&gt; ?record =&gt; constr:(fibration) end in
  let record := match goal with |- _ &lt;~&gt; ?record =&gt; constr:(record) end in
  exact (BuildEquiv (sigT (fun u1 =&gt; sigT (fibration u1))) record
                    (fun u =&gt; build u.1 u.2.1 u.2.2)
    (BuildIsEquiv (sigT (fun u1 =&gt; sigT (fibration u1))) record
      (fun u =&gt; build u.1 u.2.1 u.2.2)
      (fun v =&gt;
        (existT (fun x =&gt; sigT (fibration x)) (pr1 v)
          (existT (fibration (pr1 v)) (pr2 v) (pr3 v))))
      (fun v =&gt;
        let (v1,v2,v3) as v' return (build (pr1 v') (pr2 v') (pr3 v') = v')
          := v in 1)
      (fun u =&gt;
        match u return
          (existT (fun u1 =&gt; sigT (fibration u1))
            (pr1 (build u.1 u.2.1 u.2.2))
            (existT (fibration u.1)
              (pr2 (build u.1 u.2.1 u.2.2))
              (pr3 (build u.1 u.2.1 u.2.2))))
          = u with
          existT x (existT y z) =&gt; 1
        end)
      t)) ];
  instantiate;
  simpl;
  let x := fresh in intro x;
  destruct x as [? [? ?]];
  exact 1.
*)</pre>
</div>
<div class="code" title="File: Record.v
Line: 122
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac issig2 build pr1 pr2 pr3 :=
  exact (equiv_adjointify
           (fun u =&gt; build u.1 u.2.1 u.2.2)
           (fun v =&gt; (pr1 v; (pr2 v; pr3 v)))
           (fun v =&gt;
              let (v1,v2,v3) as v' return (build (pr1 v') (pr2 v') (pr3 v') = v')
                  := v in 1)
           eta2_sigma).</pre>
</div>
<div class="code" title="File: Record.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "issig" constr(build) constr(pr1) constr(pr2) constr(pr3) :=
  issig2 build pr1 pr2 pr3.</pre>
</div>
<div class="code" title="File: Record.v
Line: 132
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** And a similar version for four-component records.  It should be clear how to extend the pattern indefinitely. *)
(*
Ltac issig3 build pr1 pr2 pr3 pr4 :=
  let T := fresh in
  let t := fresh in
  evar (T : Type); assert (t : T); subst T;
  [ |
  hnf;
  let fibration := match goal with
                       |- sigT (fun u1 =&gt; sigT (fun u2 =&gt; sigT (@?fibration u1 u2)))
                               &lt;~&gt; ?record =&gt; constr:(fibration) end in
  let record := match goal with |- _ &lt;~&gt; ?record =&gt; constr:(record) end in
  exact (BuildEquiv (sigT (fun u1 =&gt; sigT (fun u2 =&gt; sigT (fibration u1 u2))))
                    record
                    (fun u =&gt; (build u.1 u.2.1 u.2.2.1 u.2.2.2))
    (BuildIsEquiv (sigT (fun u1 =&gt; sigT (fun u2 =&gt; sigT (fibration u1 u2)))) record
      (fun u =&gt; (build u.1 u.2.1 u.2.2.1 u.2.2.2))
      (fun v =&gt;
        (existT (fun x =&gt; sigT (fun y =&gt; sigT (fibration x y))) (pr1 v)
          (existT (fun y =&gt; sigT (fibration (pr1 v) y)) (pr2 v)
            (existT (fibration (pr1 v) (pr2 v)) (pr3 v) (pr4 v)))))
      (fun v =&gt;
        let (v1,v2,v3,v4) as v'
          return (build (pr1 v') (pr2 v') (pr3 v') (pr4 v') = v')
          := v in 1)
      (fun u =&gt;
        match u return
          (existT (fun u1 =&gt; sigT (fun u2 =&gt; sigT (fibration u1 u2)))
            (pr1 (build u.1 u.2.1 u.2.2.1 u.2.2.2))
            (existT (fun u2 =&gt; sigT (fibration u.1 u2))
              (pr2 (build u.1 u.2.1 u.2.2.1 u.2.2.2))
              (existT (fibration u.1 u.2.1)
                (pr3 (build u.1 u.2.1 u.2.2.1 u.2.2.2))
                (pr4 (build u.1 u.2.1 u.2.2.1 u.2.2.2)))))
          = u with
          existT x (existT y (existT z w)) =&gt; 1
        end)
      t)) ];
  instantiate;
  simpl;
  let x := fresh in intro x;
  destruct x as [? [? [? ?]]];
  exact 1.
*)</pre>
</div>
<div class="code" title="File: Record.v
Line: 177
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac issig3 build pr1 pr2 pr3 pr4 :=
  exact (equiv_adjointify
           (fun u =&gt; build u.1 u.2.1 u.2.2.1 u.2.2.2)
           (fun v =&gt; (pr1 v; (pr2 v; (pr3 v; pr4 v))))
           (fun v =&gt;
              let (v1,v2,v3,v4) as v' return (build (pr1 v') (pr2 v') (pr3 v') (pr4 v') = v')
                  := v in 1)
           eta3_sigma).</pre>
</div>
<div class="code" title="File: Record.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "issig" constr(build) constr(pr1) constr(pr2) constr(pr3) constr(pr4) :=
  issig3 build pr1 pr2 pr3 pr4.</pre>
</div>
<div class="code" title="File: Record.v
Line: 187
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The record [IsEquiv] has four components, so [issig3] can prove that it is equivalent to an iterated Sigma-type. *)

</pre>
</div>
<div class="code" title="File: Record.v
Line: 190
Time: 0.003s">
<div class="time" style="width: 1.3392857142857%"></div>
<pre>Definition issig_isequiv {A B : Type} (f : A -&gt; B) :
  { g:B-&gt;A &amp; { r:Sect g f &amp; { s:Sect f g &amp; forall x : A, r (f x) = ap f (s x) }}}
  &lt;~&gt; IsEquiv f.</pre>
</div>
<div class="code" title="File: Record.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Record.v
Line: 193
Time: 0.224s">
<div class="time" style="width: 100%"></div>
<pre>
  issig (BuildIsEquiv A B f) (@equiv_inv A B f) (@eisretr A B f)
    (@eissect A B f) (@eisadj A B f).</pre>
</div>
<div class="code" title="File: Record.v
Line: 195
Time: 0.048s">
<div class="time" style="width: 21.428571428571%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Record.v
Line: 197
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

