<html>
<head>
<title>Forall.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Forall.v</h1>

<div class="code" title="File: Forall.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)
(** * Theorems about dependent products *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 3
Time: 0.017s">
<div class="time" style="width: 62.962962962963%"></div>
<pre>Require Import HoTT.Basics.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 3
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
Require Import types.Paths.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope equiv_scope.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Generalizable Variables A B f g e n.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 9
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Section AssumeFunext.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 11
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Context `{Funext}.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 12
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Paths *)

(** Paths [p : f = g] in a function type [forall x:X, P x] are equivalent to functions taking values in path types, [H : forall x:X, f x = g x], or concisely, [H : f == g].

This equivalence, however, is just the combination of [apD10] and function extensionality [funext], and as such, [path_forall], et seq. are given in the [Overture]:  *)

(** Now we show how these things compute. *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 21
Time: 0.004s">
<div class="time" style="width: 14.814814814815%"></div>
<pre>Definition apD10_path_forall `{P : A -&gt; Type}
  (f g : forall x, P x) (h : f == g)
  : apD10 (path_forall _ _ h) == h
  := apD10 (eisretr apD10 h).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 24
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>

Definition eta_path_forall `{P : A -&gt; Type}
  (f g : forall x, P x) (p : f = g)
  : path_forall _ _ (apD10 p) = p
  := eissect apD10 p.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 29
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>

Definition path_forall_1 `{P : A -&gt; Type} (f : forall x, P x)
  : (path_forall f f (fun x =&gt; 1)) = 1
  := eta_path_forall f f 1.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The identification of the path space of a dependent function space, up to equivalence, is of course just funext. *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 36
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>Global Instance isequiv_path_forall `{P : A -&gt; Type} (f g : forall x, P x)
  : IsEquiv (path_forall f g) | 0
  := @isequiv_inverse _ _ (@apD10 A P f g) _.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 38
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>

Definition equiv_path_forall `{P : A -&gt; Type} (f g : forall x, P x)
  : (f == g)  &lt;~&gt;  (f = g)
  := BuildEquiv _ _ (path_forall f g) _.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Transport *)

(** The concrete description of transport in sigmas and pis is rather trickier than in the other types. In particular, these cannot be described just in terms of transport in simpler types; they require the full Id-elim rule by way of "dependent transport" [transportD].

  In particular this indicates why "transport" alone cannot be fully defined by induction on the structure of types, although Id-elim/transportD can be (cf. Observational Type Theory). A more thorough set of lemmas, along the lines of the present ones but dealing with Id-elim rather than just transport, might be nice to have eventually? *)</pre>
</div>
<div class="code" title="File: Forall.v
Line: 48
Time: 0.014s">
<div class="time" style="width: 51.851851851852%"></div>
<pre>Definition transport_forall
  {A : Type} {P : A -&gt; Type} {C : forall x, P x -&gt; Type}
  {x1 x2 : A} (p : x1 = x2) (f : forall y : P x1, C x1 y)
  : (transport (fun x =&gt; forall y : P x, C x y) p f)
    == (fun y =&gt;
       transport (C x2) (transport_pV _ _ _) (transportD _ _ p _ (f (p^ # y))))
  := match p with idpath =&gt; fun _ =&gt; 1 end.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A special case of [transport_forall] where the type [P] does not depend on [A],
    and so it is just a fixed type [B]. *)</pre>
</div>
<div class="code" title="File: Forall.v
Line: 57
Time: 0.005s">
<div class="time" style="width: 18.518518518519%"></div>
<pre>Definition transport_forall_constant
  {A B : Type} {C : A -&gt; B -&gt; Type}
  {x1 x2 : A} (p : x1 = x2) (f : forall y : B, C x1 y)
  : (transport (fun x =&gt; forall y : B, C x y) p f)
    == (fun y =&gt; transport (fun x =&gt; C x y) p (f y))
  := match p with idpath =&gt; fun _ =&gt; 1 end.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Maps on paths *)

(** The action of maps given by lambda. *)</pre>
</div>
<div class="code" title="File: Forall.v
Line: 66
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>Definition ap_lambdaD {A B : Type} {C : B -&gt; Type} {x y : A} (p : x = y) (M : forall a b, C b) :
  ap (fun a b =&gt; M a b) p =
  path_forall _ _ (fun b =&gt; ap (fun a =&gt; M a b) p).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 68
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 69
Time: 0.004s">
<div class="time" style="width: 14.814814814815%"></div>
<pre>
  destruct p;
  symmetry;
  simpl; apply path_forall_1.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 72
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Dependent paths *)

(** Usually, a dependent path over [p:x1=x2] in [P:A-&gt;Type] between [y1:P x1] and [y2:P x2] is a path [transport P p y1 = y2] in [P x2].  However, when [P] is a function space, these dependent paths have a more convenient description: rather than transporting the argument of [y1] forwards and backwards, we transport only forwards but on both sides of the equation, yielding a "naturality square". *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 78
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>Definition dpath_forall `{Funext}
  {A:Type} (B:A -&gt; Type) (C:forall a, B a -&gt; Type) (x1 x2:A) (p:x1=x2)
  (f:forall y1:B x1, C x1 y1) (g:forall (y2:B x2), C x2 y2)
  : (forall (y1:B x1), transportD B C p y1 (f y1) = g (transport B p y1))
  &lt;~&gt;
  (transport (fun x =&gt; forall y:B x, C x y) p f = g).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 83
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 84
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 85
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
  apply equiv_path_forall.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 86
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 87
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Functorial action *)

(** The functoriality of [forall] is slightly subtle: it is contravariant in the domain type and covariant in the codomain, but the codomain is dependent on the domain. *)</pre>
</div>
<div class="code" title="File: Forall.v
Line: 91
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>Definition functor_forall `{P : A -&gt; Type} `{Q : B -&gt; Type}
    (f0 : B -&gt; A) (f1 : forall b:B, P (f0 b) -&gt; Q b)
  : (forall a:A, P a) -&gt; (forall b:B, Q b)
  := (fun g b =&gt; f1 _ (g (f0 b))).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 94
Time: 0.004s">
<div class="time" style="width: 14.814814814815%"></div>
<pre>

Definition ap_functor_forall `{P : A -&gt; Type} `{Q : B -&gt; Type}
    (f0 : B -&gt; A) (f1 : forall b:B, P (f0 b) -&gt; Q b)
    (g g' : forall a:A, P a) (h : g == g')
  : ap (functor_forall f0 f1) (path_forall _ _ h)
    = path_forall _ _ (fun b:B =&gt; (ap (f1 b) (h (f0 b)))).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 101
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
  revert h.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 102
Time: 0.006s">
<div class="time" style="width: 22.222222222222%"></div>
<pre>  equiv_intro (@apD10 A P g g') h.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 102
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>
  destruct h.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  simpl.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 103
Time: 0.005s">
<div class="time" style="width: 18.518518518519%"></div>
<pre>
  transitivity (idpath (functor_forall f0 f1 g)).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Forall.v
Line: 105
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre> exact (ap (ap (functor_forall f0 f1)) (path_forall_1 g)).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Forall.v
Line: 106
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre> symmetry.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 106
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  apply path_forall_1.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 106
Time: 0.008s">
<div class="time" style="width: 29.62962962963%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Equivalences *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 110
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>Global Instance isequiv_functor_forall `{P : A -&gt; Type} `{Q : B -&gt; Type}
  `{IsEquiv B A f} `{forall b, @IsEquiv (P (f b)) (Q b) (g b)}
  : IsEquiv (functor_forall f g) | 1000.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 113
Time: 0.013s">
<div class="time" style="width: 48.148148148148%"></div>
<pre>
  refine (isequiv_adjointify (functor_forall f g)
    (functor_forall (f^-1)
      (fun (x:A) (y:Q (f^-1 x)) =&gt; eisretr f x # (g (f^-1 x))^-1 y
      )) _ _);
  intros h.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Forall.v
Line: 119
Time: 0.027s">
<div class="time" style="width: 100%"></div>
<pre> abstract (
        apply path_forall; intros b; unfold functor_forall;
        rewrite eisadj;
        rewrite &lt;- transport_compose;
        rewrite ap_transport;
        rewrite eisretr;
        apply apD
      ).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Forall.v
Line: 127
Time: 0.011s">
<div class="time" style="width: 40.740740740741%"></div>
<pre> abstract (
        apply path_forall; intros a; unfold functor_forall;
        rewrite eissect;
        apply apD
      ).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 131
Time: 0.014s">
<div class="time" style="width: 51.851851851852%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 132
Time: 0.006s">
<div class="time" style="width: 22.222222222222%"></div>
<pre>

Definition equiv_functor_forall `{P : A -&gt; Type} `{Q : B -&gt; Type}
  (f : B -&gt; A) `{IsEquiv B A f}
  (g : forall b, P (f b) -&gt; Q b)
  `{forall b, @IsEquiv (P (f b)) (Q b) (g b)}
  : (forall a, P a) &lt;~&gt; (forall b, Q b)
  := BuildEquiv _ _ (functor_forall f g) _.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 139
Time: 0.005s">
<div class="time" style="width: 18.518518518519%"></div>
<pre>

Definition equiv_functor_forall' `{P : A -&gt; Type} `{Q : B -&gt; Type}
  (f : B &lt;~&gt; A) (g : forall b, P (f b) &lt;~&gt; Q b)
  : (forall a, P a) &lt;~&gt; (forall b, Q b)
  := equiv_functor_forall f g.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 144
Time: 0.004s">
<div class="time" style="width: 14.814814814815%"></div>
<pre>

Definition equiv_functor_forall_id `{P : A -&gt; Type} `{Q : A -&gt; Type}
  (g : forall a, P a &lt;~&gt; Q a)
  : (forall a, P a) &lt;~&gt; (forall a, Q a)
  := equiv_functor_forall (equiv_idmap A) g.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 149
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Truncatedness: any dependent product of n-types is an n-type *)

</pre>
</div>
<div class="code" title="File: Forall.v
Line: 152
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance contr_forall `{P : A -&gt; Type} `{forall a, Contr (P a)}
  : Contr (forall a, P a) | 100.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 154
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
  exists (fun a =&gt; center (P a)).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 155
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro f.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  apply path_forall.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  intro a.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  apply contr.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 156
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 157
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Global Instance trunc_forall `{P : A -&gt; Type} `{forall a, IsTrunc n (P a)}
  : IsTrunc n (forall a, P a) | 100.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 161
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  generalize dependent P.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  induction n as [ | n' IH]; simpl; intros P ?.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 163
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (* case [n = -2], i.e. contractibility *)
 </pre>
</div>
<div class="code" title="File: Forall.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Forall.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (* case n = n'.+1 *)
 </pre>
</div>
<div class="code" title="File: Forall.v
Line: 167
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Forall.v
Line: 167
Time: 0.006s">
<div class="time" style="width: 22.222222222222%"></div>
<pre> intros f g; apply (trunc_equiv (apD10 ^-1)).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 167
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** ** Symmetry of curried arguments *)

(** Using the standard Haskell name for this, as it’s a handy utility function.

Note: not sure if [P] will usually be deducible, or whether it would be better explicit. *)</pre>
</div>
<div class="code" title="File: Forall.v
Line: 175
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>Definition flip `{P : A -&gt; B -&gt; Type}
  : (forall a b, P a b) -&gt; (forall b a, P a b)
  := fun f b a =&gt; f a b.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 177
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>

Global Instance isequiv_flip `{P : A -&gt; B -&gt; Type}
  : IsEquiv (@flip _ _ P) | 0.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  set (flip_P := @flip _ _ P).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  set (flip_P_inv := @flip _ _ (flip P)).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 183
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
  set (flip_P_is_sect := (fun f =&gt; 1) : Sect flip_P flip_P_inv).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 184
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  set (flip_P_is_retr := (fun g =&gt; 1) : Sect flip_P_inv flip_P).</pre>
</div>
<div class="code" title="File: Forall.v
Line: 185
Time: 0.001s">
<div class="time" style="width: 3.7037037037037%"></div>
<pre>
  exists flip_P_inv flip_P_is_retr flip_P_is_sect.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro g.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 187
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  exact 1.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 187
Time: 0.003s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 188
Time: 0.002s">
<div class="time" style="width: 7.4074074074074%"></div>
<pre>

Definition equiv_flip `(P : A -&gt; B -&gt; Type)
  : (forall a b, P a b) &lt;~&gt; (forall b a, P a b)
  := BuildEquiv _ _ (@flip _ _ P) _.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 192
Time: 0.014s">
<div class="time" style="width: 51.851851851852%"></div>
<pre>

End AssumeFunext.</pre>
</div>
<div class="code" title="File: Forall.v
Line: 195
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

