<html>
<head>
<title>Truncations.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Truncations.v</h1>

<div class="code" title="File: Truncations.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)

(** * Truncations of types, in all dimensions. *)

</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 4
Time: 0.1s">
<div class="time" style="width: 52.631578947368%"></div>
<pre>Require Import HoTT.Basics Types.Sigma ReflectiveSubuniverse Modality TruncType HProp.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope equiv_scope.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable Variables A X n.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 7
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Definition. *)

(** The definition of [Trunc n], the n-truncation of a type.

If Coq supported higher inductive types natively, we would construct this as somthing like:

   Inductive Trunc n (A : Type) : Type :=
   | tr : A -&gt; Trunc n A
   | istrunc_truncation : forall (f : Sphere n.+1 -&gt; Trunc n A)
       (x : Sphere n.+1), f x = f North.

However, while we are faking our higher-inductives anyway, we can take some shortcuts, rather than translating the definition above.  Firstly, we directly posit a “constructor” giving truncatedness, rather than rephrasing it in terms of maps of spheres.  Secondly, we omit the “computation rule” for this constructor, since it is implied by truncatedness of the result type (and, for essentially that reason, is never wanted in practice anyway).
*)

</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 22
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Export Trunc.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 22
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Delimit Scope trunc_scope with trunc.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Private Inductive Trunc (n : trunc_index) (A :Type) : Type :=
  tr : A -&gt; Trunc n A.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Bind Scope trunc_scope with Trunc.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Arguments tr {n A} a.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Without explicit universe parameters, this instance is insufficiently polymorphic. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance istrunc_truncation (n : trunc_index) (A : Type@{i})
: IsTrunc@{j} n (Trunc@{i} n A).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Admitted.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 32
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>

Definition Trunc_ind {n A}
  (P : Trunc n A -&gt; Type) {Pt : forall aa, IsTrunc n (P aa)}
  : (forall a, P (tr a)) -&gt; (forall aa, P aa)
:= (fun f aa =&gt; match aa with tr a =&gt; fun _ =&gt; f a end Pt).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 37
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Trunc.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The non-dependent version of the eliminator. *)

</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 42
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>Definition Trunc_rec {n A X} `{IsTrunc n X}
  : (A -&gt; X) -&gt; (Trunc n A -&gt; X)
:= Trunc_ind (fun _ =&gt; X).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Trunc is a modality *)

</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Section TruncationModality.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Context (n : trunc_index).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Without a universe annotation here, the two universe parameters of [Modality] get collapsed. *)
 </pre>
</div>
<div class="code" title="File: Truncations.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition Tr : Modality@{sm lg}.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 52
Time: 0.19s">
<div class="time" style="width: 100%"></div>
<pre>
    refine (Build_Modality
              (Build_UnitSubuniverse
                 (Trunc@{sm} n)
                 (IsTrunc@{lg} n)
                 _
                 (@tr n)
                 (** Again, we have to use [Lift'] to prevent the universes from getting collapsed. *)
                 (fun A B Atr f feq =&gt;
                    (@trunc_equiv (Lift'@{sm lg} A) (Lift'@{sm lg} B)
                                  (lift'@{sm lg} o f o lift'@{sm lg}^-1) n _ _))
                 _)
              (@Trunc_ind n)
              (fun A B B_inO f a =&gt; 1)
              _); cbn; try exact _.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 66
Time: 0.038s">
<div class="time" style="width: 20%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 67
Time: 0.005s">
<div class="time" style="width: 2.6315789473684%"></div>
<pre>

  Definition trunc_iff_isequiv_truncation (A : Type)
  : IsTrunc n A &lt;-&gt; IsEquiv (@tr n A)
  := @inO_iff_isequiv_to_O Tr A.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 71
Time: 0.002s">
<div class="time" style="width: 1.0526315789474%"></div>
<pre>

  Global Instance isequiv_tr A `{IsTrunc n A} : IsEquiv (@tr n A)
  := fst (trunc_iff_isequiv_truncation A) _.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 74
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>

  Definition equiv_tr (A : Type) `{IsTrunc n A}
  : A &lt;~&gt; Trunc n A
  := BuildEquiv _ _ (@tr n A) _.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 78
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>

  Definition untrunc_istrunc {A : Type} `{IsTrunc n A}
  : Trunc n A -&gt; A
  := (@tr n A)^-1.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** ** Functoriality *)

  (* This ought to be [O_functor], but currently that would be insufficiently universe polymorphic. *)
 </pre>
</div>
<div class="code" title="File: Truncations.v
Line: 87
Time: 0.002s">
<div class="time" style="width: 1.0526315789474%"></div>
<pre>Definition Trunc_functor {X Y} (f : X -&gt; Y)
  : Trunc n X -&gt; Trunc n Y
  := Trunc_rec (tr o f).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 89
Time: 0.012s">
<div class="time" style="width: 6.3157894736842%"></div>
<pre>

  Definition Trunc_functor_compose {X Y Z} (f : X -&gt; Y) (g : Y -&gt; Z)
  : Trunc_functor (g o f) == Trunc_functor g o Trunc_functor f
  := O_functor_compose Tr f g.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 93
Time: 0.006s">
<div class="time" style="width: 3.1578947368421%"></div>
<pre>

  Definition Trunc_functor_idmap (X : Type)
  : @Trunc_functor X X idmap == idmap
  := O_functor_idmap Tr X.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 97
Time: 0.007s">
<div class="time" style="width: 3.6842105263158%"></div>
<pre>

  Definition isequiv_Trunc_functor {X Y} (f : X -&gt; Y) `{IsEquiv _ _ f}
  : IsEquiv (Trunc_functor f)
  := isequiv_O_functor Tr f.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 101
Time: 0.005s">
<div class="time" style="width: 2.6315789473684%"></div>
<pre>

  Definition equiv_Trunc_prod_cmp `{Funext} {X Y}
  : Trunc n (X * Y) &lt;~&gt; Trunc n X * Trunc n Y
  := equiv_O_prod_cmp Tr X Y.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 105
Time: 0.013s">
<div class="time" style="width: 6.8421052631579%"></div>
<pre>

End TruncationModality.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This coercion allows us to use truncation indices where a modality is expected and refer to the corresponding truncation modality.  For instance, the general theory of O-connected maps specializes to the theory of n-connected maps. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 109
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Coercion Tr : trunc_index &gt;-&gt; Modality.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 109
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We have to teach Coq to translate back and forth between [IsTrunc n] and [In (Tr n)]. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 111
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>Global Instance inO_tr_istrunc {n : trunc_index} (A : Type) `{IsTrunc n A}
: In (Tr n) A.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 113
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 114
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Having both of these as [Instance]s would cause infinite loops. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 117
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>Definition istrunc_inO_tr {n : trunc_index} (A : Type) `{In (Tr n) A}
: IsTrunc n A.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 119
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>
  assumption.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 120
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 121
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Instead, we make the latter an immediate instance. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Hint Immediate istrunc_inO_tr : typeclass_instances.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Unfortunately, this isn't perfect; Coq still can't always find [In Tr] hypotheses in the context when it wants [IsTrunc]. *)


(** It's sometimes convenient to use "infinity" to refer to the identity modality in a similar way.  This clashes with some uses in higher topos theory, where "oo-truncated" means instead "hypercomplete", but this has not yet been a big problem. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 128
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation oo := purely.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 128
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** A few special things about the (-1)-truncation. *)

</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 131
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Open Scope trunc_scope.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 131
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This definition is doubly sneaky.  Firstly, we define [merely A] to be an inhabitant of the universe [hProp] of hprops, rather than a type.  We can always treat it as a type because there is a coercion, but this means that if we need an element of [hProp] then we don't need a separate name for it.  Secondly, rather than define it as [Trunc -1] we define it as [Tr -1], the action of the truncation modality.  These are of course judgmentally equal, but choosing the latter means that Coq has an easier time applying general modality theorems to it. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 133
Time: 0.004s">
<div class="time" style="width: 2.1052631578947%"></div>
<pre>Definition merely A : hProp := BuildhProp (Tr -1 A).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 133
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>

Definition hexists {X} (P : X -&gt; Type) : hProp := merely (sigT P).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 135
Time: 0.002s">
<div class="time" style="width: 1.0526315789474%"></div>
<pre>

Definition hor (P Q : Type) : hProp := merely (P + Q).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition contr_inhab_prop {A} `{IsHProp A} (ma : merely A) : Contr A.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 139
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 140
Time: 0.024s">
<div class="time" style="width: 12.631578947368%"></div>
<pre>
  refine (@contr_trunc_conn -1 A _ _); try assumption.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 141
Time: 0.009s">
<div class="time" style="width: 4.7368421052632%"></div>
<pre>
  refine (contr_inhabited_hprop _ ma).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 142
Time: 0.004s">
<div class="time" style="width: 2.1052631578947%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 143
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Surjections are the (-1)-connected maps, but they can be characterized more simply since an inhabited hprop is automatically contractible. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation IsSurjection := (IsConnMap -1).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 145
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>

Definition BuildIsSurjection {A B} (f : A -&gt; B) :
  (forall b, merely (hfiber f b)) -&gt; IsSurjection f.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 148
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 149
Time: 0.004s">
<div class="time" style="width: 2.1052631578947%"></div>
<pre>
  intros H b; refine (contr_inhabited_hprop _ _).</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 150
Time: 0.005s">
<div class="time" style="width: 2.6315789473684%"></div>
<pre>
  apply H.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 151
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 152
Time: 0.001s">
<div class="time" style="width: 0.52631578947368%"></div>
<pre>

Definition isequiv_surj_emb {A B} (f : A -&gt; B)
           `{IsSurjection f} `{IsEmbedding f}
: IsEquiv f.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 157
Time: 0.003s">
<div class="time" style="width: 1.5789473684211%"></div>
<pre>
  apply (@isequiv_conn_ino_map -1); assumption.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 158
Time: 0.002s">
<div class="time" style="width: 1.0526315789474%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 159
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** ** Tactic to remove truncations in hypotheses if possible. *)</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac strip_truncations :=
  (** search for truncated hypotheses *)
  progress repeat match goal with
                    | [ T : _ |- _ ]
                      =&gt; revert T;
                        refine (@Trunc_ind _ _ _ _ _);
                        (** ensure that we didn't generate more than one subgoal, i.e. that the goal was appropriately truncated *)
                        [];
                        intro T
                  end.</pre>
</div>
<div class="code" title="File: Truncations.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

