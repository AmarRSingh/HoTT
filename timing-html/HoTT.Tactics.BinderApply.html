<html>
<head>
<title>BinderApply.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for BinderApply.v</h1>

<div class="code" title="File: BinderApply.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(** * Apply a lemma under binders *)</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 1
Time: 0.009s">
<div class="time" style="width: 100%"></div>
<pre>Require Import Overture.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
(** There are some cases where [apply lem] will fail, but [intros; apply lem] will succeed.  The tactic [binder apply] is like [intros; apply lem], but it cleans up after itself by [revert]ing the things it introduced.  The tactic [binder apply lem in H] is to [binder apply lem], as [apply lem in H] is to [apply lem].  Note, however, that the implementation of [binder apply lem in H] is completely different and significantly more complicated. *)

(** The tactic [eval_in tac H] generalizes [eval tac in H] to things other than [cbv]-like tactics and [pattern] (e.g., to [rewrite]).  Unfortunately, it does not generalize [eval pattern in H], because we have no way to say "only beta-reduce the first application", and otherwise the [pose] gets in the way.  There's a feature request to support the syntax [eval tac in H] at https://coq.inria.fr/bugs/show_bug.cgi?id=3677.  The [eval_in_using] variant allows solving side-conditions with a user-specified tactic.  *)</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac eval_in_using tac_in using_tac H :=
  (** We create a fresh goal with the [constr:($(...)$)] pattern, so we don't modify the existing context, and so we can get our hands on a proof term corresponding to the stateful modification.  We pose [H] in the fresh context so we can play with it nicely, regardless of if it's a hypothesis or a term.  Then we run [tac_in] on the hypothesis to modify it, use [exact] to "return" the modified hypothesis, and give a nice error message if [using_tac] fails to solve some side-condition. *)
  let ret := constr:($(let H' := fresh in
                       pose H as H';
                       tac_in H';
                       [ exact H'
                       | solve [ using_tac
                               | let G := match goal with |- ?G =&gt; constr:(G) end in
                                 repeat match goal with H : _ |- _ =&gt; revert H end;
                                   let G' := match goal with |- ?G =&gt; constr:(G) end in
                                   fail 1
                                        "Cannot use" using_tac "to solve side-condition goal" G "."
                                        "Extended goal with context:" G' ].. ])$) in
  (** We play some games to format the return nicely; we want to zeta-reduce the let-in generated by [pose], but not any other [let-in]s.  (N.B. [pose]/[exact] also results in an extra [idmap]; we remove this with [cbv beta].)  We settle for zeta-reducing only this let-in, but beta-reducing everything.  Perhaps we want to zeta-reduce everything, and not beta-reduce anything instead? *)
  let T := type of ret in
  let ret' := (lazymatch ret with
              | let x := ?x' in @?P x =&gt; constr:(P x')
               end) in
  let ret'' := (eval cbv beta in ret') in
  constr:(ret'' : T).</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac eval_in tac_in H := eval_in_using tac_in idtac H.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Example eval_in_example : forall A B : Set, A = B -&gt; A -&gt; B.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros A B H a.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 29
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
  let x := (eval_in ltac:(fun H' =&gt; rewrite H in H') a) in
  pose x as b.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** we get a [b : B] *)
  (** We [Abort], so that we don't get an extra constant floating around. *)
Abort.

Ltac can_binder_apply apply_tac fail1_tac :=
  first [ test apply_tac
        | test (intro; can_binder_apply apply_tac fail1_tac)
        | fail1_tac ].</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac binder_apply apply_tac fail1_tac :=
  can_binder_apply apply_tac fail1_tac;
  first [ apply_tac
        | let H := fresh in
          intro H;
            binder_apply apply_tac fail1_tac;
            revert H
        | fail 1 "Cannot re-revert some introduced hypothesis" ].</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The tactic [eval_under_binders tac H] is equivalent to [tac H] if [H] is not a product (lambda-abstraction), and roughly equivalent to the constr [fun x =&gt; eval_under_binders tac (H x)] if [H] is a product. *)</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac eval_under_binders tac H :=
  (** Bind a convenient name for the recursive call *)
  let rec_tac := eval_under_binders tac in
  (** If the hypothesis is a product ([forall]), we want to recurse under binders; if not, we're in the base case, and we simply compute the new term.  We use [match] rather than [lazymatch] so that if the tactic fails to apply under all of the binders, we try again under fewer binders.  We want to try first under as many binders as possible, in case the tactic, e.g., instantiates extra binders with evars. *)
  match type of H with
      (** Standard pattern for recursing under binders.  We zeta-expand to work around https://coq.inria.fr/bugs/show_bug.cgi?id=3248 and https://coq.inria.fr/bugs/show_bug.cgi?id=3458; we'd otherwise need globally unique name for [x].  We zeta-reduce afterwards so the user doesn't see our zeta-expansion.  We use [x] in both the pattern and the returned constructor so that we preserve the given name for the binder.  *)
    | forall x : ?T, @?P x
      =&gt; let ret := constr:(fun x : T =&gt;
                              let Hx := H x in
                              $(let ret' := rec_tac Hx in
                                exact ret')$) in
         let ret' := (eval cbv zeta in ret) in
         constr:(ret')
    (** Base case - simply return [tac H]  *)
    | _ =&gt; tac H
  end.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 63
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The tactic [make_tac_under_binders_using_in tac using_tac H] uses [tac] to transform a term [H], solving side-conditions (e.g., if [tac] uses [apply]) with [using_tac].  It returns the updated version of [H] as a constr; if [H] is a hypothesis in the context, it does not modify it.  Conceptually, [make_tac_under_binders_using_in tac idtac H] is the composition of two tactics: a [transform_under_binders : (constr -&gt; constr) -&gt; (constr -&gt; constr)] that runs a tactic under the binders of the constr it's given, and what would be an [eval tac in H], except for the fact that, e.g., [eval rewrite in H] doesn't actually work because it predates tactics in terms (we use [eval_in_using tac using_tac H] instead).

    The arguments are:

    - [tac] - should take the name of a hypothesis, and modify that hypothesis in place.  It could, for example, be [fun H =&gt; rewrite lem in H] to do the [rewrite H] under binders.

    - [using_tac] - used to solve any side-conditions that [tac] generates.  Not strictly necessary, since [tac] can always solve its own side-conditions, but it's sometimes convenient to instantiate [tac] with [fun H =&gt; eapply lem in H] or something, and solve the side-conditions with [eassumption].

    - [H] - the name of the hypothesis to start from.

    N.B. We do not require [Funext] to use this tactic; [Funext] would only required to relate the term returned by this tactic and the original term.  Note also that we only rewrite under top-level binders (e.g., under the [x] in a hypothesis of type [forall x, P x], but not under the [x] in a hypothesis of type [(fun x y =&gt; x + y) = (fun x y =&gt; y + x)]). *)</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 75
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac make_tac_under_binders_using_in tac using_tac H :=
  eval_under_binders ltac:(fun H' =&gt; eval_in_using tac using_tac H') H.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 76
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Ltac do_tac_under_binders_using_in tac using_tac H :=
  let H' := make_tac_under_binders_using_in tac using_tac H in
  let H'' := fresh in
  pose proof H' as H'';
    clear H;
    rename H'' into H.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 83
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "constrbinder" "apply" constr(lem) "in" constr(H) "using" tactic3(tac)
  := make_tac_under_binders_using_in ltac:(fun H' =&gt; apply lem in H') tac H.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 86
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "constrbinder" "eapply" open_constr(lem) "in" constr(H) "using" tactic3(tac)
  := constrbinder apply lem in H using tac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 88
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "binder" "apply" constr(lem) "in" constr(H) "using" tactic3(tac)
  := do_tac_under_binders_using_in ltac:(fun H' =&gt; apply lem in H') tac H.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 91
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "binder" "eapply" open_constr(lem) "in" constr(H) "using" tactic3(tac)
  := binder apply lem in H using tac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "constrbinder" "apply" constr(lem) "in" constr(H) := constrbinder apply lem in H using idtac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "constrbinder" "eapply" open_constr(lem) "in" constr(H) := constrbinder eapply lem in H using idtac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "binder" "apply" constr(lem) := binder_apply ltac:(apply lem) ltac:(fail 1 "Cannot apply" lem).</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "binder" "eapply" open_constr(lem) := binder_apply ltac:(eapply lem) ltac:(fail 1 "Cannot eapply" lem).</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Tactic Notation "binder" "apply" constr(lem) "in" constr(H) := binder apply lem in H using idtac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 101
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Tactic Notation "binder" "eapply" open_constr(lem) "in" constr(H) := binder eapply lem in H using idtac.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 102
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>

Example basic_goal {A B C} (HA : forall x : A, B x) (HB : forall x : A, B x -&gt; C x) : forall x : A, C x.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** If we try to [apply HB], wanting to replace [C] with [B], we get an error about being unable to unify [B ?] with [A]. *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Fail apply HB.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 107
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** The tactic [binder apply] fixes this shortcoming. *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 109
Time: 0.001s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>binder apply HB.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 109
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  exact HA.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 110
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** We [Abort], so that we don't get an extra constant floating around. *)
Abort.

Example basic {A B C} (HA : forall x : A, B x) (HB : forall x : A, B x -&gt; C x) : forall x : A, C x.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Proof.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** If we try to [apply HB in HA], wanting to replace [B] with [C], we get an error about being unable to instantiate the argument of type [A]: "Error: Unable to find an instance for the variable x." *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 116
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Fail apply HB in HA.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 116
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** The tactic [binder apply] fixes this shortcoming. *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 118
Time: 0.002s">
<div class="time" style="width: 22.222222222222%"></div>
<pre>binder apply HB in HA.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  exact HA.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 119
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** We [Abort], so that we don't get an extra constant floating around. *)
Abort.

Example ex_funext `{Funext} {A} f g
        (H' : forall x y z w : A, f x y z w = g x y z w :&gt; A)
: f = g.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Proof.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** We need to apply [path_forall] under binders five times in [H'].  We use a different variant each time to demonstrate the various ways of using this tactic.  In a normal proof, you'd probably just do [do 4 binder apply (@path_forall _) in H'] or just [repeat binder apply (@path_forall _) in H']. *)
  (** If we do [binder apply path_forall in H'], we are told that Coq can't infer the argument [A] to [path_forall].  Instead, we can [binder eapply] it, to tell Coq to defer inference and use an evar for now. *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 128
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Fail binder apply path_forall in H'.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 128
Time: 0.005s">
<div class="time" style="width: 55.555555555556%"></div>
<pre>
  binder eapply path_forall in H'.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** Alternatively, we can make [A] explicit.  But then we get an error about not being able to resolve the instance of [Funext].  We can either tell Coq to solve the side condition using the [assumption] tactic (or [typeclasses eauto], for that matter), or we can have typeclass inference run when we construct the lemma to apply. *)
  (** Some versions of Proof General are bad about noticing [Fail] within a tactic; see http://proofgeneral.inf.ed.ac.uk/trac/ticket/494.  So we comment this one out. *)
  (**
&lt;&lt;
  Fail binder apply @path_forall in H'.
&gt;&gt;
  Error: Tactic failure: Cannot use &lt;tactic&gt; to solve side-condition goal
Funext . Extended goal with context:
(Funext -&gt;
 forall (A : Type) (f g : A -&gt; A -&gt; A -&gt; A -&gt; A)
   (H' : forall x' x'0 x'1 : A, f x' x'0 x'1 = g x' x'0 x'1),
 let H0 := H' in Funext). *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 142
Time: 0.004s">
<div class="time" style="width: 44.444444444444%"></div>
<pre>binder apply @path_forall in H' using assumption.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 142
Time: 0.003s">
<div class="time" style="width: 33.333333333333%"></div>
<pre>
  binder apply @path_forall in H' using typeclasses eauto.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 143
Time: 0.003s">
<div class="time" style="width: 33.333333333333%"></div>
<pre>
  binder apply (@path_forall _) in H'.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** Now we have removed all arguments to [f] and [g] in [H']. *)
 </pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>exact H'.</pre>
</div>
<div class="code" title="File: BinderApply.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** We [Abort], so that we don't get an extra constant floating around. *)
Abort.

(** N.B. [constrbinder apply] is like [binder apply], except that it constructs a new term and returns it, rather than applying a lemma in-place to a hypothesis.  It's primarily useful as plumbing for higher-level tactics. *)

</pre>
</div>
</body>
</html>

