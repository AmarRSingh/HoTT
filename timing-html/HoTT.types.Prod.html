<html>
<head>
<title>Prod.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Prod.v</h1>

<div class="code" title="File: Prod.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)
(** * Theorems about cartesian products *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 3
Time: 0.018s">
<div class="time" style="width: 11.764705882353%"></div>
<pre>Require Import Overture PathGroupoids Equivalences Trunc.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope equiv_scope.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Generalizable Variables X A B f g n.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Unpacking *)

(** Sometimes we would like to prove [Q u] where [u : A * B] by writing [u] as a pair [(fst u ; snd u)]. This is accomplished by [unpack_prod]. We want tight control over the proof, so we just write it down even though is looks a bit scary. *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 11
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>Definition unpack_prod `{P : A * B -&gt; Type} (u : A * B) :
  P (fst u, snd u) -&gt; P u
  :=
  let (x, y) as u return (P (fst u, snd u) -&gt; P u) := u in idmap.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Now we write down the reverse. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 16
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre>Definition pack_prod `{P : A * B -&gt; Type} (u : A * B) :
  P u -&gt; P (fst u, snd u)
  :=
  let (x, y) as u return (P u -&gt; P (fst u, snd u)) := u in idmap.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 19
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Eta conversion *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 22
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>Definition eta_prod `(z : A * B) : (fst z, snd z) = z
  := match z with (x,y) =&gt; 1 end.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Paths *)

(** With this version of the function, we often have to give [z] and [z'] explicitly, so we make them explicit arguments. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 27
Time: 0.019s">
<div class="time" style="width: 12.418300653595%"></div>
<pre>Definition path_prod_uncurried {A B : Type} (z z' : A * B)
  (pq : (fst z = fst z') * (snd z = snd z'))
  : (z = z')
  := match pq with (p,q) =&gt;
       match z, z' return
         (fst z = fst z') -&gt; (snd z = snd z') -&gt; (z = z') with
         | (a,b), (a',b') =&gt; fun p q =&gt;
           match p, q with
             idpath, idpath =&gt; 1
           end
       end p q
     end.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it's the uncurried one that is proven below to be an equivalence. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 40
Time: 0.005s">
<div class="time" style="width: 3.2679738562092%"></div>
<pre>Definition path_prod {A B : Type} (z z' : A * B) :
  (fst z = fst z') -&gt; (snd z = snd z') -&gt; (z = z')
  := fun p q =&gt; path_prod_uncurried z z' (p,q).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This version produces only paths between pairs, as opposed to paths between arbitrary inhabitants of product types.  But it has the advantage that the components of those pairs can more often be inferred. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 44
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>Definition path_prod' {A B : Type} {x x' : A} {y y' : B}
  : (x = x') -&gt; (y = y') -&gt; ((x,y) = (x',y'))
  := fun p q =&gt; path_prod (x,y) (x',y') p q.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Now we show how these things compute. *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 49
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>Definition ap_fst_path_prod {A B : Type} {z z' : A * B}
  (p : fst z = fst z') (q : snd z = snd z') :
  ap fst (path_prod _ _ p q) = p.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 51
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 52
Time: 0.031s">
<div class="time" style="width: 20.261437908497%"></div>
<pre>
  revert p q; destruct z, z'; simpl; intros [] []; reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 53
Time: 0.01s">
<div class="time" style="width: 6.5359477124183%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 54
Time: 0.005s">
<div class="time" style="width: 3.2679738562092%"></div>
<pre>

Definition ap_snd_path_prod {A B : Type} {z z' : A * B}
  (p : fst z = fst z') (q : snd z = snd z') :
  ap snd (path_prod _ _ p q) = q.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 59
Time: 0.029s">
<div class="time" style="width: 18.954248366013%"></div>
<pre>
  revert p q; destruct z, z'; simpl; intros [] []; reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 60
Time: 0.008s">
<div class="time" style="width: 5.2287581699346%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 61
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre>

Definition eta_path_prod {A B : Type} {z z' : A * B} (p : z = z') :
  path_prod _ _(ap fst p) (ap snd p) = p.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 65
Time: 0.006s">
<div class="time" style="width: 3.921568627451%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 66
Time: 0.007s">
<div class="time" style="width: 4.5751633986928%"></div>
<pre> destruct z.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 66
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 66
Time: 0.005s">
<div class="time" style="width: 3.2679738562092%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Now we show how these compute with transport. *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 70
Time: 0.01s">
<div class="time" style="width: 6.5359477124183%"></div>
<pre>Lemma transport_path_prod_uncurried A B (P : A * B -&gt; Type) (x y : A * B)
      (H : (fst x = fst y) * (snd x = snd y))
      Px
: transport P (path_prod_uncurried _ _ H) Px
  = unpack_prod
      y
      (transport (fun x =&gt; P (x, snd y))
                 (fst H)
                 (transport (fun y =&gt; P (fst x, y))
                            (snd H)
                            (pack_prod x Px))).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 81
Time: 0.086s">
<div class="time" style="width: 56.209150326797%"></div>
<pre>
  destruct x, y, H; simpl in *.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 82
Time: 0.017s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
  path_induction.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 83
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 84
Time: 0.025s">
<div class="time" style="width: 16.339869281046%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 85
Time: 0.015s">
<div class="time" style="width: 9.8039215686275%"></div>
<pre>

Definition transport_path_prod A B (P : A * B -&gt; Type) (x y : A * B)
           (HA : fst x = fst y)
           (HB : snd x = snd y)
           Px
: transport P (path_prod _ _ HA HB) Px
  = unpack_prod
      y
      (transport (fun x =&gt; P (x, snd y))
                 HA
                 (transport (fun y =&gt; P (fst x, y))
                            HB
                            (pack_prod x Px)))
  := transport_path_prod_uncurried _ _ P x y (HA, HB) Px.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 99
Time: 0.009s">
<div class="time" style="width: 5.8823529411765%"></div>
<pre>

Definition transport_path_prod'
           A B (P : A * B -&gt; Type)
           (x y : A)
           (x' y' : B)
           (HA : x = y)
           (HB : x' = y')
           Px
: transport P (path_prod' HA HB) Px
  = transport (fun x =&gt; P (x, y'))
              HA
              (transport (fun y =&gt; P (x, y))
                         HB
                         Px)
  := transport_path_prod _ _ P (x, x') (y, y') HA HB Px.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This lets us identify the path space of a product type, up to equivalence. *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 117
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>Instance isequiv_path_prod {A B : Type} {z z' : A * B}
  : IsEquiv (path_prod_uncurried z z') | 0.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 118
Time: 0.075s">
<div class="time" style="width: 49.019607843137%"></div>
<pre>
  refine (BuildIsEquiv _ _ _
    (fun r =&gt; (ap fst r, ap snd r))
    eta_path_prod
    (fun pq =&gt; match pq with
                 | (p,q) =&gt; path_prod'
                   (ap_fst_path_prod p q) (ap_snd_path_prod p q)
               end) _).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 125
Time: 0.132s">
<div class="time" style="width: 86.274509803922%"></div>
<pre>
  destruct z as [x y], z' as [x' y'].</pre>
</div>
<div class="code" title="File: Prod.v
Line: 126
Time: 0.056s">
<div class="time" style="width: 36.601307189542%"></div>
<pre>
  intros [p q]; simpl in p, q.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 127
Time: 0.153s">
<div class="time" style="width: 100%"></div>
<pre>
  destruct p, q; reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 128
Time: 0.094s">
<div class="time" style="width: 61.437908496732%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 129
Time: 0.006s">
<div class="time" style="width: 3.921568627451%"></div>
<pre>

Definition equiv_path_prod {A B : Type} (z z' : A * B)
  : (fst z = fst z') * (snd z = snd z')  &lt;~&gt;  (z = z')
  := BuildEquiv _ _ (path_prod_uncurried z z') _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 133
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Transport *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 136
Time: 0.011s">
<div class="time" style="width: 7.1895424836601%"></div>
<pre>Definition transport_prod {A : Type} {P Q : A -&gt; Type} {a a' : A} (p : a = a')
  (z : P a * Q a)
  : transport (fun a =&gt; P a * Q a) p z  =  (p # (fst z), p # (snd z))
  := match p with idpath =&gt; match z with (x,y) =&gt; 1 end end.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 139
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Functorial action *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 142
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>Definition functor_prod {A A' B B' : Type} (f:A-&gt;A') (g:B-&gt;B')
  : A * B -&gt; A' * B'
  := fun z =&gt; (f (fst z), g (snd z)).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 144
Time: 0.007s">
<div class="time" style="width: 4.5751633986928%"></div>
<pre>

Definition ap_functor_prod {A A' B B' : Type} (f:A-&gt;A') (g:B-&gt;B')
  (z z' : A * B) (p : fst z = fst z') (q : snd z = snd z')
  : ap (functor_prod f g) (path_prod _ _ p q)
  = path_prod (functor_prod f g z) (functor_prod f g z') (ap f p) (ap g q).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 149
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 150
Time: 0.026s">
<div class="time" style="width: 16.993464052288%"></div>
<pre>
  destruct z as [a b]; destruct z' as [a' b'].</pre>
</div>
<div class="code" title="File: Prod.v
Line: 151
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  simpl in p, q.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 152
Time: 0.021s">
<div class="time" style="width: 13.725490196078%"></div>
<pre> destruct p, q.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 152
Time: 0.005s">
<div class="time" style="width: 3.2679738562092%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 152
Time: 0.014s">
<div class="time" style="width: 9.1503267973856%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Equivalences *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 156
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>Instance isequiv_functor_prod `{IsEquiv A A' f} `{IsEquiv B B' g}
  : IsEquiv (functor_prod f g) | 1000.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 157
Time: 0.025s">
<div class="time" style="width: 16.339869281046%"></div>
<pre>
  refine (BuildIsEquiv _ _ (functor_prod f g) (functor_prod f^-1 g^-1)
    (fun z =&gt; path_prod' (eisretr f (fst z)) (eisretr g (snd z)) @ eta_prod z)
    (fun w =&gt; path_prod' (eissect f (fst w)) (eissect g (snd w)) @ eta_prod w)
    _).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 161
Time: 0.025s">
<div class="time" style="width: 16.339869281046%"></div>
<pre>
  intros [a b]; simpl.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 162
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  unfold path_prod'.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 163
Time: 0.049s">
<div class="time" style="width: 32.02614379085%"></div>
<pre>
  repeat rewrite concat_p1.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 164
Time: 0.022s">
<div class="time" style="width: 14.37908496732%"></div>
<pre>
  rewrite ap_functor_prod.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 165
Time: 0.047s">
<div class="time" style="width: 30.718954248366%"></div>
<pre>
  repeat rewrite eisadj.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 166
Time: 0.008s">
<div class="time" style="width: 5.2287581699346%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 167
Time: 0.044s">
<div class="time" style="width: 28.758169934641%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 168
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>

Definition equiv_functor_prod `{IsEquiv A A' f} `{IsEquiv B B' g}
  : A * B &lt;~&gt; A' * B'.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 171
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 172
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>
  exists (functor_prod f g).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 173
Time: 0.009s">
<div class="time" style="width: 5.8823529411765%"></div>
<pre>
  exact _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 174
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>    (* i.e., search the context for instances *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 174
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 174
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>

Definition equiv_functor_prod' {A A' B B' : Type} (f : A &lt;~&gt; A') (g : B &lt;~&gt; B')
  : A * B &lt;~&gt; A' * B'.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 177
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 178
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>
  exists (functor_prod f g).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 179
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>
  exact _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>    (* i.e., search the context for instances *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 180
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition equiv_functor_prod_l {A B B' : Type} (g : B &lt;~&gt; B')
  : A * B &lt;~&gt; A * B'.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 184
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>
  exists (functor_prod idmap g).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 185
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre>
  exact _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>    (* i.e., search the context for instances *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 186
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition equiv_functor_prod_r {A A' B : Type} (f : A &lt;~&gt; A')
  : A * B &lt;~&gt; A' * B.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 189
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 190
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>
  exists (functor_prod f idmap).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 191
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre>
  exact _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>    (* i.e., search the context for instances *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 192
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Symmetry *)

(* This is a special property of [prod], of course, not an instance of a general family of facts about types. *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 197
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_prod_symm (A B : Type) : A * B &lt;~&gt; B * A.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 197
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 198
Time: 0.017s">
<div class="time" style="width: 11.111111111111%"></div>
<pre>
  refine (BuildEquiv (A*B) (B*A)
    (fun ab =&gt; let (a,b) := ab in (b,a))
    (BuildIsEquiv (A*B) (B*A) _
      (fun ba =&gt; let (b,a) := ba in (a,b))
      (fun ba =&gt; let (b,a) as ba return
            ((let (a,b) := (let (b,a) := ba in (a,b)) in (b,a)) = ba)
                 := ba in 1)
    (fun ab =&gt; let (a,b) as ab return
            ((let (b,a) := (let (a,b) := ab in (b,a)) in (a,b)) = ab)
                 := ab in 1)
    _)).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 209
Time: 0.013s">
<div class="time" style="width: 8.4967320261438%"></div>
<pre>
  intros [a b].</pre>
</div>
<div class="code" title="File: Prod.v
Line: 210
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 210
Time: 0.007s">
<div class="time" style="width: 4.5751633986928%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Universal mapping properties *)

(** Ordinary universal mapping properties are expressed as equivalences of sets or spaces of functions.  In type theory, we can go beyond this and express an equivalence of types of *dependent* functions.  Moreover, because the product type can expressed both positively and negatively, it has both a left universal property and a right one. *)

(* First the positive universal property.
   Doing this sort of thing without adjointifying will require very careful use of funext. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 218
Time: 0.013s">
<div class="time" style="width: 8.4967320261438%"></div>
<pre>Instance isequiv_prod_rect `{Funext} `(P : A * B -&gt; Type)
  : IsEquiv (prod_rect P) | 0
  := isequiv_adjointify _
  (fun f x y =&gt; f (x,y))
  (fun f =&gt; path_forall
    (fun z =&gt; prod_rect P (fun x y =&gt; f (x,y)) z)
    f (fun z =&gt; match z with (a,b) =&gt; 1 end))
  (fun f =&gt; path_forall2
    (fun x y =&gt; prod_rect P f (x,y))
    f (fun a b =&gt; 1)).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 227
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>

Definition equiv_prod_rect `{Funext} `(P : A * B -&gt; Type)
  : (forall (a : A) (b : B), P (a, b)) &lt;~&gt; (forall p : A * B, P p)
  := BuildEquiv _ _ (prod_rect P) _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 231
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* The non-dependent version, which is a special case, is the currying equivalence. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 233
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>Definition equiv_uncurry `{Funext} (A B C : Type)
  : (A -&gt; B -&gt; C) &lt;~&gt; (A * B -&gt; C)
  := equiv_prod_rect (fun _ =&gt; C).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 235
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Now the negative universal property. *)</pre>
</div>
<div class="code" title="File: Prod.v
Line: 237
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>Definition prod_corect_uncurried `{A : X -&gt; Type} `{B : X -&gt; Type}
  : (forall x, A x) * (forall x, B x) -&gt; (forall x, A x * B x)
  := fun fg x =&gt; let (f,g):=fg in (f x, g x).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 239
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>

Definition prod_corect `(f : forall x:X, A x) `(g : forall x:X, B x)
  : forall x, A x * B x
  := prod_corect_uncurried (f,g).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 243
Time: 0.008s">
<div class="time" style="width: 5.2287581699346%"></div>
<pre>

Instance isequiv_prod_corect `{Funext} `(A : X -&gt; Type) (B : X -&gt; Type)
  : IsEquiv (@prod_corect_uncurried X A B) | 0
  := isequiv_adjointify _
  (fun h =&gt; (fun x =&gt; fst (h x), fun x =&gt; snd (h x)))
  _ _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 249
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 250
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Prod.v
Line: 251
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros h.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 251
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>
    apply path_forall; intros x.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 252
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>
    apply path_prod; simpl; reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 253
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Prod.v
Line: 254
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre> intros [f g].</pre>
</div>
<div class="code" title="File: Prod.v
Line: 254
Time: 0.003s">
<div class="time" style="width: 1.9607843137255%"></div>
<pre>
    apply path_prod; simpl; reflexivity.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 255
Time: 0.009s">
<div class="time" style="width: 5.8823529411765%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 256
Time: 0.005s">
<div class="time" style="width: 3.2679738562092%"></div>
<pre>

Definition equiv_prod_corect `{Funext} `(A : X -&gt; Type) (B : X -&gt; Type)
  : ((forall x, A x) * (forall x, B x)) &lt;~&gt; (forall x, A x * B x)
  := BuildEquiv _ _ (@prod_corect_uncurried X A B) _.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 260
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Products preserve truncation *)

</pre>
</div>
<div class="code" title="File: Prod.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Instance trunc_prod `{IsTrunc n A} `{IsTrunc n B} : IsTrunc n (A * B) | 100.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 264
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  generalize dependent B; generalize dependent A.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 265
Time: 0.001s">
<div class="time" style="width: 0.65359477124183%"></div>
<pre>
  induction n as [| n I]; simpl; intros A ? B ?.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 266
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>
  exists (center A, center B).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 267
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>
    intros z; apply path_prod; apply contr.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 268
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros x y.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 269
Time: 0.011s">
<div class="time" style="width: 7.1895424836601%"></div>
<pre>
    exact (trunc_equiv (equiv_path_prod x y)).</pre>
</div>
<div class="code" title="File: Prod.v
Line: 270
Time: 0.004s">
<div class="time" style="width: 2.6143790849673%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 271
Time: 0.002s">
<div class="time" style="width: 1.3071895424837%"></div>
<pre>

Instance contr_prod `{CA : Contr A} `{CB : Contr B} : Contr (A * B) | 100
  := @trunc_prod minus_two A CA B CB.</pre>
</div>
<div class="code" title="File: Prod.v
Line: 275
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

