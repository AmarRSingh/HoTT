<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>HoTT.Modalities.Lex</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HoTT.Modalities.Lex</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Fibrations.html#"><span class="id" title="library">Fibrations</span></a> <a class="idref" href="HoTT.Extensions.html#"><span class="id" title="library">Extensions</span></a> <a class="idref" href="HoTT.Pullback.html#"><span class="id" title="library">Pullback</span></a> <a class="idref" href="HoTT.NullHomotopy.html#"><span class="id" title="library">NullHomotopy</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Modality.html#"><span class="id" title="library">Modality</span></a> <a class="idref" href="HoTT.Modalities.Accessible.html#"><span class="id" title="library">Accessible</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Tactics.html#"><span class="id" title="library">HoTT.Tactics</span></a>.<br/>

<br/>
<span class="id" title="keyword">Local</span>&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>
<span class="id" title="keyword">Local</span>&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">equiv_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab266"></a><h1 class="section">Lex modalities</h1>

<div class="paragraph"> </div>

 A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

<div class="paragraph"> </div>

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;http://mathoverflow.net/questions/185980/a-small-definition-of-sub-88
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> (<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Lex_Modalities_Theory.Os_Theory"><span class="id" title="module">Os_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a name="Lex_Modalities_Theory.Lex"><span class="id" title="record">Lex</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span>})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a name="Lex_Modalities_Theory.isconnected_paths"><span class="id" title="projection">isconnected_paths</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected@</span></a>{<span class="id" title="var">u</span> <span class="id" title="var">a</span> <span class="id" title="var">i</span>} <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global</span>&nbsp;<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">isconnected_paths</span>.<br/>

<br/>
</div>

<div class="doc">
The next six lemmas are equivalent characterizations of lex-ness. 
<div class="paragraph"> </div>

 1. Every map between connected types is a connected map. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.conn_map_lex"><span class="id" title="instance">conn_map_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}} {<span class="id" title="var">B</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a> <span class="id" title="var">O</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
2. Connected maps are left- as well as right-cancellable. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Fibrations.html#hfiber_hfiber_compose_map"><span class="id" title="definition">hfiber_hfiber_compose_map</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
3. Every map inverted by <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span> is <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span>-connected. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.isconnected_O_inverts"><span class="id" title="definition">isconnected_O_inverts</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_inverts"><span class="id" title="abbreviation">O_inverts</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
Typeclass magic! 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
4. Connected types are closed under pullbacks. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnected"><span class="id" title="class">IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_sigma"><span class="id" title="instance">isconnected_sigma</span></a>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma&acute;"><span class="id" title="definition">equiv_functor_sigma&acute;</span></a> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_idmap"><span class="id" title="definition">equiv_idmap</span></a> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
5. The reflector preserves pullbacks.  This justifies the terminology "lex". 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_functor_pullback"><span class="id" title="definition">O_functor_pullback</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor_square"><span class="id" title="definition">O_functor_square</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.isequiv_O_inverts"><span class="id" title="definition">isequiv_O_inverts</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.O_inverts_conn_map"><span class="id" title="instance">O_inverts_conn_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#Pullback"><span class="id" title="definition">Pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor"><span class="id" title="definition">O_functor</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">B</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <span class="id" title="var">g</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> [<span class="id" title="var">c</span> <span class="id" title="var">e</span>]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#functor_pullback"><span class="id" title="definition">functor_pullback</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>, <a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma&acute;"><span class="id" title="definition">path_sigma&acute;</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr1"><span class="id" title="definition">pullback_pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Sigma.html#transport_sigma&acute;"><span class="id" title="definition">transport_sigma&acute;</span></a>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#path_sigma&acute;"><span class="id" title="definition">path_sigma&acute;</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural"><span class="id" title="definition">to_O_natural</span></a> <span class="id" title="var">O</span> <a class="idref" href="HoTT.Pullback.html#pullback_pr2"><span class="id" title="definition">pullback_pr2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;(</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">))</span></a><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fl"><span class="id" title="definition">transport_paths_Fl</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_Fr"><span class="id" title="definition">transport_paths_Fr</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor_square"><span class="id" title="definition">O_functor_square</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor_homotopy_beta"><span class="id" title="definition">O_functor_homotopy_beta</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p_pp"><span class="id" title="definition">concat_p_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pp_p"><span class="id" title="definition">concat_pp_p</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a>, &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_functor_compose"><span class="id" title="definition">O_functor_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)), &lt;- <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a>, <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.to_O_natural_compose"><span class="id" title="definition">to_O_natural_compose</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Close</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">long_path_scope</span>.<br/>
</div>

<div class="doc">
By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by <span class="inlinecode"><a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a></span> and typeclass magic invoking <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_pullback"><span class="id" title="instance">isconnected_pullback</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">ob</span> [<span class="id" title="var">oc</span> <span class="id" title="var">oe</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Pullback.html#hfiber_functor_pullback"><span class="id" title="definition">hfiber_functor_pullback</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
6. Lex modalities preserve path-spaces. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_rec"><span class="id" title="definition">O_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.isequiv_O_path_cmp"><span class="id" title="instance">isequiv_O_path_cmp</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">y</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.conn_map_homotopic"><span class="id" title="definition">conn_map_homotopic</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.RSU.O_rec_beta"><span class="id" title="definition">O_rec_beta</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isconnected_equiv"><span class="id" title="definition">isconnected_equiv</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Fibrations.html#hfiber_ap"><span class="id" title="definition">hfiber_ap</span></a> <span class="id" title="var">p</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We will not prove that any of these lemmas are equivalent characterizations of lex-ness, because they are all fairly obvious and we don't yet know of any use for them; <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.isconnected_paths"><span class="id" title="projection">isconnected_paths</span></a></span> is usually strictly easier to prove than they are. 
<div class="paragraph"> </div>

 Another useful lemma, which is probably not equivalent to lex-ness: any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Lex_Modalities_Theory.ispullback_connmap_mapino_commsq"><span class="id" title="definition">ispullback_connmap_mapino_commsq</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">k</span> : <a class="idref" href="HoTT.Modalities.Lex.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#D"><span class="id" title="variable">D</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.IsConnMap"><span class="id" title="class">IsConnMap</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.MapIn"><span class="id" title="class">MapIn</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Modalities.Lex.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#h"><span class="id" title="variable">h</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Pullback.html#IsPullback"><span class="id" title="definition">IsPullback</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.isequiv_conn_ino_map"><span class="id" title="definition">isequiv_conn_ino_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.cancelL_conn_map"><span class="id" title="definition">cancelL_conn_map</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> <span class="id" title="var">p</span>) (<span class="id" title="var">k</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Pullback.html#equiv_pullback_symm"><span class="id" title="definition">equiv_pullback_symm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.cancelL_mapinO"><span class="id" title="definition">cancelL_mapinO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<span class="id" title="var">g</span><a class="idref" href="HoTT.Pullback.html#a3f59e6c9556bd7073e29064ad7219d8"><span class="id" title="notation">^*</span></a> <span class="id" title="var">k</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Lex modalities preserve <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>-types for all <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a></span>.  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to <span class="inlinecode"><a class="idref" href="HoTT.hit.Truncations.html#oo"><span class="id" title="abbreviation">oo</span></a></span>-types. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Lex_Modalities_Theory.istrunc_O_lex"><span class="id" title="instance">istrunc_O_lex</span></a> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} `{<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">n</span>} {<span class="id" title="var">A</span>} `{<a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">A</span>; <span class="id" title="var">simple_induction</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. </div>

<div class="doc">
Already proven for all modalities. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span>, <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.O_ind"><span class="id" title="definition">O_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <span class="id" title="var">n</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y"><span class="id" title="variable">y</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#trunc_equiv"><span class="id" title="definition">trunc_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory.O_path_cmp"><span class="id" title="definition">O_path_cmp</span></a> <span class="id" title="var">O</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a>.<br/>

<br/>
</div>

<div class="doc">
We now restrict to lex modalities that are also accessible. 
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <a name="Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Os</span> : <a class="idref" href="HoTT.Modalities.Modality.html#Modalities"><span class="id" title="module">Modalities</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Acc</span> : <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities"><span class="id" title="module">Accessible_Modalities</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Acc_Theory"><span class="id" title="module">Acc_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Acc"><span class="id" title="module">Acc</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="Accessible_Lex_Modalities_Theory.Lex_Theory"><span class="id" title="module">Lex_Theory</span></a> := <a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Os"><span class="id" title="module">Os</span></a>.<br/>

<br/>
</div>

<div class="doc">
Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">Os_Theory</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> that occur in both <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Accessible.html#Accessible_Modalities_Theory"><span class="id" title="module">Accessible_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> <span class="inlinecode"><span class="id" title="var">Acc</span></span> and <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Lex_Modalities_Theory"><span class="id" title="module">Lex_Modalities_Theory</span></a></span> <span class="inlinecode"><span class="id" title="var">Os</span></span> create two *different* modules, which appear here as <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span>.  Thus, for instance, we have two different definitions <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory.O_ind</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory.O_ind</span></span>, etc.

<div class="paragraph"> </div>

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> is opaque, then Coq will be unable to notice that its duplicate copies in <span class="inlinecode"><span class="id" title="var">Acc_Theory.Os_Theory</span></span> and <span class="inlinecode"><span class="id" title="var">Lex_Theory.Os_Theory</span></span> were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

<div class="paragraph"> </div>

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> and <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions, like modules, always create a new object not convertible to any previously existing one.  There are no <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> or <span class="inlinecode"><span class="id" title="keyword">Record</span></span> definitions in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span>, but there are <span class="inlinecode"><span class="id" title="keyword">Class</span></span> declarations, and these function similarly.  In particular, typeclass search is unable to use <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s defined in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> to instantiate typeclasses from <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> (such as <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory.IsConnected"><span class="id" title="record">IsConnected</span></a></span>) needed by functions in <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and vice versa.

<div class="paragraph"> </div>

  Fortunately, all the typeclasses defined in <span class="inlinecode"><a class="idref" href="HoTT.Modalities.Modality.html#Modalities_Theory"><span class="id" title="module">Modalities_Theory</span></a></span> are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s from <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span> can in fact be typechecked to *belong* to the typeclasses needed by <span class="inlinecode"><span class="id" title="var">Lex_Theory</span></span>, and hence can be supplied explicitly.

<div class="paragraph"> </div>

  We can also do this once and for all by defining <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s translating automatically between the two typeclasses, although unfortunately we probably can't declare such instances in both directions at once for fear of infinite loops.  Fortunately, there is not a lot in <span class="inlinecode"><span class="id" title="var">Acc_Theory</span></span>, so this direction seems likely to be the most useful. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.isconnected_acc_to_lex"><span class="id" title="instance">isconnected_acc_to_lex</span></a> {<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Acc_Theory.Os_Theory.IsConnected"><span class="id" title="class">Acc_Theory.Os_Theory.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.IsConnected"><span class="id" title="class">Lex_Theory.Os_Theory.IsConnected</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>} (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.RSU.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.inO_iff_isnull"><span class="id" title="axiom">inO_iff_isnull</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; [ <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> | <span class="id" title="tactic">split</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
</div>

<div class="doc">
Here is the core of the proof: we must show that any family of modal types indexed by a (generating) connected type is equivalent to a constant family.  We take the constant family to be constant at the reflection of the sum of our given family <span class="inlinecode"><a class="idref" href="HoTT.categories.DependentProduct.html#dependent_product.P"><span class="id" title="variable">P</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.RSU.path_TypeO"><span class="id" title="definition">path_TypeO</span></a>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Universe.html#path_universe"><span class="id" title="definition">path_universe</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> ⇒ <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Fibrations.html#isequiv_from_functor_sigma"><span class="id" title="definition">isequiv_from_functor_sigma</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Pullback.html#pullback_corec"><span class="id" title="definition">pullback_corec</span></a> ((<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span>:<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span> ⇒ 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Modalities.Lex.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#70142a8c3dba04f5a64047914b5e18ea"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
And here is the core of why it works: the useful lemma above about detecting pullback squares. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.ispullback_connmap_mapino_commsq"><span class="id" title="definition">ispullback_connmap_mapino_commsq</span></a> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span>:<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span> ⇒ 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>) <a class="idref" href="HoTT.Basics.Overture.html#cfa37b78c28623fd2a8dbbdb5f080ad4"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#edadc0d66ba2e614f03a8e21622242b7"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>)).<br/>
</div>

<div class="doc">
All the necessary hypotheses are found by typeclass magic! 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_compose"><span class="id" title="definition">equiv_compose</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Types.Prod.html#equiv_prod_symm"><span class="id" title="definition">equiv_prod_symm</span></a> (<span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>)) (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Pullback.html#equiv_pullback_unit_prod"><span class="id" title="definition">equiv_pullback_unit_prod</span></a> (<span class="id" title="var">O</span> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" title="abbreviation">sigT</span></a> <span class="id" title="var">P</span>)) (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod0"><span class="id" title="definition">equiv_sigma_prod0</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
</div>

<div class="doc">
The case <span class="inlinecode"><a class="idref" href="Coq.Init.Peano.html#n"><span class="id" title="variable">n</span></a>&gt;0</span> is actually quite easy, using univalence and the fact that modal types are closed under <span class="inlinecode"><a class="idref" href="HoTT.hit.quotient.html#Equiv"><span class="id" title="section">Equiv</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Extensions.html#extendable_postcompose&acute;"><span class="id" title="definition">extendable_postcompose&acute;</span></a> <span class="id" title="var">n</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_compose&acute;"><span class="id" title="definition">equiv_compose&acute;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.RSU.equiv_path_TypeO"><span class="id" title="definition">equiv_path_TypeO</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Types.Universe.html#equiv_path_universe"><span class="id" title="definition">equiv_path_universe</span></a> (<span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>) (<span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.extendable_conn_map_inO"><span class="id" title="definition">extendable_conn_map_inO</span></a> <span class="id" title="var">O</span> <span class="id" title="var">n</span> (@<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Acc.acc_gen"><span class="id" title="axiom">acc_gen</span></a> <span class="id" title="var">O</span> <span class="id" title="var">i</span>) <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">A</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#490cb90cbf16dda297465c679b461e1c"><span class="id" title="notation">&lt;~&gt;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Modalities.Lex.html#b"><span class="id" title="variable">b</span></a>)).<br/>
</div>

<div class="doc">
Typeclass magic! 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.inO_typeO"><span class="id" title="instance">inO_typeO</span></a></span> is also an equivalent characterization of lex-ness for a modality.  We will prove this, because it is less obvious, and also more useful. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Accessible_Lex_Modalities_Theory.lex_inO_typeO"><span class="id" title="definition">lex_inO_typeO</span></a> (<span class="id" title="var">O</span> : <a class="idref" href="HoTT.Modalities.Lex.html#Os.Modality"><span class="id" title="axiom">Modality</span></a>) `{<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.In"><span class="id" title="class">In</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.RSU.Type_"><span class="id" title="definition">Type_</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>)}<br/>
&nbsp;&nbsp;: <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Lex"><span class="id" title="class">Lex</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#O"><span class="id" title="variable">O</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.isconnected_from_elim_to_O"><span class="id" title="definition">isconnected_from_elim_to_O</span></a>.<br/>
</div>

<div class="doc">
The idea is that if <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" title="variable">A</span></a></span> is connected and <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.Type_"><span class="id" title="definition">Type_</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span> is modal, then <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="HoTT.categories.Functor.Attributes.html#fully_faithful_helpers.y"><span class="id" title="variable">y</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#ReflectiveSubuniverses_Theory.Type_"><span class="id" title="definition">Type_</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span> is constant.  Thus, <span class="inlinecode"><a class="idref" href="HoTT.categories.IndiscreteCategory.html#Functors.to"><span class="id" title="definition">to</span></a></span> <span class="inlinecode"><a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>=<a class="idref" href="HoTT.categories.Grothendieck.PseudofunctorToCat.html#x"><span class="id" title="projection">x</span></a>)</span> <span class="inlinecode">1</span> can be transported around to make it contractible everywhere. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">e</span> := <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.isconnected_elim"><span class="id" title="definition">isconnected_elim</span></a> <span class="id" title="var">O</span> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.RSU.Type_"><span class="id" title="definition">Type_</span></a> <span class="id" title="var">O</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">y&acute;</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">(</span></a><span class="id" title="var">O</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#y&acute;"><span class="id" title="variable">y&acute;</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.O_inO"><span class="id" title="definition">O_inO</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6219320773dc83ab7d1d441169459b9d"><span class="id" title="notation">)</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">(</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#3351948a6e0d36c4877ab109ffc3dfc9"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a><a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">)</span></a>..<a class="idref" href="HoTT.Types.Sigma.html#5bfcbd4197c5362e00d29233e8cbeaee"><span class="id" title="notation">1</span></a> (<a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory.Lex_Theory.Os_Theory.Os_ReflectiveSubuniverses.to"><span class="id" title="definition">to</span></a> <span class="id" title="var">O</span> (<span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Overture.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><span class="id" title="var">x</span>) 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#transport2"><span class="id" title="definition">transport2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_pV"><span class="id" title="definition">concat_pV</span></a> (<span class="id" title="var">e</span><a class="idref" href="HoTT.Basics.Overture.html#32a18aa7c2c66c8633d64337f5480d50"><span class="id" title="notation">.2</span></a> <span class="id" title="var">x</span>))) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#29af923c7a8513334b9f1a5189c731d3"><span class="id" title="notation">)^</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Modalities.Lex.html#Accessible_Lex_Modalities_Theory"><span class="id" title="module">Accessible_Lex_Modalities_Theory</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>