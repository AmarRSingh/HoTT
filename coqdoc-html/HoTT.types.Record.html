<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>HoTT.types.Record</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HoTT.types.Record</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab86"></a><h1 class="section">Techniques for applying theorems from <span class="inlinecode"><span class="id" type="var">Sigma.v</span></span> to record types.</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="HoTT.Overture.html#"><span class="id" type="library">Overture</span></a> <a class="idref" href="HoTT.Contractible.html#"><span class="id" type="library">Contractible</span></a> <a class="idref" href="HoTT.Equivalences.html#"><span class="id" type="library">Equivalences</span></a> <a class="idref" href="HoTT.types.Sigma.html#"><span class="id" type="library">types.Sigma</span></a> <a class="idref" href="HoTT.types.Forall.html#"><span class="id" type="library">types.Forall</span></a>.<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">path_scope</span>.<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">equiv_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The following tactic proves automatically that a two-component record type is equivalent to a Sigma-type.  Specifically, it proves a goal that looks like
<pre>
   { x : A &amp; B x } &lt;~&gt; Some_Record
</pre>
   You have to give it the record constructor and the two record projections as arguments (it has no way to guess what those might be). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig1</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
What follows is is a bit of Ltac black magic.  We want to give the explicit proof term except for the coherence cell and define that cell afterwards with tactics.  We could do this by calling the tactic <span class="inlinecode"><span class="id" type="tactic">refine</span></span> and leaving a placeholder <span class="inlinecode"><span class="id" type="var">_</span></span> in the term.  However, the following trick seems to be noticably faster, at least when we move on to the 3- and 4-variable versions below. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">T</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">t</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;</div>

<div class="doc">
We introduce a new existential variable <span class="inlinecode"><a class="idref" href="HoTT.categories.LaxComma.CoreLaws.html#LaxCommaCategory.lax_comma_category_parts.T"><span class="id" type="variable">T</span></a>:<span class="id" type="keyword">Type</span></span>, assert an element <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a>:<a class="idref" href="HoTT.categories.LaxComma.CoreLaws.html#LaxCommaCategory.lax_comma_category_parts.T"><span class="id" type="variable">T</span></a></span>, and substitute away the definition of <span class="inlinecode"><a class="idref" href="HoTT.categories.LaxComma.CoreLaws.html#LaxCommaCategory.lax_comma_category_parts.T"><span class="id" type="variable">T</span></a></span> in the context. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">evar</span> (<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>); <span class="id" type="tactic">assert</span> (<span class="id" type="var">t</span> : <span class="id" type="var">T</span>); <span class="id" type="tactic">subst</span> <span class="id" type="var">T</span>;<br/>
&nbsp;&nbsp;</div>

<div class="doc">
At this point we have two subgoals.  The first is to construct <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span> whose type is utterly unknown (an existential variable), and the second is to prove our desired equivalence under the additional assumption of <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span> (with its unknown type).  We proceed to ignore the first subgoal and supply a term proving the second one, with <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span> standing in for the coherence cell.  This enables Coq to infer what the type of <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span> must be.  Since existential variables are the only way that Coq can communicate typing information between subgoals, this information then propagates over to the first subgoal. 
</div>
<div class="code">
&nbsp;&nbsp;[ |<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Just in case the user supplied a goal which only *reduces* to one of the desired form. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">hnf</span>;<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Extract the fibration of which our Sigma-type is the total space, as well as the record type. We pull the terms out of a <span class="inlinecode"><span class="id" type="keyword">match</span></span>, rather than leaving everything inside the <span class="inlinecode"><span class="id" type="keyword">match</span></span> because this gives us better error messages. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">fibration</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="abbreviation">sigT</span></a> ?<span class="id" type="var">fibration</span> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">record</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">fibration</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">record</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- <a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="abbreviation">sigT</span></a> ?<span class="id" type="var">fibration</span> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">record</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">record</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="abbreviation">sigT</span></a> <span class="id" type="var">fibration</span>) <span class="id" type="var">record</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="HoTT.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a> (<a class="idref" href="Coq.Init.Specif.html#sigT"><span class="id" type="abbreviation">sigT</span></a> <span class="id" type="var">fibration</span>) <span class="id" type="var">record</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="abbreviation">existT</span></a> <span class="id" type="var">fibration</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">v1</span>,<span class="id" type="var">v2</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">v'</span> <span class="id" type="keyword">return</span> (<span class="id" type="var">build</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">in</span> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">return</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="abbreviation">existT</span></a> <span class="id" type="var">fibration</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">pr1</span> (<span class="id" type="var">build</span> (<a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">pr2</span> (<span class="id" type="var">build</span> (<a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a>) (<a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a>)))<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existT</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
We *could* actually give an explicit proof term for the coherence cell.  Here it is:
<pre>
      (fun u =&gt; match u return
                  ((let (v1,v2) as v' return (build (pr1 v') (pr2 v') = v')
                      := (build u.1 u.2) in 1) =
                  ap (fun u =&gt; build u.1 u.2)
                    (match u return
                       (existT fibration
                         (pr1 (build (u.1) (u.2)))
                         (pr2 (build (u.1) (u.2))))
                       = u with
                       existT x y =&gt; 1
                     end)) with
                  existT x y =&gt; 1
                end)
</pre>
      However, for the 3- and 4-variable versions, giving the explicit proof term seems to actually *slow down* the tactic.  Perhaps it is because Coq has to infer more implicit arguments, or perhaps this is because there is no oppertunity to run <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>  Thus, we proceed instead by supplying the term <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span> whose type is an existential variable. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">t</span>)) ];<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Now we are left only with the one subgoal to prove <span class="inlinecode"><a class="idref" href="HoTT.hit.minus1Trunc.html#t"><span class="id" type="lemma">t</span></a></span>, and at this point we know its type.  The proof basically amounts to destructing a pair.  First, though, we instruct Coq to incorporate learned values of all unification variables.  This speeds things up significantly (although again, the difference is really only noticable for the 3- and 4-variable versions below). 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">instantiate</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span> <span class="id" type="keyword">as</span> [? ?];<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> 1.<br/>

<br/>
</div>

<div class="doc">
This allows us to use the same notation for the tactics with varying numbers of variables. 
</div>
<div class="code">
<span class="id" type="keyword">Tactic Notation</span> "issig" <span class="id" type="keyword">constr</span>(<span class="id" type="var">build</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr1</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr2</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">issig1</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span>.<br/>

<br/>
</div>

<div class="doc">
We show how the tactic works in a couple of examples. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="issig_contr"><span class="id" type="definition">issig_contr</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">y</span>:<a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a>, <span class="id" type="var">x</span> <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#y"><span class="id" type="variable">y</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#Contr"><span class="id" type="abbreviation">Contr</span></a> <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">issig</span> (<a class="idref" href="HoTT.Overture.html#BuildContr"><span class="id" type="constructor">BuildContr</span></a> <span class="id" type="var">A</span>) (@<a class="idref" href="HoTT.Overture.html#center"><span class="id" type="method">center</span></a> <span class="id" type="var">A</span>) (@<a class="idref" href="HoTT.Overture.html#contr"><span class="id" type="method">contr</span></a> <span class="id" type="var">A</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="issig_equiv"><span class="id" type="definition">issig_equiv</span></a> (<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">f</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a> <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> <span class="id" type="var">f</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#Equiv"><span class="id" type="record">Equiv</span></a> <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">issig</span> (<a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) (@<a class="idref" href="HoTT.Overture.html#equiv_fun"><span class="id" type="projection">equiv_fun</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) (@<a class="idref" href="HoTT.Overture.html#equiv_isequiv"><span class="id" type="projection">equiv_isequiv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Here is a version of the <span class="inlinecode"><span class="id" type="var">issig</span></span> tactic for three-component records, which proves goals that look like
<pre>
   { x : A &amp; { y : B x &amp; C x y } } &lt;~&gt; Some_Record.
</pre>
   It takes the record constructor and its three projections as arguments, as before. 
<div class="paragraph"> </div>

 First we build a version that doesn't go through adjointification.  By applying <span class="inlinecode"><span class="id" type="tactic">symmetry</span></span> first, we can speed up the coherence proof by about two orders of magnitude (in the case of <span class="inlinecode"><span class="id" type="var">issig3</span></span>, from around 24 seconds to around 0.3 seconds, plus a reduction from 16 seconds to 0.8 seconds in the <span class="inlinecode"><span class="id" type="keyword">Defined</span></span>.  However, this still is too slow, so we will eventually adjointify first.  The speed boost comes from the fact that we are <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>ing a record rather than a sigma type; when primitive projections land in Coq, hopefully this won't make so much of a difference. 
<div class="paragraph"> </div>

 The harness takes a tactical to make the <span class="inlinecode"><a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="record">IsEquiv</span></a></span> proof; when proving <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span> <span class="inlinecode">&lt;~&gt;</span> <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span>, the tactical is given <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.A"><span class="id" type="variable">A</span></a></span> and <span class="inlinecode"><a class="idref" href="HoTTBookExercises.html#Book_4_5.parts.B"><span class="id" type="variable">B</span></a></span>, and should return a function that takes the coherence proof <span class="inlinecode"><a class="idref" href="HoTT.Overture.html#eisadj"><span class="id" type="projection">eisadj</span></a></span> and gives back an <span class="inlinecode"><a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="record">IsEquiv</span></a></span>. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig_harness</span> <span class="id" type="var">make_is_equiv_tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">T</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">t</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">evar</span> (<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>); <span class="id" type="tactic">assert</span> (<span class="id" type="var">t</span> : <span class="id" type="var">T</span>); <span class="id" type="tactic">subst</span> <span class="id" type="var">T</span>;<br/>
&nbsp;&nbsp;[<br/>
&nbsp;&nbsp;| <span class="id" type="tactic">hnf</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="HoTT.Overture.html#symmetry"><span class="id" type="definition">symmetry</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">A</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- ?<span class="id" type="var">A</span> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">B</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">A</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">B</span> := <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> |- ?<span class="id" type="var">A</span> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">B</span> ⇒ <span class="id" type="keyword">constr</span>:(<span class="id" type="var">B</span>) <span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">isequiv_proof</span> := <span class="id" type="var">make_is_equiv_tac</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">exact</span> (@<a class="idref" href="HoTT.Overture.html#BuildEquiv"><span class="id" type="constructor">BuildEquiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">isequiv_proof</span> <span class="id" type="var">t</span>)) ];<br/>
&nbsp;&nbsp;<span class="id" type="tactic">instantiate</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">exact</span> 1.<br/>

<br/>
</div>

<div class="doc">
Now we actually build the non-adjointified version.  We use some notations to provide a cleaner-looking tactic.  We name it <span class="inlinecode"><span class="id" type="var">_exact</span></span> because the section and retraction are not adjusted, as they are in adjointification. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig2_transparent</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">issig_harness</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">constr</span>:(@<a class="idref" href="HoTT.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">A</span> <span class="id" type="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">))</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#eta2_sigma"><span class="id" type="definition">eta2_sigma</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">v1</span>,<span class="id" type="var">v2</span>,<span class="id" type="var">v3</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">v'</span> <span class="id" type="keyword">return</span> (<span class="id" type="var">build</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">in</span> 1))).<br/>

<br/>
</div>

<div class="doc">
Now we build the adjointified version. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig2</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">))</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">v1</span>,<span class="id" type="var">v2</span>,<span class="id" type="var">v3</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">v'</span> <span class="id" type="keyword">return</span> (<span class="id" type="var">build</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">in</span> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#eta2_sigma"><span class="id" type="definition">eta2_sigma</span></a>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "issig" <span class="id" type="keyword">constr</span>(<span class="id" type="var">build</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr1</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr2</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr3</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">issig2</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span>.<br/>

<br/>
</div>

<div class="doc">
And a similar version for four-component records.  It should be clear how to extend the pattern indefinitely. 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig3_transparent</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span> <span class="id" type="var">pr4</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">issig_harness</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">constr</span>:(@<a class="idref" href="HoTT.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">A</span> <span class="id" type="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">pr4</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)))</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#eta3_sigma"><span class="id" type="definition">eta3_sigma</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">v1</span>,<span class="id" type="var">v2</span>,<span class="id" type="var">v3</span>,<span class="id" type="var">v4</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">v'</span> <span class="id" type="keyword">return</span> (<span class="id" type="var">build</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr4</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">in</span> 1))).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">issig3</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span> <span class="id" type="var">pr4</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> (<a class="idref" href="HoTT.Equivalences.html#equiv_adjointify"><span class="id" type="definition">equiv_adjointify</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">u</span> ⇒ <span class="id" type="var">build</span> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.1'"><span class="id" type="notation">.1</span></a> <a class="idref" href="HoTT.types.Record.html#u"><span class="id" type="variable">u</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:x_'.2'"><span class="id" type="notation">.2.2.2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒ <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">;</span></a> <span class="id" type="var">pr4</span> <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a><a class="idref" href="HoTT.Overture.html#:fibration_scope:'('_x_';'_x_')'"><span class="id" type="notation">)))</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">v1</span>,<span class="id" type="var">v2</span>,<span class="id" type="var">v3</span>,<span class="id" type="var">v4</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">v'</span> <span class="id" type="keyword">return</span> (<span class="id" type="var">build</span> (<span class="id" type="var">pr1</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr2</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr3</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) (<span class="id" type="var">pr4</span> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.types.Record.html#v'"><span class="id" type="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="HoTT.types.Record.html#v"><span class="id" type="variable">v</span></a> <span class="id" type="keyword">in</span> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="HoTT.types.Sigma.html#eta3_sigma"><span class="id" type="definition">eta3_sigma</span></a>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "issig" <span class="id" type="keyword">constr</span>(<span class="id" type="var">build</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr1</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr2</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr3</span>) <span class="id" type="keyword">constr</span>(<span class="id" type="var">pr4</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">issig3</span> <span class="id" type="var">build</span> <span class="id" type="var">pr1</span> <span class="id" type="var">pr2</span> <span class="id" type="var">pr3</span> <span class="id" type="var">pr4</span>.<br/>

<br/>
</div>

<div class="doc">
The record <span class="inlinecode"><a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="record">IsEquiv</span></a></span> has four components, so <span class="inlinecode"><span class="id" type="var">issig3</span></span> can prove that it is equivalent to an iterated Sigma-type. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="issig_isequiv_transparent"><span class="id" type="definition">issig_isequiv_transparent</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">g</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a><a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">r</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <span class="id" type="var">g</span> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">s</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <span class="id" type="var">g</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a>, <span class="id" type="var">r</span> (<a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Record.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> (<span class="id" type="var">s</span> <a class="idref" href="HoTT.types.Record.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">issig3_transparent</span> (<a class="idref" href="HoTT.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#equiv_inv"><span class="id" type="method">equiv_inv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<a class="idref" href="HoTT.Overture.html#eissect"><span class="id" type="method">eissect</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#eisadj"><span class="id" type="method">eisadj</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="issig_isequiv"><span class="id" type="definition">issig_isequiv</span></a> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">g</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.types.Record.html#B"><span class="id" type="variable">B</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'->'_x"><span class="id" type="notation">→</span></a><a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">r</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <span class="id" type="var">g</span> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">{</span></a> <span class="id" type="var">s</span><a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">:</span></a><a class="idref" href="HoTT.Overture.html#Sect"><span class="id" type="definition">Sect</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <span class="id" type="var">g</span> <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">&amp;</span></a> <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="HoTT.types.Record.html#A"><span class="id" type="variable">A</span></a>, <span class="id" type="var">r</span> (<a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="HoTT.types.Record.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="HoTT.Overture.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="HoTT.Overture.html#ap"><span class="id" type="definition">ap</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a> (<span class="id" type="var">s</span> <a class="idref" href="HoTT.types.Record.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="Coq.Init.Specif.html#:type_scope:'{'_x_':'_x_'&'_x_'}'"><span class="id" type="notation">}}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="HoTT.Overture.html#:equiv_scope:x_'<~>'_x"><span class="id" type="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Overture.html#IsEquiv"><span class="id" type="class">IsEquiv</span></a> <a class="idref" href="HoTT.types.Record.html#f"><span class="id" type="variable">f</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">issig</span> (<a class="idref" href="HoTT.Overture.html#BuildIsEquiv"><span class="id" type="constructor">BuildIsEquiv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#equiv_inv"><span class="id" type="method">equiv_inv</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#eisretr"><span class="id" type="method">eisretr</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<a class="idref" href="HoTT.Overture.html#eissect"><span class="id" type="method">eissect</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>) (@<a class="idref" href="HoTT.Overture.html#eisadj"><span class="id" type="method">eisadj</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>