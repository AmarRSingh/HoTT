<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Table of contents</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div id="toc">
<a href="HoTT.Functorish.html"><h2>Library HoTT.Functorish</h2></a>
<a href="HoTT.HSet.html"><h2>Library HoTT.HSet</h2></a>
<ul class="doclist">
<li><a href="HoTT.HSet.html#lab1">H-Sets</a>

</li>
</ul>
<a href="HoTT.EquivalenceVarieties.html"><h2>Library HoTT.EquivalenceVarieties</h2></a>
<ul class="doclist">
<li><a href="HoTT.EquivalenceVarieties.html#lab2">Comparing definitions of equivalence</a>
<ul class="doclist">
<li><a href="HoTT.EquivalenceVarieties.html#lab3">Contractible maps</a>

</li>
<li><a href="HoTT.EquivalenceVarieties.html#lab4">Bi-invertible maps</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.Fibrations.html"><h2>Library HoTT.Fibrations</h2></a>
<ul class="doclist">
<li><a href="HoTT.Fibrations.html#lab5">Basic facts about fibrations</a>

</li>
</ul>
<a href="HoTT.Misc.html"><h2>Library HoTT.Misc</h2></a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.Misc.html#lab6">Null homotopies of maps</a>

</li>
<li><a href="HoTT.Misc.html#lab7">Sigmas of hprops.</a>
<ul class="doclist">
<li><a href="HoTT.Misc.html#lab8">Paths between equivalences</a>

</li>
</ul>

</li>
<li><a href="HoTT.Misc.html#lab9">Equivalences between contractible types</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.Tactics.html"><h2>Library HoTT.Tactics</h2></a>
<ul class="doclist">
<li><a href="HoTT.Tactics.html#lab10">Extra tactics for homotopy type theory.</a>
<ul class="doclist">
<li><a href="HoTT.Tactics.html#lab11">Tactics for dealing with <span class="inlinecode"><span class="id" type="var">Funext</span></span></a>
<ul class="doclist">
<li><a href="HoTT.Tactics.html#lab12">Tactics about <span class="inlinecode"><span class="id" type="var">transport</span></span>ing with <span class="inlinecode"><span class="id" type="var">path_forall</span></span></a>

</li>
</ul>

</li>
<li><a href="HoTT.Tactics.html#lab13">A more powerful variant of <span class="inlinecode"><span class="id" type="var">path_induction</span></span></a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.UnivalenceAxiom.html"><h2>Library HoTT.UnivalenceAxiom</h2></a>
<a href="HoTT.PathGroupoids.html"><h2>Library HoTT.PathGroupoids</h2></a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.PathGroupoids.html#lab14">Naming conventions</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab15">The 1-dimensional groupoid structure.</a>
<ul class="doclist">
<li><a href="HoTT.PathGroupoids.html#lab16">Functoriality of functions</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab17">Action of <span class="inlinecode"><span class="id" type="var">apD10</span></span> and <span class="inlinecode"><span class="id" type="var">ap10</span></span> on paths.</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab18">Transport and the groupoid structure of paths</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab19">Transporting in particular fibrations.</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab20">The behavior of <span class="inlinecode"><span class="id" type="var">ap</span></span> and <span class="inlinecode"><span class="id" type="var">apD</span></span>.</a>

</li>
</ul>

</li>
<li><a href="HoTT.PathGroupoids.html#lab21">The 2-dimensional groupoid structure</a>
<ul class="doclist">
<li><a href="HoTT.PathGroupoids.html#lab22">Whiskering</a>

</li>
<li><a href="HoTT.PathGroupoids.html#lab23">Unwhiskering, a.k.a. cancelling.</a>

</li>
</ul>

</li>
<li><a href="HoTT.PathGroupoids.html#lab24">Tactics, hints, and aliases</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.Conjugation.html"><h2>Library HoTT.Conjugation</h2></a>
<a href="HoTT.hit.Suspension.html"><h2>Library HoTT.hit.Suspension</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Suspension.html#lab25">The suspension of a type</a>
<ul class="doclist">
<li><a href="HoTT.hit.Suspension.html#lab26">Eta-rule.</a>

</li>
<li><a href="HoTT.hit.Suspension.html#lab27">Nullhomotopies of maps out of suspensions</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.quotient.html"><h2>Library HoTT.hit.quotient</h2></a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.hit.quotient.html#lab28">Quotient of a Type by a set-valued relation</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.unique_choice.html"><h2>Library HoTT.hit.unique_choice</h2></a>
<a href="HoTT.hit.Interval.html"><h2>Library HoTT.hit.Interval</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Interval.html#lab29">Theorems about the homotopical interval.</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.hit.Interval.html#lab30">From an interval type, we can prove function extensionality.</a>

</li>
<li><a href="HoTT.hit.Interval.html#lab31">The interval is contractible.</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.Connectedness.html"><h2>Library HoTT.hit.Connectedness</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Connectedness.html#lab32">Connectedness</a>
<ul class="doclist">
<li><a href="HoTT.hit.Connectedness.html#lab33">Connectedness</a>

</li>
<li><a href="HoTT.hit.Connectedness.html#lab34">Extensions</a>

</li>
<li><a href="HoTT.hit.Connectedness.html#lab35">Connectivity of pointed types</a>

</li>
<li><a href="HoTT.hit.Connectedness.html#lab36">Connectivity of the wedge into the product.</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.Flattening.html"><h2>Library HoTT.hit.Flattening</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Flattening.html#lab37">The flattening lemma.</a>

</li>
</ul>
<a href="HoTT.hit.Circle.html"><h2>Library HoTT.hit.Circle</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Circle.html#lab38">Theorems about the circle S^1.</a>

</li>
</ul>
<a href="HoTT.hit.epi.html"><h2>Library HoTT.hit.epi</h2></a>
<a href="HoTT.hit.Truncations.html"><h2>Library HoTT.hit.Truncations</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Truncations.html#lab39">Truncations of types, in all dimensions.</a>
<ul class="doclist">
<li><a href="HoTT.hit.Truncations.html#lab40">Definition.</a>

</li>
<li><a href="HoTT.hit.Truncations.html#lab41">Functoriality</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.Spheres.html"><h2>Library HoTT.hit.Spheres</h2></a>
<ul class="doclist">
<li><a href="HoTT.hit.Spheres.html#lab42">The spheres, in all dimensions.</a>
<ul class="doclist">
<li><a href="HoTT.hit.Spheres.html#lab43">Definition, by iterated suspension.</a>

</li>
<li><a href="HoTT.hit.Spheres.html#lab44">Explicit equivalences in low dimensions</a>

</li>
<li><a href="HoTT.hit.Spheres.html#lab45">Truncatedness via spheres</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.hit.minus1Trunc.html"><h2>Library HoTT.hit.minus1Trunc</h2></a>
<a href="HoTT.HProp.html"><h2>Library HoTT.HProp</h2></a>
<ul class="doclist">
<li><a href="HoTT.HProp.html#lab46">HPropositions</a>
<ul class="doclist">
<li><a href="HoTT.HProp.html#lab47">Facts about <span class="inlinecode"><span class="id" type="var">IsHProp</span></span></a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.TruncType.html"><h2>Library HoTT.TruncType</h2></a>
<ul class="doclist">
<li><a href="HoTT.TruncType.html#lab48">Universes of truncated types.</a>
<ul class="doclist">
<li><a href="HoTT.TruncType.html#lab49"><span class="inlinecode"><span class="id" type="var">TruncType</span></span>: Universes of truncated types</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.HoTT.html"><h2>Library HoTT.HoTT</h2></a>
<a href="HoTT.FunextAxiom.html"><h2>Library HoTT.FunextAxiom</h2></a>
<a href="HoTT.types.Record.html"><h2>Library HoTT.types.Record</h2></a>
<a href="HoTT.types.Prod.html"><h2>Library HoTT.types.Prod</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Prod.html#lab50">Theorems about cartesian products</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Prod.html#lab51">Unpacking</a>

</li>
<li><a href="HoTT.types.Prod.html#lab52">Eta conversion</a>

</li>
<li><a href="HoTT.types.Prod.html#lab53">Paths</a>

</li>
<li><a href="HoTT.types.Prod.html#lab54">Transport</a>

</li>
<li><a href="HoTT.types.Prod.html#lab55">Functorial action</a>

</li>
<li><a href="HoTT.types.Prod.html#lab56">Equivalences</a>

</li>
<li><a href="HoTT.types.Prod.html#lab57">Symmetry</a>

</li>
<li><a href="HoTT.types.Prod.html#lab58">Universal mapping properties</a>

</li>
<li><a href="HoTT.types.Prod.html#lab59">Products preserve truncation</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Sum.html"><h2>Library HoTT.types.Sum</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Sum.html#lab60">Theorems about disjoint unions</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Sum.html#lab61">CoUnpacking</a>

</li>
<li><a href="HoTT.types.Sum.html#lab62">Eta conversion</a>

</li>
<li><a href="HoTT.types.Sum.html#lab63">Paths</a>

</li>
<li><a href="HoTT.types.Sum.html#lab64">Transport</a>

</li>
<li><a href="HoTT.types.Sum.html#lab65">Functorial action</a>

</li>
<li><a href="HoTT.types.Sum.html#lab66">Equivalences</a>

</li>
<li><a href="HoTT.types.Sum.html#lab67">Symmetry</a>

</li>
<li><a href="HoTT.types.Sum.html#lab68">Universal mapping properties</a>

</li>
<li><a href="HoTT.types.Sum.html#lab69">Sums preserve most truncation</a>

</li>
<li><a href="HoTT.types.Sum.html#lab70">Binary coproducts are equivalent to dependent sigmas where the first component is a bool.</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Sigma.html"><h2>Library HoTT.types.Sigma</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Sigma.html#lab71">Theorems about Sigma-types (dependent sums)</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Sigma.html#lab72">Unpacking</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab73">Eta conversion</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab74">Paths</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab75">Transport</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab76">Functorial action</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab77">Equivalences</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab78">Associativity</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab79">Universal mapping properties</a>

</li>
<li><a href="HoTT.types.Sigma.html#lab80">Sigmas preserve truncation</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Universe.html"><h2>Library HoTT.types.Universe</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Universe.html#lab81">Theorems about the universe, including the Univalence Axiom.</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Universe.html#lab82">Paths</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Paths.html"><h2>Library HoTT.types.Paths</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Paths.html#lab83">Theorems about path spaces</a>
<ul class="doclist">
<li><a href="HoTT.types.Paths.html#lab84">Path spaces</a>

</li>
<li><a href="HoTT.types.Paths.html#lab85">Transporting in path spaces.</a>

</li>
<li><a href="HoTT.types.Paths.html#lab86">Functorial action</a>

</li>
<li><a href="HoTT.types.Paths.html#lab87">Equivalences between path spaces</a>

</li>
<li><a href="HoTT.types.Paths.html#lab88">Path operations are equivalences</a>
<ul class="doclist">
<li><a href="HoTT.types.Paths.html#lab89">Dependent paths</a>

</li>
</ul>

</li>
<li><a href="HoTT.types.Paths.html#lab90">Universal mapping property</a>

</li>
<li><a href="HoTT.types.Paths.html#lab91">Truncation</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Bool.html"><h2>Library HoTT.types.Bool</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Bool.html#lab92">Theorems about the booleans</a>

</li>
</ul>
<a href="HoTT.types.Empty.html"><h2>Library HoTT.types.Empty</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Empty.html#lab93">Theorems about the empty type</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Empty.html#lab94">Unpacking</a>

</li>
<li><a href="HoTT.types.Empty.html#lab95">Eta conversion</a>

</li>
<li><a href="HoTT.types.Empty.html#lab96">Paths</a>

</li>
<li><a href="HoTT.types.Empty.html#lab97">Transport</a>

</li>
<li><a href="HoTT.types.Empty.html#lab98">Functorial action</a>

</li>
<li><a href="HoTT.types.Empty.html#lab99">Equivalences</a>

</li>
<li><a href="HoTT.types.Empty.html#lab100">Universal mapping properties</a>

</li>
<li><a href="HoTT.types.Empty.html#lab101">Behavior with respect to truncation</a>

</li>
<li><a href="HoTT.types.Empty.html#lab102">Paths</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Forall.html"><h2>Library HoTT.types.Forall</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Forall.html#lab103">Theorems about dependent products</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Forall.html#lab104">Paths</a>

</li>
<li><a href="HoTT.types.Forall.html#lab105">Transport</a>

</li>
<li><a href="HoTT.types.Forall.html#lab106">Maps on paths</a>

</li>
<li><a href="HoTT.types.Forall.html#lab107">Dependent paths</a>

</li>
<li><a href="HoTT.types.Forall.html#lab108">Functorial action</a>

</li>
<li><a href="HoTT.types.Forall.html#lab109">Equivalences</a>

</li>
<li><a href="HoTT.types.Forall.html#lab110">Truncatedness: any dependent product of n-types is an n-type</a>

</li>
<li><a href="HoTT.types.Forall.html#lab111">Symmetry of curried arguments</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.ObjectClassifier.html"><h2>Library HoTT.types.ObjectClassifier</h2></a>
<a href="HoTT.types.Unit.html"><h2>Library HoTT.types.Unit</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Unit.html#lab112">Theorems about the unit type</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Unit.html#lab113">Eta conversion</a>

</li>
<li><a href="HoTT.types.Unit.html#lab114">Paths</a>

</li>
<li><a href="HoTT.types.Unit.html#lab115">Transport</a>

</li>
<li><a href="HoTT.types.Unit.html#lab116">Universal mapping properties</a>

</li>
<li><a href="HoTT.types.Unit.html#lab117">Truncation</a>

</li>
<li><a href="HoTT.types.Unit.html#lab118">Equivalences</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.types.Arrow.html"><h2>Library HoTT.types.Arrow</h2></a>
<ul class="doclist">
<li><a href="HoTT.types.Arrow.html#lab119">Theorems about Non-dependent function types</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.types.Arrow.html#lab120">Paths</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab121">Transport</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab122">Dependent paths</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab123">Maps on paths</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab124">Functorial action</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab125">Truncatedness: functions into an n-type is an n-type</a>

</li>
<li><a href="HoTT.types.Arrow.html#lab126">Equivalences</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="HoTT.Equivalences.html"><h2>Library HoTT.Equivalences</h2></a>
<ul class="doclist">
<li><a href="HoTT.Equivalences.html#lab127">Equivalences -*- mode: coq; mode: visual-line -*-</a>

</li>
</ul>
<a href="HoTT.Contractible.html"><h2>Library HoTT.Contractible</h2></a>
<a href="HoTT.FunextVarieties.html"><h2>Library HoTT.FunextVarieties</h2></a>
<a href="HoTT.Trunc.html"><h2>Library HoTT.Trunc</h2></a>
<ul class="doclist">
<li><a href="HoTT.Trunc.html#lab128">Truncatedness</a>
<ul class="doclist">
<li><a href="HoTT.Trunc.html#lab129">Arithmetic on truncation-levels.</a>

</li>
<li><a href="HoTT.Trunc.html#lab130">Truncatedness proper.</a>

</li>
</ul>

</li>
</ul>
<a href="HoTT.Overture.html"><h2>Library HoTT.Overture</h2></a>
<ul class="doclist">
<li><a href="HoTT.Overture.html#lab131">Basic definitions of homotopy type theory, particularly the groupoid structure of identity types.</a>
<ul class="doclist">
<li><a href="HoTT.Overture.html#lab132">Type classes</a>

</li>
<li><a href="HoTT.Overture.html#lab133">Basic definitions</a>

</li>
<li><a href="HoTT.Overture.html#lab134">The groupoid structure of identity types.</a>

</li>
<li><a href="HoTT.Overture.html#lab135">Equivalences</a>

</li>
<li><a href="HoTT.Overture.html#lab136">Contractibility and truncation levels</a>

</li>
</ul>

</li>
<li><a href="HoTT.Overture.html#lab137">We prefer to reason about <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span class="id" type="var">A</span></span> rather than <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(@<span class="id" type="var">paths</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode"><span class="id" type="var">b</span>)</span>.  Whenever we see a statement (or goal) about truncation of paths, we try to turn it into a statement (or goal) about truncation of a (non-<span class="inlinecode"><span class="id" type="var">paths</span></span>) type.  We do not allow typeclass resolution to go in the reverse direction from <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span class="id" type="var">A</span></span> to <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b</span>)</span>.</a>

</li>
<li><a href="HoTT.Overture.html#lab138">We prefer to reason about syntactically smaller types.  That is, typeclass instances should turn goals of type <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">a</span>)</span> into goals of type <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">a</span>)</span>; and goals of type <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">B</span>)</span> into the pair of goals of type <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> and <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>; rather than the other way around.  Ideally, we would add similar rules to transform hypotheses in the cases where we can do so.  This rule is not always the one we want, but it seems to heuristically capture the shape of most cases that we want the typeclass machinery to automatically infer.  That is, we often want to infer <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">B</span>)</span> from <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> and <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>, but we (probably) don't often need to do other simple things with <span class="inlinecode"><span class="id" type="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">(<span class="id" type="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">B</span>)</span> which are broken by that reduction.</a>
<ul class="doclist">
<li><ul class="doclist">
<li><a href="HoTT.Overture.html#lab139">Contractibility</a>

</li>
<li><a href="HoTT.Overture.html#lab140">Truncation levels</a>

</li>
<li><a href="HoTT.Overture.html#lab141">Function extensionality</a>

</li>
<li><a href="HoTT.Overture.html#lab142">Tactics</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="Coq.Program.Tactics.html"><h2>Library Coq.Program.Tactics</h2></a>
<a href="Coq.Init.Specif.html"><h2>Library Coq.Init.Specif</h2></a>
<ul class="doclist">
<li><ul class="doclist">
<li><ul class="doclist">
<li><a href="Coq.Init.Specif.html#lab143">Notations</a>

</li>
</ul>

</li>
</ul>

</li>
</ul>
<a href="Coq.Init.Prelude.html"><h2>Library Coq.Init.Prelude</h2></a>
<a href="Coq.Init.Peano.html"><h2>Library Coq.Init.Peano</h2></a>
<a href="Coq.Init.Notations.html"><h2>Library Coq.Init.Notations</h2></a>
<a href="Coq.Init.Tactics.html"><h2>Library Coq.Init.Tactics</h2></a>
<a href="Coq.Init.Logic_Type.html"><h2>Library Coq.Init.Logic_Type</h2></a>
<a href="Coq.Init.Datatypes.html"><h2>Library Coq.Init.Datatypes</h2></a>
<a href="Coq.Init.Logic.html"><h2>Library Coq.Init.Logic</h2></a>
<ul class="doclist">
<li><a href="Coq.Init.Logic.html#lab144">Propositional connectives</a>

</li>
</ul>
<a href="Coq.Bool.Bool.html"><h2>Library Coq.Bool.Bool</h2></a>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>